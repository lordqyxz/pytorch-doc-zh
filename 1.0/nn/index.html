
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
        <link rel="canonical" href="https://pytorch.apachecn.org/1.0/nn/">
      
      
        <link rel="prev" href="../storage/">
      
      
        <link rel="next" href="../nn_functional/">
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.4.3, mkdocs-material-9.1.17">
    
    
      
        <title>torch.nn - 【布客】PyTorch 中文翻译</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.26e3688c.min.css">
      
      

    
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce((e,_)=>(e<<5)-e+_.charCodeAt(0),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  <link rel="stylesheet" href="../../assets/stylesheets/custom.bea7efe8.min.css">
  <!-- google ads -->
  <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3565452474788507" crossorigin="anonymous"></script>
  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-8DP4GX97XY"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-8DP4GX97XY');
  </script>
  <!-- google webmaster -->
  <meta name="google-site-verification" content="pyo9N70ZWyh8JB43bIu633mhxesJ1IcwWCZlM3jUfFo" />

  <!-- wwads-cn union -->
  <meta name="wwads-cn-verify" content="03c6b06952c750899bb03d998e631860" />
  <script type="text/javascript" charset="UTF-8" src="https://cdn.wwads.cn/js/makemoney.js" async></script>

  </head>
  
  
    <body dir="ltr">
  
    
    
      <script>var palette=__md_get("__palette");if(palette&&"object"==typeof palette.color)for(var key of Object.keys(palette.color))document.body.setAttribute("data-md-color-"+key,palette.color[key])</script>
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#torchnn" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
        <aside class="md-banner">
          <div class="md-banner__inner md-grid md-typeset">
            
            
  => 组织无偿提供 中文版本（免费，秒级响应）
  <a target="_blank" href="https://chat.ibooker.org.cn/chat" style="color: red;">
    <span class="twemoji mastodon">
      <img src="https://data.apachecn.org/img/icon/ROBOT_TXT.svg" alt="ChatGPT - ailake.top">
    </span>
    <strong>ChatGPT - ailake.top</strong>
  </a> 一起来白嫖叭～！

          </div>
          
        </aside>
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="【布客】PyTorch 中文翻译" class="md-header__button md-logo" aria-label="【布客】PyTorch 中文翻译" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3V6m0 5h18v2H3v-2m0 5h18v2H3v-2Z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            【布客】PyTorch 中文翻译
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              torch.nn
            
          </span>
        </div>
      </div>
    </div>
    
    
    
      <label class="md-header__button md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
      </label>
      <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.516 6.516 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5Z"/></svg>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12 19 6.41Z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
    
    
      <div class="md-header__source">
        <a href="https://github.com/apachecn/pytorch-doc-zh" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    apachecn/pytorch-doc-zh
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    


<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="【布客】PyTorch 中文翻译" class="md-nav__button md-logo" aria-label="【布客】PyTorch 中文翻译" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54Z"/></svg>

    </a>
    【布客】PyTorch 中文翻译
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/apachecn/pytorch-doc-zh" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.4.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2023 Fonticons, Inc.--><path d="M439.55 236.05 244 40.45a28.87 28.87 0 0 0-40.81 0l-40.66 40.63 51.52 51.52c27.06-9.14 52.68 16.77 43.39 43.68l49.66 49.66c34.23-11.8 61.18 31 35.47 56.69-26.49 26.49-70.21-2.87-56-37.34L240.22 199v121.85c25.3 12.54 22.26 41.85 9.08 55a34.34 34.34 0 0 1-48.55 0c-17.57-17.6-11.07-46.91 11.25-56v-123c-20.8-8.51-24.6-30.74-18.64-45L142.57 101 8.45 235.14a28.86 28.86 0 0 0 0 40.81l195.61 195.6a28.86 28.86 0 0 0 40.8 0l194.69-194.69a28.86 28.86 0 0 0 0-40.81z"/></svg>
  </div>
  <div class="md-source__repository">
    apachecn/pytorch-doc-zh
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        PyTorch 中文文档 & 教程
      </a>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
          PyTorch 2.0 中文文档 & 教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 2.0 中文文档 & 教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_1" >
      
      
      
        <label class="md-nav__link" for="__nav_2_1" id="__nav_2_1_label" tabindex="0">
          中文教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_1">
          <span class="md-nav__icon md-icon"></span>
          中文教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../2.0/tutorials/README.md" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_2" >
      
      
      
        <label class="md-nav__link" for="__nav_2_2" id="__nav_2_2_label" tabindex="0">
          中文文档
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_2_2">
          <span class="md-nav__icon md-icon"></span>
          中文文档
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../2.0/docs/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
      
      
      
        <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
          PyTorch 1.7 中文文档
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 1.7 中文文档
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" >
      
      
      
        <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
          学习 PyTorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_1">
          <span class="md-nav__icon md-icon"></span>
          学习 PyTorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_1" >
      
      
      
        <label class="md-nav__link" for="__nav_3_1_1" id="__nav_3_1_1_label" tabindex="0">
          PyTorch 深度学习：60 分钟的突击
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_1_1">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 深度学习：60 分钟的突击
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/02/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/03/" class="md-nav__link">
        张量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/04/" class="md-nav__link">
        torch.autograd的简要介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/05/" class="md-nav__link">
        神经网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/06/" class="md-nav__link">
        训练分类器
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1_2" >
      
      
      
        <label class="md-nav__link" for="__nav_3_1_2" id="__nav_3_1_2_label" tabindex="0">
          通过示例学习 PyTorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_3_1_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_1_2">
          <span class="md-nav__icon md-icon"></span>
          通过示例学习 PyTorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/07/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/08/" class="md-nav__link">
        热身：NumPy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/09/" class="md-nav__link">
        PyTorch：张量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/10/" class="md-nav__link">
        PyTorch：张量和 Autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/11/" class="md-nav__link">
        PyTorch：定义新的 Autograd 函数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/12/" class="md-nav__link">
        PyTorch：nn
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/13/" class="md-nav__link">
        PyTorch：optim
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/14/" class="md-nav__link">
        PyTorch：自定义nn模块
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/15/" class="md-nav__link">
        PyTorch：控制流 - 权重共享
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/16/" class="md-nav__link">
        torch.nn到底是什么？
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/17/" class="md-nav__link">
        使用 TensorBoard 可视化模型，数据和训练
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
      
      
      
        <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
          图片/视频
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_2">
          <span class="md-nav__icon md-icon"></span>
          图片/视频
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/19/" class="md-nav__link">
        torchvision对象检测微调教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/20/" class="md-nav__link">
        计算机视觉的迁移学习教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/21/" class="md-nav__link">
        对抗示例生成
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/22/" class="md-nav__link">
        DCGAN 教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
      
      
      
        <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
          音频
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_3">
          <span class="md-nav__icon md-icon"></span>
          音频
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/24/" class="md-nav__link">
        音频 I/O 和torchaudio的预处理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/25/" class="md-nav__link">
        使用torchaudio的语音命令识别
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4" >
      
      
      
        <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
          文本
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_4">
          <span class="md-nav__icon md-icon"></span>
          文本
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/27/" class="md-nav__link">
        使用nn.Transformer和torchtext的序列到序列建模
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/28/" class="md-nav__link">
        从零开始的 NLP：使用字符级 RNN 分类名称
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/29/" class="md-nav__link">
        从零开始的 NLP：使用字符级 RNN 生成名称
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/30/" class="md-nav__link">
        从零开始的 NLP：使用序列到序列网络和注意力的翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/31/" class="md-nav__link">
        使用torchtext的文本分类
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/32/" class="md-nav__link">
        torchtext语言翻译
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_5" >
      
      
      
        <label class="md-nav__link" for="__nav_3_5" id="__nav_3_5_label" tabindex="0">
          强化学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_5">
          <span class="md-nav__icon md-icon"></span>
          强化学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/34/" class="md-nav__link">
        强化学习（DQN）教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/35/" class="md-nav__link">
        训练玩马里奥的 RL 智能体
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_6" >
      
      
      
        <label class="md-nav__link" for="__nav_3_6" id="__nav_3_6_label" tabindex="0">
          在生产中部署 PyTorch 模型
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_6">
          <span class="md-nav__icon md-icon"></span>
          在生产中部署 PyTorch 模型
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/37/" class="md-nav__link">
        通过使用 Flask 的 REST API 在 Python 中部署 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/38/" class="md-nav__link">
        TorchScript 简介
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/39/" class="md-nav__link">
        在 C-- 中加载 TorchScript 模型
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/40/" class="md-nav__link">
        将模型从 PyTorch 导出到 ONNX 并使用 ONNX 运行时运行它（可选）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_7" >
      
      
      
        <label class="md-nav__link" for="__nav_3_7" id="__nav_3_7_label" tabindex="0">
          前端 API
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_7">
          <span class="md-nav__icon md-icon"></span>
          前端 API
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/42/" class="md-nav__link">
        PyTorch 中的命名张量简介（原型）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/43/" class="md-nav__link">
        PyTorch 中通道在最后的内存格式（beta）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/44/" class="md-nav__link">
        使用 PyTorch C-- 前端
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/45/" class="md-nav__link">
        自定义 C-- 和 CUDA 扩展
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/46/" class="md-nav__link">
        使用自定义 C-- 运算符扩展 TorchScript
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/47/" class="md-nav__link">
        使用自定义 C-- 类扩展 TorchScript
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/48/" class="md-nav__link">
        TorchScript 中的动态并行性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/49/" class="md-nav__link">
        C-- 前端中的 Autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/50/" class="md-nav__link">
        在 C-- 中注册调度运算符
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_8" >
      
      
      
        <label class="md-nav__link" for="__nav_3_8" id="__nav_3_8_label" tabindex="0">
          模型优化
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_8">
          <span class="md-nav__icon md-icon"></span>
          模型优化
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/52/" class="md-nav__link">
        分析您的 PyTorch 模块
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/53/" class="md-nav__link">
        使用 Ray Tune 的超参数调整
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/54/" class="md-nav__link">
        模型剪裁教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/55/" class="md-nav__link">
        LSTM 单词语言模型上的动态量化（beta）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/56/" class="md-nav__link">
        BERT 上的动态量化（Beta）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/57/" class="md-nav__link">
        PyTorch 中使用 Eager 模式的静态量化（beta）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/58/" class="md-nav__link">
        计算机视觉的量化迁移学习教程（beta）
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_9" >
      
      
      
        <label class="md-nav__link" for="__nav_3_9" id="__nav_3_9_label" tabindex="0">
          并行和分布式训练
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_9_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_3_9">
          <span class="md-nav__icon md-icon"></span>
          并行和分布式训练
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/60/" class="md-nav__link">
        PyTorch 分布式概述
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/61/" class="md-nav__link">
        单机模型并行最佳实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/62/" class="md-nav__link">
        分布式数据并行入门
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/63/" class="md-nav__link">
        用 PyTorch 编写分布式应用
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/64/" class="md-nav__link">
        分布式 RPC 框架入门
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/65/" class="md-nav__link">
        使用分布式 RPC 框架实现参数服务器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/66/" class="md-nav__link">
        使用 RPC 的分布式管道并行化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/67/" class="md-nav__link">
        使用异步执行实现批量 RPC 处理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.7/68/" class="md-nav__link">
        将分布式DataParallel与分布式 RPC 框架相结合
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
      
      
      
        <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
          PyTorch 1.4 中文文档 & 教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 1.4 中文文档 & 教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1" >
      
      
      
        <label class="md-nav__link" for="__nav_4_1" id="__nav_4_1_label" tabindex="0">
          入门
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_1">
          <span class="md-nav__icon md-icon"></span>
          入门
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_1_1" >
      
      
      
        <label class="md-nav__link" for="__nav_4_1_1" id="__nav_4_1_1_label" tabindex="0">
          使用 PyTorch 进行深度学习：60 分钟的闪电战
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_4_1_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_1_1">
          <span class="md-nav__icon md-icon"></span>
          使用 PyTorch 进行深度学习：60 分钟的闪电战
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/4/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/blitz/tensor_tutorial/" class="md-nav__link">
        什么是PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/blitz/autograd_tutorial/" class="md-nav__link">
        Autograd：自动求导
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/blitz/neural_networks_tutorial/" class="md-nav__link">
        神经网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/blitz/cifar10_tutorial/" class="md-nav__link">
        训练分类器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/blitz/data_parallel_tutorial/" class="md-nav__link">
        可选：数据并行
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/5/" class="md-nav__link">
        编写自定义数据集，数据加载器和转换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/6/" class="md-nav__link">
        使用 TensorBoard 可视化模型，数据和训练
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_2" >
      
      
      
        <label class="md-nav__link" for="__nav_4_2" id="__nav_4_2_label" tabindex="0">
          图片
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_2">
          <span class="md-nav__icon md-icon"></span>
          图片
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/8/" class="md-nav__link">
        TorchVision 对象检测微调教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/9/" class="md-nav__link">
        转移学习的计算机视觉教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/10/" class="md-nav__link">
        空间变压器网络教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/11/" class="md-nav__link">
        使用 PyTorch 进行神经传递
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/12/" class="md-nav__link">
        对抗示例生成
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/13/" class="md-nav__link">
        DCGAN 教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_3" >
      
      
      
        <label class="md-nav__link" for="__nav_4_3" id="__nav_4_3_label" tabindex="0">
          音频
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_3">
          <span class="md-nav__icon md-icon"></span>
          音频
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/15/" class="md-nav__link">
        torchaudio 教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_4" >
      
      
      
        <label class="md-nav__link" for="__nav_4_4" id="__nav_4_4_label" tabindex="0">
          文本
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_4">
          <span class="md-nav__icon md-icon"></span>
          文本
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/17/" class="md-nav__link">
        NLP From Scratch: 使用char-RNN对姓氏进行分类
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/18/" class="md-nav__link">
        NLP From Scratch: 生成名称与字符级RNN
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/19/" class="md-nav__link">
        NLP From Scratch: 基于注意力机制的 seq2seq 神经网络翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/20/" class="md-nav__link">
        使用 TorchText 进行文本分类
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/21/" class="md-nav__link">
        使用 TorchText 进行语言翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/22/" class="md-nav__link">
        使用 nn.Transformer 和 TorchText 进行序列到序列建模
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_5" >
      
      
      
        <label class="md-nav__link" for="__nav_4_5" id="__nav_4_5_label" tabindex="0">
          命名为 Tensor(实验性）
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_5">
          <span class="md-nav__icon md-icon"></span>
          命名为 Tensor(实验性）
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/24/" class="md-nav__link">
        (实验性)PyTorch 中的命名张量简介
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_6" >
      
      
      
        <label class="md-nav__link" for="__nav_4_6" id="__nav_4_6_label" tabindex="0">
          强化学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_6">
          <span class="md-nav__icon md-icon"></span>
          强化学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/26/" class="md-nav__link">
        强化学习(DQN)教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_7" >
      
      
      
        <label class="md-nav__link" for="__nav_4_7" id="__nav_4_7_label" tabindex="0">
          在生产中部署 PyTorch 模型
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_7">
          <span class="md-nav__icon md-icon"></span>
          在生产中部署 PyTorch 模型
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/28/" class="md-nav__link">
        通过带有 Flask 的 REST API 在 Python 中部署 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/29/" class="md-nav__link">
        TorchScript 简介
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/30/" class="md-nav__link">
        在 C --中加载 TorchScript 模型
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/31/" class="md-nav__link">
        (可选）将模型从 PyTorch 导出到 ONNX 并使用 ONNX Runtime 运行
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_8" >
      
      
      
        <label class="md-nav__link" for="__nav_4_8" id="__nav_4_8_label" tabindex="0">
          并行和分布式训练
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_8">
          <span class="md-nav__icon md-icon"></span>
          并行和分布式训练
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/33/" class="md-nav__link">
        单机模型并行最佳实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/34/" class="md-nav__link">
        分布式数据并行入门
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/35/" class="md-nav__link">
        用 PyTorch 编写分布式应用程序
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/36/" class="md-nav__link">
        分布式 RPC 框架入门
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/37/" class="md-nav__link">
        (高级）带有 Amazon AWS 的 PyTorch 1.0 分布式训练师
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_9" >
      
      
      
        <label class="md-nav__link" for="__nav_4_9" id="__nav_4_9_label" tabindex="0">
          扩展 PyTorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_9_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_9">
          <span class="md-nav__icon md-icon"></span>
          扩展 PyTorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/39/" class="md-nav__link">
        使用自定义 C --运算符扩展 TorchScript
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/40/" class="md-nav__link">
        使用自定义 C --类扩展 TorchScript
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/41/" class="md-nav__link">
        使用 numpy 和 scipy 创建扩展
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/42/" class="md-nav__link">
        自定义 C --和 CUDA 扩展
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_10" >
      
      
      
        <label class="md-nav__link" for="__nav_4_10" id="__nav_4_10_label" tabindex="0">
          模型优化
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_10_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_10">
          <span class="md-nav__icon md-icon"></span>
          模型优化
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/44/" class="md-nav__link">
        LSTM Word 语言模型上的(实验）动态量化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/45/" class="md-nav__link">
        (实验性）在 PyTorch 中使用 Eager 模式进行静态量化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/46/" class="md-nav__link">
        (实验性）计算机视觉教程的量化转移学习
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/47/" class="md-nav__link">
        (实验）BERT 上的动态量化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/48/" class="md-nav__link">
        修剪教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_11" >
      
      
      
        <label class="md-nav__link" for="__nav_4_11" id="__nav_4_11_label" tabindex="0">
          PyTorch 用其他语言
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_11_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_11">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 用其他语言
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/50/" class="md-nav__link">
        使用 PyTorch C --前端
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_12" >
      
      
      
        <label class="md-nav__link" for="__nav_4_12" id="__nav_4_12_label" tabindex="0">
          PyTorch 基础知识
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_12_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_12">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 基础知识
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/52/" class="md-nav__link">
        通过示例学习 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/53/" class="md-nav__link">
        torch.nn 到底是什么？
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_13" >
      
      
      
        <label class="md-nav__link" for="__nav_4_13" id="__nav_4_13_label" tabindex="0">
          笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_13_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_13">
          <span class="md-nav__icon md-icon"></span>
          笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/56/" class="md-nav__link">
        自动求导机制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/57/" class="md-nav__link">
        广播语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/58/" class="md-nav__link">
        CPU 线程和 TorchScript 推断
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/59/" class="md-nav__link">
        CUDA 语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/60/" class="md-nav__link">
        分布式 Autograd 设计
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/61/" class="md-nav__link">
        扩展 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/62/" class="md-nav__link">
        经常问的问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/63/" class="md-nav__link">
        大规模部署的功能
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/64/" class="md-nav__link">
        并行处理最佳实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/65/" class="md-nav__link">
        重现性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/66/" class="md-nav__link">
        远程参考协议
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/67/" class="md-nav__link">
        序列化语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/68/" class="md-nav__link">
        Windows 常见问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/69/" class="md-nav__link">
        XLA 设备上的 PyTorch
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_14" >
      
      
      
        <label class="md-nav__link" for="__nav_4_14" id="__nav_4_14_label" tabindex="0">
          语言绑定
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_14_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_14">
          <span class="md-nav__icon md-icon"></span>
          语言绑定
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/71/" class="md-nav__link">
        PyTorch C -- API
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/72/" class="md-nav__link">
        PyTorch Java API
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_15" >
      
      
      
        <label class="md-nav__link" for="__nav_4_15" id="__nav_4_15_label" tabindex="0">
          Python API
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_15_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_15">
          <span class="md-nav__icon md-icon"></span>
          Python API
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/74/" class="md-nav__link">
        torch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/75/" class="md-nav__link">
        torch.nn
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/76/" class="md-nav__link">
        torch功能
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/77/" class="md-nav__link">
        torch张量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/78/" class="md-nav__link">
        张量属性
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/79/" class="md-nav__link">
        自动差分包-Torch.Autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/80/" class="md-nav__link">
        torch.cuda
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/81/" class="md-nav__link">
        分布式通讯包-Torch.Distributed
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/82/" class="md-nav__link">
        概率分布-torch分布
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/83/" class="md-nav__link">
        torch.hub
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/84/" class="md-nav__link">
        torch脚本
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/85/" class="md-nav__link">
        torch.nn.init
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/86/" class="md-nav__link">
        torch.onnx
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/87/" class="md-nav__link">
        torch.optim
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/88/" class="md-nav__link">
        量化
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/89/" class="md-nav__link">
        分布式 RPC 框架
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/90/" class="md-nav__link">
        torch随机
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/91/" class="md-nav__link">
        torch稀疏
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/92/" class="md-nav__link">
        torch存储
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/93/" class="md-nav__link">
        torch.utils.bottleneck
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/94/" class="md-nav__link">
        torch.utils.checkpoint
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/95/" class="md-nav__link">
        torch.utils.cpp_extension
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/96/" class="md-nav__link">
        torch.utils.data
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/97/" class="md-nav__link">
        torch.utils.dlpack
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/98/" class="md-nav__link">
        torch.utils.model_zoo
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/99/" class="md-nav__link">
        torch.utils.tensorboard
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/100/" class="md-nav__link">
        类型信息
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/101/" class="md-nav__link">
        命名张量
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/102/" class="md-nav__link">
        命名为 Tensors 操作员范围
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/103/" class="md-nav__link">
        糟糕！
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_16" >
      
      
      
        <label class="md-nav__link" for="__nav_4_16" id="__nav_4_16_label" tabindex="0">
          torchvision参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_16_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_16">
          <span class="md-nav__icon md-icon"></span>
          torchvision参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/105/" class="md-nav__link">
        torchvision
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_17" >
      
      
      
        <label class="md-nav__link" for="__nav_4_17" id="__nav_4_17_label" tabindex="0">
          音频参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_17_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_17">
          <span class="md-nav__icon md-icon"></span>
          音频参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/107/" class="md-nav__link">
        torchaudio
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_18" >
      
      
      
        <label class="md-nav__link" for="__nav_4_18" id="__nav_4_18_label" tabindex="0">
          torchtext参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_18_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_18">
          <span class="md-nav__icon md-icon"></span>
          torchtext参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/109/" class="md-nav__link">
        torchtext
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4_19" >
      
      
      
        <label class="md-nav__link" for="__nav_4_19" id="__nav_4_19_label" tabindex="0">
          社区
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_4_19_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_4_19">
          <span class="md-nav__icon md-icon"></span>
          社区
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/111/" class="md-nav__link">
        PyTorch 贡献指南
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/112/" class="md-nav__link">
        PyTorch 治理
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../1.4/113/" class="md-nav__link">
        PyTorch 治理| 感兴趣的人
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5" id="__nav_5_label" tabindex="0">
          PyTorch 1.0 中文文档 & 教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_5_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_5">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 1.0 中文文档 & 教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../" class="md-nav__link">
        目录
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2" id="__nav_5_2_label" tabindex="0">
          中文教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2">
          <span class="md-nav__icon md-icon"></span>
          中文教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_1" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_1" id="__nav_5_2_1_label" tabindex="0">
          入门
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_1">
          <span class="md-nav__icon md-icon"></span>
          入门
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_1_1" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_1_1" id="__nav_5_2_1_1_label" tabindex="0">
          PyTorch 深度学习: 60 分钟极速入门
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_2_1_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_1_1">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 深度学习: 60 分钟极速入门
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../deep_learning_60min_blitz/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../blitz_tensor_tutorial/" class="md-nav__link">
        什么是 PyTorch？
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../blitz_autograd_tutorial/" class="md-nav__link">
        Autograd：自动求导
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../blitz_neural_networks_tutorial/" class="md-nav__link">
        神经网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../blitz_cifar10_tutorial/" class="md-nav__link">
        训练分类器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../blitz_data_parallel_tutorial/" class="md-nav__link">
        可选：数据并行处理
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data_loading_tutorial/" class="md-nav__link">
        数据加载和处理教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../pytorch_with_examples/" class="md-nav__link">
        用例子学习 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../transfer_learning_tutorial/" class="md-nav__link">
        迁移学习教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../deploy_seq2seq_hybrid_frontend_tutorial/" class="md-nav__link">
        混合前端的 seq2seq 模型部署
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../saving_loading_models/" class="md-nav__link">
        Saving and Loading Models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nn_tutorial/" class="md-nav__link">
        What is torch.nn really?
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_2" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_2" id="__nav_5_2_2_label" tabindex="0">
          图像
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_2">
          <span class="md-nav__icon md-icon"></span>
          图像
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../finetuning_torchvision_models_tutorial/" class="md-nav__link">
        Torchvision 模型微调
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../spatial_transformer_tutorial/" class="md-nav__link">
        空间变换器网络教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../neural_style_tutorial/" class="md-nav__link">
        使用 PyTorch 进行图像风格转换
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../fgsm_tutorial/" class="md-nav__link">
        对抗性示例生成
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../super_resolution_with_caffe2/" class="md-nav__link">
        使用 ONNX 将模型从 PyTorch 传输到 Caffe2 和移动端
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_3" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_3" id="__nav_5_2_3_label" tabindex="0">
          文本
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_3">
          <span class="md-nav__icon md-icon"></span>
          文本
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../chatbot_tutorial/" class="md-nav__link">
        聊天机器人教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../char_rnn_generation_tutorial/" class="md-nav__link">
        使用字符级别特征的 RNN 网络生成姓氏
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../char_rnn_classification_tutorial/" class="md-nav__link">
        使用字符级别特征的 RNN 网络进行姓氏分类
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_3_4" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_3_4" id="__nav_5_2_3_4_label" tabindex="0">
          Deep Learning for NLP with Pytorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_2_3_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_3_4">
          <span class="md-nav__icon md-icon"></span>
          Deep Learning for NLP with Pytorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../deep_learning_nlp_tutorial/" class="md-nav__link">
        在深度学习和 NLP 中使用 Pytorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nlp_pytorch_tutorial/" class="md-nav__link">
        PyTorch 介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nlp_deep_learning_tutorial/" class="md-nav__link">
        使用 PyTorch 进行深度学习
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nlp_word_embeddings_tutorial/" class="md-nav__link">
        Word Embeddings: Encoding Lexical Semantics
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nlp_sequence_models_tutorial/" class="md-nav__link">
        序列模型和 LSTM 网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nlp_advanced_tutorial/" class="md-nav__link">
        Advanced: Making Dynamic Decisions and the Bi-LSTM CRF
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../seq2seq_translation_tutorial/" class="md-nav__link">
        基于注意力机制的 seq2seq 神经网络翻译
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_4" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_4" id="__nav_5_2_4_label" tabindex="0">
          生成
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_4">
          <span class="md-nav__icon md-icon"></span>
          生成
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dcgan_faces_tutorial/" class="md-nav__link">
        DCGAN Tutorial
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_5" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_5" id="__nav_5_2_5_label" tabindex="0">
          强化学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_5">
          <span class="md-nav__icon md-icon"></span>
          强化学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../reinforcement_q_learning/" class="md-nav__link">
        Reinforcement Learning (DQN) Tutorial
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_6" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_6" id="__nav_5_2_6_label" tabindex="0">
          扩展 PyTorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_6">
          <span class="md-nav__icon md-icon"></span>
          扩展 PyTorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../numpy_extensions_tutorial/" class="md-nav__link">
        用 numpy 和 scipy 创建扩展
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp_extension/" class="md-nav__link">
        Custom C-- and CUDA Extensions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_script_custom_ops/" class="md-nav__link">
        Extending TorchScript with Custom C-- Operators
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_7" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_7" id="__nav_5_2_7_label" tabindex="0">
          生产性使用
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_7">
          <span class="md-nav__icon md-icon"></span>
          生产性使用
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dist_tuto/" class="md-nav__link">
        Writing Distributed Applications with PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../aws_distributed_training_tutorial/" class="md-nav__link">
        使用 Amazon AWS 进行分布式训练
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../ONNXLive/" class="md-nav__link">
        ONNX 现场演示教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp_export/" class="md-nav__link">
        在 C-- 中加载 PYTORCH 模型
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_2_8" >
      
      
      
        <label class="md-nav__link" for="__nav_5_2_8" id="__nav_5_2_8_label" tabindex="0">
          其它语言中的 PyTorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_2_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_2_8">
          <span class="md-nav__icon md-icon"></span>
          其它语言中的 PyTorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cpp_frontend/" class="md-nav__link">
        使用 PyTorch C-- 前端
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5_3" id="__nav_5_3_label" tabindex="0">
          中文文档
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_5_3_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_5_3">
          <span class="md-nav__icon md-icon"></span>
          中文文档
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3_1" >
      
      
      
        <label class="md-nav__link" for="__nav_5_3_1" id="__nav_5_3_1_label" tabindex="0">
          注解
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_3_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_3_1">
          <span class="md-nav__icon md-icon"></span>
          注解
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_autograd/" class="md-nav__link">
        自动求导机制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_broadcasting/" class="md-nav__link">
        广播语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_cuda/" class="md-nav__link">
        CUDA 语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_extending/" class="md-nav__link">
        Extending PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_faq/" class="md-nav__link">
        Frequently Asked Questions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_multiprocessing/" class="md-nav__link">
        Multiprocessing best practices
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_randomness/" class="md-nav__link">
        Reproducibility
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_serialization/" class="md-nav__link">
        Serialization semantics
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../notes_windows/" class="md-nav__link">
        Windows FAQ
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
    
  
  
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3_2" checked>
      
      
      
        <label class="md-nav__link" for="__nav_5_3_2" id="__nav_5_3_2_label" tabindex="0">
          包参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_3_2_label" aria-expanded="true">
        <label class="md-nav__title" for="__nav_5_3_2">
          <span class="md-nav__icon md-icon"></span>
          包参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3_2_1" >
      
      
      
        <label class="md-nav__link" for="__nav_5_3_2_1" id="__nav_5_3_2_1_label" tabindex="0">
          torch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_5_3_2_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_3_2_1">
          <span class="md-nav__icon md-icon"></span>
          torch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_tensors/" class="md-nav__link">
        Tensors
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_random_sampling/" class="md-nav__link">
        Random sampling
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_serialization_parallelism_utilities/" class="md-nav__link">
        Serialization, Parallelism, Utilities
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3_2_1_5" >
      
      
      
        <label class="md-nav__link" for="__nav_5_3_2_1_5" id="__nav_5_3_2_1_5_label" tabindex="0">
          Math operations
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="5" aria-labelledby="__nav_5_3_2_1_5_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_3_2_1_5">
          <span class="md-nav__icon md-icon"></span>
          Math operations
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_math_operations_pointwise_ops/" class="md-nav__link">
        Pointwise Ops
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_math_operations_reduction_ops/" class="md-nav__link">
        Reduction Ops
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_math_operations_comparison_ops/" class="md-nav__link">
        Comparison Ops
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_math_operations_spectral_ops/" class="md-nav__link">
        Spectral Ops
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_math_operations_other_ops/" class="md-nav__link">
        Other Operations
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torch_math_operations_blas_lapack_ops/" class="md-nav__link">
        BLAS and LAPACK Operations
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tensors/" class="md-nav__link">
        torch.Tensor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../tensor_attributes/" class="md-nav__link">
        Tensor Attributes
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../type_info/" class="md-nav__link">
        数据类型信息
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../sparse/" class="md-nav__link">
        torch.sparse
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../cuda/" class="md-nav__link">
        torch.cuda
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../storage/" class="md-nav__link">
        torch.Storage
      </a>
    </li>
  

            
          
            
              
  
  
    
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          torch.nn
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        torch.nn
      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters(参数）
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#containers" class="md-nav__link">
    Containers(容器）
  </a>
  
    <nav class="md-nav" aria-label="Containers(容器）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#module" class="md-nav__link">
    Module(模块）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequential" class="md-nav__link">
    Sequential
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modulelist" class="md-nav__link">
    ModuleList (模块列表)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#moduledict" class="md-nav__link">
    ModuleDict (模块词典)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameterlist" class="md-nav__link">
    ParameterList (参数列表)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameterdict" class="md-nav__link">
    ParameterDict (参数词典)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#convolution-layers" class="md-nav__link">
    Convolution layers (卷积层)
  </a>
  
    <nav class="md-nav" aria-label="Convolution layers (卷积层)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#conv1d" class="md-nav__link">
    Conv1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv2d" class="md-nav__link">
    Conv2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv3d" class="md-nav__link">
    Conv3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose1d" class="md-nav__link">
    ConvTranspose1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose2d" class="md-nav__link">
    ConvTranspose2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose3d" class="md-nav__link">
    ConvTranspose3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unfold" class="md-nav__link">
    Unfold
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fold" class="md-nav__link">
    Fold
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pooling-layers" class="md-nav__link">
    池化层(Pooling layers）
  </a>
  
    <nav class="md-nav" aria-label="池化层(Pooling layers）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxpool1d" class="md-nav__link">
    MaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool2d" class="md-nav__link">
    MaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool3d" class="md-nav__link">
    MaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool1d" class="md-nav__link">
    MaxUnpool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool2d" class="md-nav__link">
    MaxUnpool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool3d" class="md-nav__link">
    MaxUnpool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool1d" class="md-nav__link">
    AvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool2d" class="md-nav__link">
    AvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool3d" class="md-nav__link">
    AvgPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractionalmaxpool2d" class="md-nav__link">
    FractionalMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lppool1d" class="md-nav__link">
    LPPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lppool2d" class="md-nav__link">
    LPPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool1d" class="md-nav__link">
    AdaptiveMaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool2d" class="md-nav__link">
    AdaptiveMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool3d" class="md-nav__link">
    AdaptiveMaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool1d" class="md-nav__link">
    AdaptiveAvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool2d" class="md-nav__link">
    AdaptiveAvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool3d" class="md-nav__link">
    AdaptiveAvgPool3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#padding-layers" class="md-nav__link">
    填充层(Padding layers）
  </a>
  
    <nav class="md-nav" aria-label="填充层(Padding layers）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reflectionpad1d" class="md-nav__link">
    ReflectionPad1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reflectionpad2d" class="md-nav__link">
    ReflectionPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad1d" class="md-nav__link">
    ReplicationPad1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad2d" class="md-nav__link">
    ReplicationPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad3d" class="md-nav__link">
    ReplicationPad3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeropad2d" class="md-nav__link">
    ZeroPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad1d" class="md-nav__link">
    ConstantPad1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad2d" class="md-nav__link">
    ConstantPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad3d" class="md-nav__link">
    ConstantPad3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#non-linear-activations-weighted-sum-nonlinearity" class="md-nav__link">
    非线性激活(加权求和，非线性) ( Non-linear activations (weighted sum, nonlinearity))
  </a>
  
    <nav class="md-nav" aria-label="非线性激活(加权求和，非线性) ( Non-linear activations (weighted sum, nonlinearity))">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#elu" class="md-nav__link">
    ELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hardshrink" class="md-nav__link">
    Hardshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hardtanh" class="md-nav__link">
    Hardtanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leakyrelu" class="md-nav__link">
    LeakyReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsigmoid" class="md-nav__link">
    LogSigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prelu" class="md-nav__link">
    PReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relu" class="md-nav__link">
    ReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relu6" class="md-nav__link">
    ReLU6
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rrelu" class="md-nav__link">
    RReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selu" class="md-nav__link">
    SELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#celu" class="md-nav__link">
    CELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sigmoid" class="md-nav__link">
    Sigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softplus" class="md-nav__link">
    Softplus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softshrink" class="md-nav__link">
    Softshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softsign" class="md-nav__link">
    Softsign
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanh" class="md-nav__link">
    Tanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhshrink" class="md-nav__link">
    Tanhshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threshold" class="md-nav__link">
    Threshold
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#non-linear-activations-other" class="md-nav__link">
    Non-linear activations (other)
  </a>
  
    <nav class="md-nav" aria-label="Non-linear activations (other)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#softmin" class="md-nav__link">
    Softmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax" class="md-nav__link">
    Softmax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax2d" class="md-nav__link">
    Softmax2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsoftmax" class="md-nav__link">
    LogSoftmax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivelogsoftmaxwithloss" class="md-nav__link">
    AdaptiveLogSoftmaxWithLoss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#normalization-layers" class="md-nav__link">
    Normalization layers
  </a>
  
    <nav class="md-nav" aria-label="Normalization layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#batchnorm1d" class="md-nav__link">
    BatchNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm2d" class="md-nav__link">
    BatchNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm3d" class="md-nav__link">
    BatchNorm3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#groupnorm" class="md-nav__link">
    GroupNorm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm1d" class="md-nav__link">
    InstanceNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm2d" class="md-nav__link">
    InstanceNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm3d" class="md-nav__link">
    InstanceNorm3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#layernorm" class="md-nav__link">
    LayerNorm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#localresponsenorm" class="md-nav__link">
    LocalResponseNorm
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recurrent-layers" class="md-nav__link">
    Recurrent layers
  </a>
  
    <nav class="md-nav" aria-label="Recurrent layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rnn" class="md-nav__link">
    RNN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstm" class="md-nav__link">
    LSTM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gru" class="md-nav__link">
    GRU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rnncell" class="md-nav__link">
    RNNCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstmcell" class="md-nav__link">
    LSTMCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grucell" class="md-nav__link">
    GRUCell
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linear-layers" class="md-nav__link">
    Linear layers
  </a>
  
    <nav class="md-nav" aria-label="Linear layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linear" class="md-nav__link">
    Linear
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bilinear" class="md-nav__link">
    Bilinear
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dropout-layers" class="md-nav__link">
    Dropout layers
  </a>
  
    <nav class="md-nav" aria-label="Dropout layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dropout" class="md-nav__link">
    Dropout
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout2d" class="md-nav__link">
    Dropout2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout3d" class="md-nav__link">
    Dropout3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alphadropout" class="md-nav__link">
    AlphaDropout
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sparse-layers" class="md-nav__link">
    Sparse layers
  </a>
  
    <nav class="md-nav" aria-label="Sparse layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#embedding" class="md-nav__link">
    Embedding
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#embeddingbag" class="md-nav__link">
    EmbeddingBag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#distance-functions" class="md-nav__link">
    Distance functions
  </a>
  
    <nav class="md-nav" aria-label="Distance functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cosinesimilarity" class="md-nav__link">
    CosineSimilarity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pairwisedistance" class="md-nav__link">
    PairwiseDistance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#loss-functions" class="md-nav__link">
    Loss functions
  </a>
  
    <nav class="md-nav" aria-label="Loss functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l1loss" class="md-nav__link">
    L1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mseloss" class="md-nav__link">
    MSELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crossentropyloss" class="md-nav__link">
    CrossEntropyLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ctcloss" class="md-nav__link">
    CTCLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nllloss" class="md-nav__link">
    NLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poissonnllloss" class="md-nav__link">
    PoissonNLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kldivloss" class="md-nav__link">
    KLDivLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bceloss" class="md-nav__link">
    BCELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcewithlogitsloss" class="md-nav__link">
    BCEWithLogitsLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marginrankingloss" class="md-nav__link">
    MarginRankingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hingeembeddingloss" class="md-nav__link">
    HingeEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelmarginloss" class="md-nav__link">
    MultiLabelMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smoothl1loss" class="md-nav__link">
    SmoothL1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmarginloss" class="md-nav__link">
    SoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelsoftmarginloss" class="md-nav__link">
    MultiLabelSoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosineembeddingloss" class="md-nav__link">
    CosineEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multimarginloss" class="md-nav__link">
    MultiMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tripletmarginloss" class="md-nav__link">
    TripletMarginLoss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vision-layers" class="md-nav__link">
    Vision layers
  </a>
  
    <nav class="md-nav" aria-label="Vision layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pixelshuffle" class="md-nav__link">
    PixelShuffle
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsample" class="md-nav__link">
    Upsample
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingnearest2d" class="md-nav__link">
    UpsamplingNearest2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingbilinear2d" class="md-nav__link">
    UpsamplingBilinear2d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dataparallel-layers-multi-gpu-distributed" class="md-nav__link">
    DataParallel layers (multi-GPU, distributed)
  </a>
  
    <nav class="md-nav" aria-label="DataParallel layers (multi-GPU, distributed)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dataparallel" class="md-nav__link">
    DataParallel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distributeddataparallel" class="md-nav__link">
    DistributedDataParallel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distributeddataparallelcpu" class="md-nav__link">
    DistributedDataParallelCPU
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utilities" class="md-nav__link">
    Utilities
  </a>
  
    <nav class="md-nav" aria-label="Utilities">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#clip_grad_norm_" class="md-nav__link">
    clip_grad_norm_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clip_grad_value_" class="md-nav__link">
    clip_grad_value_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameters_to_vector" class="md-nav__link">
    parameters_to_vector
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector_to_parameters" class="md-nav__link">
    vector_to_parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weight_norm" class="md-nav__link">
    weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_weight_norm" class="md-nav__link">
    remove_weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spectral_norm" class="md-nav__link">
    spectral_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_spectral_norm" class="md-nav__link">
    remove_spectral_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#packedsequence" class="md-nav__link">
    PackedSequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pack_padded_sequence" class="md-nav__link">
    pack_padded_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad_packed_sequence" class="md-nav__link">
    pad_packed_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad_sequence" class="md-nav__link">
    pad_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pack_sequence" class="md-nav__link">
    pack_sequence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nn_functional/" class="md-nav__link">
        torch.nn.functional
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../nn_init/" class="md-nav__link">
        torch.nn.init
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../optim/" class="md-nav__link">
        torch.optim
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../autograd/" class="md-nav__link">
        Automatic differentiation package - torch.autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../distributed/" class="md-nav__link">
        Distributed communication package - torch.distributed
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../distributions/" class="md-nav__link">
        Probability distributions - torch.distributions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../jit/" class="md-nav__link">
        Torch Script
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../multiprocessing/" class="md-nav__link">
        多进程包 - torch.multiprocessing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../bottleneck/" class="md-nav__link">
        torch.utils.bottleneck
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../checkpoint/" class="md-nav__link">
        torch.utils.checkpoint
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../docs_cpp_extension/" class="md-nav__link">
        torch.utils.cpp_extension
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../data/" class="md-nav__link">
        torch.utils.data
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../dlpack/" class="md-nav__link">
        torch.utils.dlpack
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../hub/" class="md-nav__link">
        torch.hub
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../model_zoo/" class="md-nav__link">
        torch.utils.model_zoo
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../onnx/" class="md-nav__link">
        torch.onnx
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../distributed_deprecated/" class="md-nav__link">
        Distributed communication package (deprecated) - torch.distributed.deprecated
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_5_3_3" >
      
      
      
        <label class="md-nav__link" for="__nav_5_3_3" id="__nav_5_3_3_label" tabindex="0">
          torchvision 参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_5_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_5_3_3">
          <span class="md-nav__icon md-icon"></span>
          torchvision 参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../docs_torchvision_ref/" class="md-nav__link">
        目录
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torchvision_datasets/" class="md-nav__link">
        torchvision.datasets
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torchvision_models/" class="md-nav__link">
        torchvision.models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torchvision_transforms/" class="md-nav__link">
        torchvision.transforms
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../torchvision_utils/" class="md-nav__link">
        torchvision.utils
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6" >
      
      
      
        <label class="md-nav__link" for="__nav_6" id="__nav_6_label" tabindex="0">
          PyTorch 0.4 中文文档
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 0.4 中文文档
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_1" >
      
      
      
        <label class="md-nav__link" for="__nav_6_1" id="__nav_6_1_label" tabindex="0">
          笔记
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6_1">
          <span class="md-nav__icon md-icon"></span>
          笔记
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/1/" class="md-nav__link">
        自动求导机制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/2/" class="md-nav__link">
        广播语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/3/" class="md-nav__link">
        CUDA 语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/4/" class="md-nav__link">
        扩展 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/5/" class="md-nav__link">
        常见问题
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/6/" class="md-nav__link">
        多进程最佳实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/7/" class="md-nav__link">
        序列化语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/8/" class="md-nav__link">
        Windows 常见问题
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_2" >
      
      
      
        <label class="md-nav__link" for="__nav_6_2" id="__nav_6_2_label" tabindex="0">
          包参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6_2">
          <span class="md-nav__icon md-icon"></span>
          包参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/10/" class="md-nav__link">
        Torch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/11/" class="md-nav__link">
        torch.Tensor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/12/" class="md-nav__link">
        Tensor Attributes
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/13/" class="md-nav__link">
        torch.sparse
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/14/" class="md-nav__link">
        torch.cuda
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/15/" class="md-nav__link">
        torch.Storage
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/16/" class="md-nav__link">
        torch.nn
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/17/" class="md-nav__link">
        torch.nn.functional
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/18/" class="md-nav__link">
        自动差异化包 - torch.autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/19/" class="md-nav__link">
        torch.optim
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/20/" class="md-nav__link">
        torch.nn.init
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/21/" class="md-nav__link">
        torch.distributions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/22/" class="md-nav__link">
        Multiprocessing 包 - torch.multiprocessing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/23/" class="md-nav__link">
        分布式通讯包 - torch.distributed
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/24/" class="md-nav__link">
        torch.utils.bottleneck
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/25/" class="md-nav__link">
        torch.utils.checkpoint
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/26/" class="md-nav__link">
        torch.utils.cpp_extension
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/27/" class="md-nav__link">
        torch.utils.data
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/28/" class="md-nav__link">
        torch.utils.ffi
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/29/" class="md-nav__link">
        torch.utils.model_zoo
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/30/" class="md-nav__link">
        torch.onnx
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/31/" class="md-nav__link">
        遗留包 - torch.legacy
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_6_3" >
      
      
      
        <label class="md-nav__link" for="__nav_6_3" id="__nav_6_3_label" tabindex="0">
          torchvision 参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_6_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_6_3">
          <span class="md-nav__icon md-icon"></span>
          torchvision 参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/33/" class="md-nav__link">
        torchvision
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/34/" class="md-nav__link">
        torchvision.datasets
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/35/" class="md-nav__link">
        torchvision.models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/36/" class="md-nav__link">
        torchvision.transform
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.4/37/" class="md-nav__link">
        torchvision.utils
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7" >
      
      
      
        <label class="md-nav__link" for="__nav_7" id="__nav_7_label" tabindex="0">
          PyTorch 0.3 中文文档 & 教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_7_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 0.3 中文文档 & 教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/" class="md-nav__link">
        目录
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2" id="__nav_7_2_label" tabindex="0">
          中文教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2">
          <span class="md-nav__icon md-icon"></span>
          中文教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_1" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_1" id="__nav_7_2_1_label" tabindex="0">
          初学者教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_7_2_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_1">
          <span class="md-nav__icon md-icon"></span>
          初学者教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_1_1" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_1_1" id="__nav_7_2_1_1_label" tabindex="0">
          PyTorch 深度学习: 60 分钟极速入门教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_7_2_1_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_1_1">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 深度学习: 60 分钟极速入门教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/deep_learning_60min_blitz/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/blitz_tensor_tutorial/" class="md-nav__link">
        PyTorch 是什么？
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/blitz_autograd_tutorial/" class="md-nav__link">
        自动求导: 自动微分
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/blitz_neural_networks_tutorial/" class="md-nav__link">
        神经网络
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/blitz_cifar10_tutorial/" class="md-nav__link">
        训练一个分类器
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/blitz_data_parallel_tutorial/" class="md-nav__link">
        可选: 数据并行
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_1_2" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_1_2" id="__nav_7_2_1_2_label" tabindex="0">
          PyTorch for former Torch users
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_7_2_1_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_1_2">
          <span class="md-nav__icon md-icon"></span>
          PyTorch for former Torch users
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/former_torchies_tutorial/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/former_torchies_tensor_tutorial/" class="md-nav__link">
        Tensors
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/former_torchies_autograd_tutorial/" class="md-nav__link">
        Autograd (自动求导)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/former_torchies_nn_tutorial/" class="md-nav__link">
        nn package
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/former_torchies_parallelism_tutorial/" class="md-nav__link">
        Multi-GPU examples
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_1_3" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_1_3" id="__nav_7_2_1_3_label" tabindex="0">
          跟着例子学习 PyTorch
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_7_2_1_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_1_3">
          <span class="md-nav__icon md-icon"></span>
          跟着例子学习 PyTorch
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_warm-up-numpy/" class="md-nav__link">
        Warm-up: numpy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-tensors/" class="md-nav__link">
        PyTorch: Tensors
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-variables-and-autograd/" class="md-nav__link">
        PyTorch: 变量和autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-defining-new-autograd-functions/" class="md-nav__link">
        PyTorch: 定义新的autograd函数
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_tensorflow-static-graphs/" class="md-nav__link">
        TensorFlow: 静态图
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-nn/" class="md-nav__link">
        PyTorch: nn包
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-optim/" class="md-nav__link">
        PyTorch: optim包
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-custom-nn-modules/" class="md-nav__link">
        PyTorch: 定制化nn模块
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/pytorch_with_examples_pytorch-control-flow-weight-sharing/" class="md-nav__link">
        PyTorch: 动态控制流程 - 权重共享
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/transfer_learning_tutorial/" class="md-nav__link">
        迁移学习教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/data_loading_tutorial/" class="md-nav__link">
        数据加载和处理教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_1_6" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_1_6" id="__nav_7_2_1_6_label" tabindex="0">
          针对NLP的Pytorch深度学习
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="4" aria-labelledby="__nav_7_2_1_6_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_1_6">
          <span class="md-nav__icon md-icon"></span>
          针对NLP的Pytorch深度学习
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/deep_learning_nlp_tutorial/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/nlp_pytorch_tutorial/" class="md-nav__link">
        PyTorch介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/nlp_deep_learning_tutorial/" class="md-nav__link">
        PyTorch深度学习
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/nlp_word_embeddings_tutorial/" class="md-nav__link">
        词汇嵌入:编码词汇语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/nlp_sequence_models_tutorial/" class="md-nav__link">
        序列模型和 LSTM 网络(长短记忆网络）
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/nlp_advanced_tutorial/" class="md-nav__link">
        高级教程: 作出动态决策和 Bi-LSTM CRF
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_2" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_2" id="__nav_7_2_2_label" tabindex="0">
          中级教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_7_2_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_2">
          <span class="md-nav__icon md-icon"></span>
          中级教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/char_rnn_classification_tutorial/" class="md-nav__link">
        用字符级RNN分类名称
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/char_rnn_generation_tutorial/" class="md-nav__link">
        基与字符级RNN(Char-RNN）的人名生成
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/seq2seq_translation_tutorial/" class="md-nav__link">
        用基于注意力机制的seq2seq神经网络进行翻译
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/reinforcement_q_learning/" class="md-nav__link">
        强化学习(DQN）教程
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/dist_tuto/" class="md-nav__link">
        Writing Distributed Applications with PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/spatial_transformer_tutorial/" class="md-nav__link">
        空间转换网络 (Spatial Transformer Networks) 教程
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_2_3" >
      
      
      
        <label class="md-nav__link" for="__nav_7_2_3" id="__nav_7_2_3_label" tabindex="0">
          高级教程
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_7_2_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_2_3">
          <span class="md-nav__icon md-icon"></span>
          高级教程
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/neural_style_tutorial/" class="md-nav__link">
        用 PyTorch 做 神经转换 (Neural Transfer)
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/numpy_extensions_tutorial/" class="md-nav__link">
        使用 numpy 和 scipy 创建扩展
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/super_resolution_with_caffe2/" class="md-nav__link">
        使用 ONNX 将模型从 PyTorch 迁移到 Caffe2 和 Mobile
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/c_extension/" class="md-nav__link">
        为 pytorch 自定义 C 扩展
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_3" >
      
      
      
        <label class="md-nav__link" for="__nav_7_3" id="__nav_7_3_label" tabindex="0">
          中文文档
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_7_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_3">
          <span class="md-nav__icon md-icon"></span>
          中文文档
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_3_1" >
      
      
      
        <label class="md-nav__link" for="__nav_7_3_1" id="__nav_7_3_1_label" tabindex="0">
          介绍
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_7_3_1_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_3_1">
          <span class="md-nav__icon md-icon"></span>
          介绍
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/notes_autograd/" class="md-nav__link">
        自动求导机制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/notes_broadcasting/" class="md-nav__link">
        广播语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/notes_cuda/" class="md-nav__link">
        CUDA 语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/notes_extending/" class="md-nav__link">
        扩展 PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/notes_multiprocessing/" class="md-nav__link">
        多进程的最佳实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/notes_serialization/" class="md-nav__link">
        序列化语义
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_3_2" >
      
      
      
        <label class="md-nav__link" for="__nav_7_3_2" id="__nav_7_3_2_label" tabindex="0">
          Package 参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_7_3_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_3_2">
          <span class="md-nav__icon md-icon"></span>
          Package 参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/torch/" class="md-nav__link">
        torch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/tensors/" class="md-nav__link">
        torch.Tensor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/sparse/" class="md-nav__link">
        torch.sparse
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/storage/" class="md-nav__link">
        torch.Storage
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/nn/" class="md-nav__link">
        torch.nn
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/optim/" class="md-nav__link">
        torch.optim
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/autograd/" class="md-nav__link">
        Automatic differentiation package - torch.autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/distributions/" class="md-nav__link">
        Probability distributions - torch.distributions
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/multiprocessing/" class="md-nav__link">
        Multiprocessing package - torch.multiprocessing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/distributed/" class="md-nav__link">
        Distributed communication package - torch.distributed
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/legacy/" class="md-nav__link">
        Legacy package - torch.legacy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/cuda/" class="md-nav__link">
        torch.cuda
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/ffi/" class="md-nav__link">
        torch.utils.ffi
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/data/" class="md-nav__link">
        torch.utils.data
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/model_zoo/" class="md-nav__link">
        torch.utils.model_zoo
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/onnx/" class="md-nav__link">
        torch.onnx
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_7_3_3" >
      
      
      
        <label class="md-nav__link" for="__nav_7_3_3" id="__nav_7_3_3_label" tabindex="0">
          torchvision 参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="3" aria-labelledby="__nav_7_3_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_7_3_3">
          <span class="md-nav__icon md-icon"></span>
          torchvision 参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/torchvision/" class="md-nav__link">
        torchvision
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/datasets/" class="md-nav__link">
        torchvision.datasets
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/models/" class="md-nav__link">
        torchvision.models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/transforms/" class="md-nav__link">
        torchvision.transforms
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.3/utils/" class="md-nav__link">
        torchvision.utils
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8" >
      
      
      
        <label class="md-nav__link" for="__nav_8" id="__nav_8_label" tabindex="0">
          PyTorch 0.2 中文文档
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_8_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8">
          <span class="md-nav__icon md-icon"></span>
          PyTorch 0.2 中文文档
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/" class="md-nav__link">
        介绍
      </a>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_2" >
      
      
      
        <label class="md-nav__link" for="__nav_8_2" id="__nav_8_2_label" tabindex="0">
          说明
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_2_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8_2">
          <span class="md-nav__icon md-icon"></span>
          说明
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/notes/autograd/" class="md-nav__link">
        自动求导机制
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/notes/cuda/" class="md-nav__link">
        CUDA语义
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/notes/extending/" class="md-nav__link">
        扩展PyTorch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/notes/multiprocessing/" class="md-nav__link">
        多进程最佳实践
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/notes/serialization/" class="md-nav__link">
        序列化语义
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_3" >
      
      
      
        <label class="md-nav__link" for="__nav_8_3" id="__nav_8_3_label" tabindex="0">
          PACKAGE参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_3_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8_3">
          <span class="md-nav__icon md-icon"></span>
          PACKAGE参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/torch/" class="md-nav__link">
        torch
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/Tensor/" class="md-nav__link">
        torch.Tensor
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/Storage/" class="md-nav__link">
        torch.Storage
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/torch-nn/" class="md-nav__link">
        torch.nn
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/functional/" class="md-nav__link">
        torch.nn.functional
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/torch-autograd/" class="md-nav__link">
        torch.autograd
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/torch-optim/" class="md-nav__link">
        torch.optim
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/nn_init/" class="md-nav__link">
        torch.nn.init
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/torch-multiprocessing/" class="md-nav__link">
        torch.multiprocessing
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/legacy/" class="md-nav__link">
        torch.legacy
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/torch-cuda/" class="md-nav__link">
        torch.cuda
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/ffi/" class="md-nav__link">
        torch.utils.ffi
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/data/" class="md-nav__link">
        torch.utils.data
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/package_references/model_zoo/" class="md-nav__link">
        torch.utils.model_zoo
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    
    <li class="md-nav__item md-nav__item--nested">
      
      
      
      
      <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_8_4" >
      
      
      
        <label class="md-nav__link" for="__nav_8_4" id="__nav_8_4_label" tabindex="0">
          TORCHVISION参考
          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_8_4_label" aria-expanded="false">
        <label class="md-nav__title" for="__nav_8_4">
          <span class="md-nav__icon md-icon"></span>
          TORCHVISION参考
        </label>
        <ul class="md-nav__list" data-md-scrollfix>
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/torchvision/torchvision/" class="md-nav__link">
        torchvision
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/torchvision/torchvision-datasets/" class="md-nav__link">
        torchvision.datasets
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/torchvision/torchvision-models/" class="md-nav__link">
        torchvision.models
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/torchvision/torchvision-transform/" class="md-nav__link">
        torchvision.transforms
      </a>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/torchvision/torchvision-utils/" class="md-nav__link">
        torchvision.utils
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

            
          
            
              
  
  
  
    <li class="md-nav__item">
      <a href="../../0.2/acknowledgement/" class="md-nav__link">
        致谢
      </a>
    </li>
  

            
          
        </ul>
      </nav>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="../../contrib/" class="md-nav__link">
        贡献者
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://www.apachecn.org/about/" class="md-nav__link">
        关于我们
      </a>
    </li>
  

    
      
      
      

  
  
  
    <li class="md-nav__item">
      <a href="https://docs.apachecn.org" class="md-nav__link">
        中文资源合集
      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#parameters" class="md-nav__link">
    Parameters(参数）
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#containers" class="md-nav__link">
    Containers(容器）
  </a>
  
    <nav class="md-nav" aria-label="Containers(容器）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#module" class="md-nav__link">
    Module(模块）
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sequential" class="md-nav__link">
    Sequential
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modulelist" class="md-nav__link">
    ModuleList (模块列表)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#moduledict" class="md-nav__link">
    ModuleDict (模块词典)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameterlist" class="md-nav__link">
    ParameterList (参数列表)
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameterdict" class="md-nav__link">
    ParameterDict (参数词典)
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#convolution-layers" class="md-nav__link">
    Convolution layers (卷积层)
  </a>
  
    <nav class="md-nav" aria-label="Convolution layers (卷积层)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#conv1d" class="md-nav__link">
    Conv1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv2d" class="md-nav__link">
    Conv2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#conv3d" class="md-nav__link">
    Conv3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose1d" class="md-nav__link">
    ConvTranspose1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose2d" class="md-nav__link">
    ConvTranspose2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#convtranspose3d" class="md-nav__link">
    ConvTranspose3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unfold" class="md-nav__link">
    Unfold
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fold" class="md-nav__link">
    Fold
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#pooling-layers" class="md-nav__link">
    池化层(Pooling layers）
  </a>
  
    <nav class="md-nav" aria-label="池化层(Pooling layers）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#maxpool1d" class="md-nav__link">
    MaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool2d" class="md-nav__link">
    MaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxpool3d" class="md-nav__link">
    MaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool1d" class="md-nav__link">
    MaxUnpool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool2d" class="md-nav__link">
    MaxUnpool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#maxunpool3d" class="md-nav__link">
    MaxUnpool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool1d" class="md-nav__link">
    AvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool2d" class="md-nav__link">
    AvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#avgpool3d" class="md-nav__link">
    AvgPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#fractionalmaxpool2d" class="md-nav__link">
    FractionalMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lppool1d" class="md-nav__link">
    LPPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lppool2d" class="md-nav__link">
    LPPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool1d" class="md-nav__link">
    AdaptiveMaxPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool2d" class="md-nav__link">
    AdaptiveMaxPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivemaxpool3d" class="md-nav__link">
    AdaptiveMaxPool3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool1d" class="md-nav__link">
    AdaptiveAvgPool1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool2d" class="md-nav__link">
    AdaptiveAvgPool2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptiveavgpool3d" class="md-nav__link">
    AdaptiveAvgPool3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#padding-layers" class="md-nav__link">
    填充层(Padding layers）
  </a>
  
    <nav class="md-nav" aria-label="填充层(Padding layers）">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#reflectionpad1d" class="md-nav__link">
    ReflectionPad1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#reflectionpad2d" class="md-nav__link">
    ReflectionPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad1d" class="md-nav__link">
    ReplicationPad1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad2d" class="md-nav__link">
    ReplicationPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#replicationpad3d" class="md-nav__link">
    ReplicationPad3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#zeropad2d" class="md-nav__link">
    ZeroPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad1d" class="md-nav__link">
    ConstantPad1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad2d" class="md-nav__link">
    ConstantPad2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#constantpad3d" class="md-nav__link">
    ConstantPad3d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#non-linear-activations-weighted-sum-nonlinearity" class="md-nav__link">
    非线性激活(加权求和，非线性) ( Non-linear activations (weighted sum, nonlinearity))
  </a>
  
    <nav class="md-nav" aria-label="非线性激活(加权求和，非线性) ( Non-linear activations (weighted sum, nonlinearity))">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#elu" class="md-nav__link">
    ELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hardshrink" class="md-nav__link">
    Hardshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hardtanh" class="md-nav__link">
    Hardtanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#leakyrelu" class="md-nav__link">
    LeakyReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsigmoid" class="md-nav__link">
    LogSigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#prelu" class="md-nav__link">
    PReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relu" class="md-nav__link">
    ReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#relu6" class="md-nav__link">
    ReLU6
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rrelu" class="md-nav__link">
    RReLU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#selu" class="md-nav__link">
    SELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#celu" class="md-nav__link">
    CELU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sigmoid" class="md-nav__link">
    Sigmoid
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softplus" class="md-nav__link">
    Softplus
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softshrink" class="md-nav__link">
    Softshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softsign" class="md-nav__link">
    Softsign
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanh" class="md-nav__link">
    Tanh
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tanhshrink" class="md-nav__link">
    Tanhshrink
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#threshold" class="md-nav__link">
    Threshold
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#non-linear-activations-other" class="md-nav__link">
    Non-linear activations (other)
  </a>
  
    <nav class="md-nav" aria-label="Non-linear activations (other)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#softmin" class="md-nav__link">
    Softmin
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax" class="md-nav__link">
    Softmax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmax2d" class="md-nav__link">
    Softmax2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#logsoftmax" class="md-nav__link">
    LogSoftmax
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#adaptivelogsoftmaxwithloss" class="md-nav__link">
    AdaptiveLogSoftmaxWithLoss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#normalization-layers" class="md-nav__link">
    Normalization layers
  </a>
  
    <nav class="md-nav" aria-label="Normalization layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#batchnorm1d" class="md-nav__link">
    BatchNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm2d" class="md-nav__link">
    BatchNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#batchnorm3d" class="md-nav__link">
    BatchNorm3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#groupnorm" class="md-nav__link">
    GroupNorm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm1d" class="md-nav__link">
    InstanceNorm1d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm2d" class="md-nav__link">
    InstanceNorm2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#instancenorm3d" class="md-nav__link">
    InstanceNorm3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#layernorm" class="md-nav__link">
    LayerNorm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#localresponsenorm" class="md-nav__link">
    LocalResponseNorm
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#recurrent-layers" class="md-nav__link">
    Recurrent layers
  </a>
  
    <nav class="md-nav" aria-label="Recurrent layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#rnn" class="md-nav__link">
    RNN
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstm" class="md-nav__link">
    LSTM
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#gru" class="md-nav__link">
    GRU
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rnncell" class="md-nav__link">
    RNNCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#lstmcell" class="md-nav__link">
    LSTMCell
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#grucell" class="md-nav__link">
    GRUCell
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#linear-layers" class="md-nav__link">
    Linear layers
  </a>
  
    <nav class="md-nav" aria-label="Linear layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#linear" class="md-nav__link">
    Linear
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bilinear" class="md-nav__link">
    Bilinear
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dropout-layers" class="md-nav__link">
    Dropout layers
  </a>
  
    <nav class="md-nav" aria-label="Dropout layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dropout" class="md-nav__link">
    Dropout
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout2d" class="md-nav__link">
    Dropout2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#dropout3d" class="md-nav__link">
    Dropout3d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#alphadropout" class="md-nav__link">
    AlphaDropout
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#sparse-layers" class="md-nav__link">
    Sparse layers
  </a>
  
    <nav class="md-nav" aria-label="Sparse layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#embedding" class="md-nav__link">
    Embedding
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#embeddingbag" class="md-nav__link">
    EmbeddingBag
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#distance-functions" class="md-nav__link">
    Distance functions
  </a>
  
    <nav class="md-nav" aria-label="Distance functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#cosinesimilarity" class="md-nav__link">
    CosineSimilarity
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pairwisedistance" class="md-nav__link">
    PairwiseDistance
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#loss-functions" class="md-nav__link">
    Loss functions
  </a>
  
    <nav class="md-nav" aria-label="Loss functions">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#l1loss" class="md-nav__link">
    L1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#mseloss" class="md-nav__link">
    MSELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#crossentropyloss" class="md-nav__link">
    CrossEntropyLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#ctcloss" class="md-nav__link">
    CTCLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#nllloss" class="md-nav__link">
    NLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#poissonnllloss" class="md-nav__link">
    PoissonNLLLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#kldivloss" class="md-nav__link">
    KLDivLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bceloss" class="md-nav__link">
    BCELoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#bcewithlogitsloss" class="md-nav__link">
    BCEWithLogitsLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#marginrankingloss" class="md-nav__link">
    MarginRankingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#hingeembeddingloss" class="md-nav__link">
    HingeEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelmarginloss" class="md-nav__link">
    MultiLabelMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#smoothl1loss" class="md-nav__link">
    SmoothL1Loss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#softmarginloss" class="md-nav__link">
    SoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multilabelsoftmarginloss" class="md-nav__link">
    MultiLabelSoftMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#cosineembeddingloss" class="md-nav__link">
    CosineEmbeddingLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#multimarginloss" class="md-nav__link">
    MultiMarginLoss
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tripletmarginloss" class="md-nav__link">
    TripletMarginLoss
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#vision-layers" class="md-nav__link">
    Vision layers
  </a>
  
    <nav class="md-nav" aria-label="Vision layers">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#pixelshuffle" class="md-nav__link">
    PixelShuffle
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsample" class="md-nav__link">
    Upsample
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingnearest2d" class="md-nav__link">
    UpsamplingNearest2d
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#upsamplingbilinear2d" class="md-nav__link">
    UpsamplingBilinear2d
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#dataparallel-layers-multi-gpu-distributed" class="md-nav__link">
    DataParallel layers (multi-GPU, distributed)
  </a>
  
    <nav class="md-nav" aria-label="DataParallel layers (multi-GPU, distributed)">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#dataparallel" class="md-nav__link">
    DataParallel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distributeddataparallel" class="md-nav__link">
    DistributedDataParallel
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#distributeddataparallelcpu" class="md-nav__link">
    DistributedDataParallelCPU
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#utilities" class="md-nav__link">
    Utilities
  </a>
  
    <nav class="md-nav" aria-label="Utilities">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#clip_grad_norm_" class="md-nav__link">
    clip_grad_norm_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#clip_grad_value_" class="md-nav__link">
    clip_grad_value_
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#parameters_to_vector" class="md-nav__link">
    parameters_to_vector
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#vector_to_parameters" class="md-nav__link">
    vector_to_parameters
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#weight_norm" class="md-nav__link">
    weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_weight_norm" class="md-nav__link">
    remove_weight_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#spectral_norm" class="md-nav__link">
    spectral_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#remove_spectral_norm" class="md-nav__link">
    remove_spectral_norm
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#packedsequence" class="md-nav__link">
    PackedSequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pack_padded_sequence" class="md-nav__link">
    pack_padded_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad_packed_sequence" class="md-nav__link">
    pad_packed_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pad_sequence" class="md-nav__link">
    pad_sequence
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pack_sequence" class="md-nav__link">
    pack_sequence
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  

  
    <a href="https://github.com/apachecn/pytorch-doc-zh/edit/master/docs/1.0/nn.md" title="Edit this page" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M10 20H6V4h7v5h5v3.1l2-2V8l-6-6H6c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h4v-2m10.2-7c.1 0 .3.1.4.2l1.3 1.3c.2.2.2.6 0 .8l-1 1-2.1-2.1 1-1c.1-.1.2-.2.4-.2m0 3.9L14.1 23H12v-2.1l6.1-6.1 2.1 2.1Z"/></svg>
    </a>
  
  
    
      
    
    <a href="https://github.com/apachecn/pytorch-doc-zh/raw/master/docs/1.0/nn.md" title="View source of this page" class="md-content__button md-icon">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M17 18c.56 0 1 .44 1 1s-.44 1-1 1-1-.44-1-1 .44-1 1-1m0-3c-2.73 0-5.06 1.66-6 4 .94 2.34 3.27 4 6 4s5.06-1.66 6-4c-.94-2.34-3.27-4-6-4m0 6.5a2.5 2.5 0 0 1-2.5-2.5 2.5 2.5 0 0 1 2.5-2.5 2.5 2.5 0 0 1 2.5 2.5 2.5 2.5 0 0 1-2.5 2.5M9.27 20H6V4h7v5h5v4.07c.7.08 1.36.25 2 .49V8l-6-6H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h4.5a8.15 8.15 0 0 1-1.23-2Z"/></svg>
    </a>
  


<div class="wwads-cn wwads-horizontal" data-id="206" style="max-width:680px"></div>
<h1 id="torchnn">torch.nn</h1>
<h2 id="parameters">Parameters(参数）</h2>
<pre><code class="language-py">class torch.nn.Parameter
</code></pre>
<p>Parameters对象是一种会被视为模块参数(module parameter）的Tensor张量。</p>
<p>Parameters类是<a href="tensors.html#torch.Tensor" title="torch.Tensor"><code>Tensor</code></a> 的子类, 不过相对于它的父类，Parameters类有一个很重要的特性就是当其在 <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类中被使用并被当做这个<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类的模块属性的时候，那么这个Parameters对象会被自动地添加到这个<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类的参数列表(list of parameters)之中，同时也就会被添加入此<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>类的 <a href="#torch.nn.Module.parameters" title="torch.nn.Module.parameters"><code>parameters()</code></a>方法所返回的参数迭代器中。而Parameters类的父类Tensor类也可以被用为构建模块的属性，但不会被加入参数列表。这样主要是因为，有时可能需要在模型中存储一些非模型参数的临时状态，比如RNN中的最后一个隐状态。而通过使用非<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>的Tensor类，可以将这些临时变量注册(register)为模型的属性的同时使其不被加入参数列表。</p>
<p>Parameters: </p>
<ul>
<li><strong>data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 参数张量(parameter tensor).</li>
<li><strong>requires_grad</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 参数是否需要梯度， 默认为 <code>True</code>。更多细节请看 <a href="notes/autograd.html#excluding-subgraphs">如何将子图踢出反向传播过程</a>。 </li>
</ul>
<h2 id="containers">Containers(容器）</h2>
<h3 id="module">Module(模块）</h3>
<pre><code class="language-py">class torch.nn.Module
</code></pre>
<p>模块(Module）是所有神经网络模型的基类。</p>
<p>你创建模型的时候也应该继承这个类哦。</p>
<p>模块(Module)中还可以包含其他的模块，你可以将一个模块赋值成为另一个模块的属性，从而成为这个模块的一个子模块。而通过不断的赋值，你可以将不同的模块组织成一个树结构:</p>
<pre><code class="language-py">import torch.nn as nn
import torch.nn.functional as F

class Model(nn.Module):
    def __init__(self):
        super(Model, self).__init__()
        self.conv1 = nn.Conv2d(1, 20, 5) # 当前的nn.Conv2d模块就被赋值成为Model模块的一个子模块，成为“树结构”的叶子
        self.conv2 = nn.Conv2d(20, 20, 5)

    def forward(self, x):
       x = F.relu(self.conv1(x))
       return F.relu(self.conv2(x))

</code></pre>
<p>通过赋值这种方式添加的子模块将会被模型注册(register)，而后当调用模块的一些参数转换函数(<a href="#torch.nn.Module.to" title="torch.nn.Module.to"><code>to()</code></a>）的时候，子模块的参数也会一并转换。</p>
<pre><code class="language-py">add_module(name, module)
</code></pre>
<p>向当前模块添加一个子模块。
此子模块可以作为当前模块的属性被访问到，而属性名就是add_module()函数中的name参数。</p>
<p>add_module()函数参数: </p>
<ul>
<li><strong>name</strong> (<em>string</em>) – 子模块的名字. 函数调用完成后，可以通过访问当前模块的此字段来访问该子模块。</li>
<li><strong>parameter</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – 要添加到当前模块的子模块。</li>
</ul>
<pre><code class="language-py">apply(fn)
</code></pre>
<p>apply()函数的主要作用是将 <code>fn</code> 递归地应用于模块的所有子模块(<code>.children()</code>函数的返回值）以及模块自身。此函数的一个经典应用就是初始化模型的所有参数这一过程(同样参见于 torch-nn-init)。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>fn</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> -&gt; None) – 要应用于所有子模型的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; def init_weights(m):
 print(m)
 if type(m) == nn.Linear:
 m.weight.data.fill_(1.0)
 print(m.weight)

&gt;&gt;&gt; net = nn.Sequential(nn.Linear(2, 2), nn.Linear(2, 2))
&gt;&gt;&gt; net.apply(init_weights) # 将init_weights()函数应用于模块的所有子模块
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
 [ 1.,  1.]])
Linear(in_features=2, out_features=2, bias=True)
Parameter containing:
tensor([[ 1.,  1.],
 [ 1.,  1.]])
Sequential(
 (0): Linear(in_features=2, out_features=2, bias=True)
 (1): Linear(in_features=2, out_features=2, bias=True)
)
Sequential(
 (0): Linear(in_features=2, out_features=2, bias=True)
 (1): Linear(in_features=2, out_features=2, bias=True)
)

</code></pre>
<pre><code class="language-py">buffers(recurse=True)
</code></pre>
<p>返回模块的缓冲区的迭代器</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，产生的缓冲区迭代器会遍历模块自己与所有子模块，否则只会遍历模块的直连的成员。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Yields:</td>
<td><em>torch.Tensor</em> – 模型缓冲区</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>举例:</p>
<pre><code class="language-py">&gt;&gt;&gt; for buf in model.buffers():
&gt;&gt;&gt;     print(type(buf.data), buf.size())
&lt;class 'torch.FloatTensor'&gt; (20L,)
&lt;class 'torch.FloatTensor'&gt; (20L, 1L, 5L, 5L)

</code></pre>
<pre><code class="language-py">children()
</code></pre>
<p>返回一个当前所有子模块的迭代器
Returns an iterator over immediate children modules.</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Module</em> – 子模块</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">cpu()
</code></pre>
<p>将模型的所有参数(parameter)和缓冲区(buffer)都转移到CPU内存中。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">cuda(device=None)
</code></pre>
<p>将模型的所有参数和缓冲区都转移到CUDA设备内存中。</p>
<p>因为cuda()函数同时会将处理模块中的所有参数并缓存这些参数的对象。所以如果想让模块在GPU上进行优化操作，一定要在构建优化器之前调用模块的cuda()函数。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 如果设备编号被指定，所有的参数都会被拷贝到编号指定设备上</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">double()
</code></pre>
<p>将所有的浮点数类型的参数(parameters)和缓冲区(buffers)转换为<code>double</code>数据类型。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">dump_patches = False
</code></pre>
<p>这个字段可以为<a href="#torch.nn.Module.load_state_dict" title="torch.nn.Module.load_state_dict"><code>load_state_dict()</code></a>提供 BC 支持(BC support实在不懂是什么意思-.-）。 在 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict()</code></a>函数返回的状态字典(state dict）中， 有一个名为<code>_metadata</code>的属性中存储了这个state_dict的版本号。<code>_metadata</code>是一个遵从了状态字典(state dict）的命名规范的关键字字典， 要想了解这个<code>_metadata</code>在加载状态(loading state dict）的时候是怎么用的，可以看一下 <code>_load_from_state_dict</code>部分的文档。</p>
<p>如果新的参数/缓冲区被添加于/移除自这个模块之中时，这个版本号数字会随之发生变化。同时模块的<code>_load_from_state_dict</code>方法会比较版本号的信息并依据此状态词典(state dict）的变化做出一些适当的调整。</p>
<pre><code class="language-py">eval()
</code></pre>
<p>将模块转换为测试模式。</p>
<p>这个函数只对特定的模块类型有效，如 <a href="#torch.nn.Dropout" title="torch.nn.Dropout"><code>Dropout</code></a>和<code>BatchNorm</code>等等。如果想了解这些特定模块在训练/测试模式下各自的运作细节，可以看一下这些特殊模块的文档部分。</p>
<pre><code class="language-py">extra_repr()
</code></pre>
<p>为模块设置额外的展示信息(extra representation)。</p>
<p>如果想要打印展示(print)你的模块的一些定制的额外信息，那你应该在你的模块中复现这个函数。单行和多行的字符串都可以被接受。</p>
<pre><code class="language-py">float()
</code></pre>
<p>将所有浮点数类型的参数(parameters)和缓冲区(buffers)转换为<code>float</code>数据类型。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">forward(*input)
</code></pre>
<p>定义了每次模块被调用之后所进行的计算过程。</p>
<p>应该被Module类的所有子类重写。</p>
<p>Note</p>
<p>尽管模块的前向操作都被定义在这个函数里面，但是当你要进行模块的前向操作的时候，还是要直接调用模块<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> 的实例函数，而不是直接调用这个forward()函数。这主要是因为前者会照顾到注册在此模块之上的钩子函数(the registered hooks）的运行，而后者则不会。</p>
<pre><code class="language-py">half()
</code></pre>
<p>将所有的浮点数类型的参数(parameters)和缓冲区(buffers)转换为<code>half</code>数据类型。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">load_state_dict(state_dict, strict=True)
</code></pre>
<p>将<a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a>中的参数(parameters）和缓冲区(buffers）拷贝到模块和其子模块之中。如果<code>strict</code>被设置为<code>True</code>，那么<a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a>中的键值(keys）必须与模型的[<code>state_dict()</code>]函数所返回的键值(keys）信息保持完全的一致。</p>
<p>load_state_dict()函数参数： </p>
<ul>
<li><strong>state_dict</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)"><em>dict</em></a>) – 一个包含了参数和持久缓冲区的字典。</li>
<li><strong>strict</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 是否严格要求 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict</code></a> 中的键值(keys）与模型 <a href="#torch.nn.Module.state_dict" title="torch.nn.Module.state_dict"><code>state_dict()</code></a> 函数返回的键值(keys）信息保持完全一致。 默认： <code>True</code></li>
</ul>
<pre><code class="language-py">modules()
</code></pre>
<p>返回一个当前模块内所有模块(包括自身）的迭代器。</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>Module</em> – a module in the network</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>注意重复的模块只会被返回一次。比在下面这个例子中，<code>l</code>就只会被返回一次。</p>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.modules()):
 print(idx, '-&gt;', m)

0 -&gt; Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
)
1 -&gt; Linear (2 -&gt; 2)

</code></pre>
<pre><code class="language-py">named_buffers(prefix='', recurse=True)
</code></pre>
<p>返回一个模块缓冲区的迭代器，每次返回的元素是由缓冲区的名字和缓冲区自身组成的元组。</p>
<p>named_buffers()函数的参数: </p>
<ul>
<li><strong>prefix</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – 要添加在所有缓冲区名字之前的前缀。</li>
<li><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，那样迭代器中不光会返回这个模块自身直连成员的缓冲区，同时也会递归返回其子模块的缓冲区。否则，只返回这个模块直连成员的缓冲区。</li>
</ul>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, torch.Tensor)</em> – 包含了缓冲区的名字和缓冲区自身的元组</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; for name, buf in self.named_buffers():
&gt;&gt;&gt;    if name in ['running_var']:
&gt;&gt;&gt;        print(buf.size())

</code></pre>
<pre><code class="language-py">named_children()
</code></pre>
<p>返回一个当前模型直连的子模块的迭代器，每次返回的元素是由子模块的名字和子模块自身组成的元组。</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Module)</em> – 包含了子模块的名字和子模块自身的元组</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例子：</p>
<pre><code class="language-py">&gt;&gt;&gt; for name, module in model.named_children():
&gt;&gt;&gt;     if name in ['conv4', 'conv5']:
&gt;&gt;&gt;         print(module)

</code></pre>
<pre><code class="language-py">named_modules(memo=None, prefix='')
</code></pre>
<p>返回一个当前模块内所有模块(包括自身）的迭代器，每次返回的元素是由模块的名字和模块自身组成的元组。</p>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Module)</em> – 模块名字和模块自身组成的元组</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>重复的模块只会被返回一次。在下面的例子中，<code>l</code>只被返回了一次。</p>
<p>例子：</p>
<pre><code class="language-py">&gt;&gt;&gt; l = nn.Linear(2, 2)
&gt;&gt;&gt; net = nn.Sequential(l, l)
&gt;&gt;&gt; for idx, m in enumerate(net.named_modules()):
 print(idx, '-&gt;', m)

0 -&gt; ('', Sequential (
 (0): Linear (2 -&gt; 2)
 (1): Linear (2 -&gt; 2)
))
1 -&gt; ('0', Linear (2 -&gt; 2))

</code></pre>
<pre><code class="language-py">named_parameters(prefix='', recurse=True)
</code></pre>
<p>返回一个当前模块内所有参数的迭代器，每次返回的元素是由参数的名字和参数自身组成的元组。</p>
<p>named_parameters()函数参数：</p>
<ul>
<li><strong>prefix</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a>) – 要在所有参数名字前面添加的前缀。</li>
<li><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – 如果设置为True，那样迭代器中不光会返回这个模块自身直连成员的参数，同时也会返回其子模块的参数。否则，只返回这个模块直连成员的参数。</li>
</ul>
<table>
<thead>
<tr>
<th>Yields:</th>
<th><em>(string, Parameter)</em> – 参数名字和参数自身组成的元组</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; for name, param in self.named_parameters():
&gt;&gt;&gt;    if name in ['bias']:
&gt;&gt;&gt;        print(param.size())

</code></pre>
<pre><code class="language-py">parameters(recurse=True)
</code></pre>
<p>返回一个遍历模块所有参数的迭代器。
parameters()函数一个经典的应用就是实践中经常将此函数的返回值传入优化器。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>recurse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) –  如果设置为True，那样迭代器中不光会返回这个模块自身直连成员的参数，同时也会递归返回其子模块的参数。否则，只返回这个模块直连成员的参数。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Yields:</td>
<td><em>Parameter</em> – 模块参数</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; for param in model.parameters():
&gt;&gt;&gt;     print(type(param.data), param.size())
&lt;class 'torch.FloatTensor'&gt; (20L,)
&lt;class 'torch.FloatTensor'&gt; (20L, 1L, 5L, 5L)

</code></pre>
<pre><code class="language-py">register_backward_hook(hook)
</code></pre>
<p>在模块上注册一个挂载在反向操作之后的钩子函数。(挂载在backward之后这个点上的钩子函数）</p>
<p>对于每次输入，当模块关于此次输入的反向梯度的计算过程完成，该钩子函数都会被调用一次。此钩子函数需要遵从以下函数签名：</p>
<pre><code class="language-py">hook(module, grad_input, grad_output) -&gt; Tensor or None

</code></pre>
<p>如果模块的输入或输出是多重的(multiple inputs or outputs），那 <code>grad_input</code> 和 <code>grad_output</code> 应当是元组数据。 钩子函数不能对输入的参数<code>grad_input</code> 和 <code>grad_output</code>进行任何更改，但是可以选择性地根据输入的参数返回一个新的梯度回去，而这个新的梯度在后续的计算中会替换掉<code>grad_input</code>。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个句柄(handle），这个handle的特点就是通过调用<code>handle.remove()</code>函数就可以将这个添加于模块之上的钩子移除掉。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Warning</p>
<p>对于一些具有很多复杂操作的<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>，当前的hook实现版本还不能达到完全理想的效果。举个例子，有些错误的情况下，函数的输入参数<code>grad_input</code> 和 <code>grad_output</code>中可能只是真正的输入和输出变量的一个子集。对于此类的<a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a>，你应该使用[<code>torch.Tensor.register_hook()</code>]直接将钩子挂载到某个特定的输入输出的变量上，而不是当前的模块。</p>
<pre><code class="language-py">register_buffer(name, tensor)
</code></pre>
<p>往模块上添加一个持久缓冲区。</p>
<p>这个函数的经常会被用于向模块添加不会被认为是模块参数(model parameter）的缓冲区。举个栗子，BatchNorm的<code>running_mean</code>就不是一个参数，但却属于持久状态。</p>
<p>所添加的缓冲区可以通过给定的名字(name参数)以访问模块的属性的方式进行访问。</p>
<p>register_buffer()函数的参数: </p>
<ul>
<li><strong>name</strong> (<em>string</em>) – 要添加的缓冲区的名字。所添加的缓冲区可以通过此名字以访问模块的属性的方式进行访问。</li>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 需要注册到模块上的缓冲区。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; self.register_buffer('running_mean', torch.zeros(num_features))

</code></pre>
<pre><code class="language-py">register_forward_hook(hook)
</code></pre>
<p>在模块上注册一个挂载在前向操作之后的钩子函数。(挂载在forward操作结束之后这个点）</p>
<p>此钩子函数在每次模块的 <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a>函数运行结束产生output之后就会被触发。此钩子函数需要遵从以下函数签名：</p>
<pre><code class="language-py">hook(module, input, output) -&gt; None

</code></pre>
<p>此钩子函数不能进行会修改 input 和 output 这两个参数的操作。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个句柄(handle），这个handle的特点就是通过调用<code>handle.remove()</code>函数就可以将这个添加于模块之上的钩子移除掉。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">register_forward_pre_hook(hook)
</code></pre>
<p>在模块上注册一个挂载在前向操作之前的钩子函数。(挂载在forward操作开始之前这个点）</p>
<p>此钩子函数在每次模块的 <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a>函数运行开始之前会被触发。此钩子函数需要遵从以下函数签名：
The hook will be called every time before <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> is invoked. It should have the following signature:</p>
<pre><code class="language-py">hook(module, input) -&gt; None

</code></pre>
<p>此钩子函数不能进行会修改 input 这个参数的操作。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个句柄(handle），这个handle的特点就是通过调用<code>handle.remove()</code>函数就可以将这个添加于模块之上的钩子移除掉。</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><code>torch.utils.hooks.RemovableHandle</code></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">register_parameter(name, param)
</code></pre>
<p>向模块添加一个参数(parameter）。</p>
<p>所添加的参数(parameter）可以通过给定的名字(name参数)以访问模块的属性的方式进行访问。</p>
<p>register_parameter()函数的参数： </p>
<ul>
<li><strong>name</strong> (<em>string</em>) – 所添加的参数的名字. 所添加的参数(parameter）可以通过此名字以访问模块的属性的方式进行访问</li>
<li><strong>parameter</strong> (<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><em>Parameter</em></a>) – 要添加到模块之上的参数。</li>
</ul>
<pre><code class="language-py">state_dict(destination=None, prefix='', keep_vars=False)
</code></pre>
<p>返回一个包含了模块当前所有状态(state)的字典(dictionary)。</p>
<p>所有的参数和持久缓冲区都被囊括在其中。字典的键值就是响应的参数和缓冲区的名字(name)。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>一个包含了模块当前所有状态的字典</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.7)">dict</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; module.state_dict().keys()
['bias', 'weight']

</code></pre>
<pre><code class="language-py">to(*args, **kwargs)
</code></pre>
<p>移动 并且/或者(and/or）转换所有的参数和缓冲区。</p>
<p>这个函数可以这样调用：</p>
<pre><code class="language-py">to(device=None, dtype=None, non_blocking=False)
</code></pre>
<pre><code class="language-py">to(dtype, non_blocking=False)
</code></pre>
<pre><code class="language-py">to(tensor, non_blocking=False)
</code></pre>
<p>此函数的函数签名跟<a href="tensors.html#torch.Tensor.to" title="torch.Tensor.to"><code>torch.Tensor.to()</code></a>函数的函数签名很相似，只不过这个函数<code>dtype</code>参数只接受浮点数类型的dtype，如float， double， half (floating point desired <code>dtype</code> s）。同时，这个方法只会将浮点数类型的参数和缓冲区(the floating point parameters and buffers）转化为<code>dtype</code>(如果输入参数中给定的话）的数据类型。而对于整数类型的参数和缓冲区(the integral parameters and buffers），即便输入参数中给定了<code>dtype</code>，也不会进行转换操作，而如果给定了 <code>device</code>参数，移动操作则会正常进行。当<code>non_blocking</code>参数被设置为True之后，此函数会尽可能地相对于 host 进行异步的 转换/移动 操作，比如，将存储在固定内存(pinned memory）上的CPU Tensors移动到CUDA设备上这一过程既是如此。</p>
<p>例子在下面。</p>
<p>Note</p>
<p>这个方法对模块的修改都是in-place操作。</p>
<p>to()函数的参数: </p>
<ul>
<li><strong>device</strong> (<code>torch.device</code>) – 想要将这个模块中的参数和缓冲区转移到的设备。</li>
<li><strong>dtype</strong> (<code>torch.dtype</code>) – 想要将这个模块中浮点数的参数和缓冲区转化为的浮点数数据类型。</li>
<li><strong>tensor</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>torch.Tensor</em></a>) – 一个Tensor，如果被指定，其dtype和device信息，将分别起到上面两个参数的作用，也就是说，这个模块的浮点数的参数和缓冲区的数据类型将会被转化为这个Tensor的dtype类型，同时被转移到此Tensor所处的设备device上去。</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; linear = nn.Linear(2, 2)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1913, -0.3420],
 [-0.5113, -0.2325]])
&gt;&gt;&gt; linear.to(torch.double)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1913, -0.3420],
 [-0.5113, -0.2325]], dtype=torch.float64)
&gt;&gt;&gt; gpu1 = torch.device(&quot;cuda:1&quot;)
&gt;&gt;&gt; linear.to(gpu1, dtype=torch.half, non_blocking=True)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1914, -0.3420],
 [-0.5112, -0.2324]], dtype=torch.float16, device='cuda:1')
&gt;&gt;&gt; cpu = torch.device(&quot;cpu&quot;)
&gt;&gt;&gt; linear.to(cpu)
Linear(in_features=2, out_features=2, bias=True)
&gt;&gt;&gt; linear.weight
Parameter containing:
tensor([[ 0.1914, -0.3420],
 [-0.5112, -0.2324]], dtype=torch.float16)

</code></pre>
<pre><code class="language-py">train(mode=True)
</code></pre>
<p>将模块转换成训练模式。</p>
<p>这个函数只对特定的模块类型有效，如 <a href="#torch.nn.Dropout" title="torch.nn.Dropout"><code>Dropout</code></a>和<code>BatchNorm</code>等等。如果想了解这些特定模块在训练/测试模式下各自的运作细节，可以看一下这些特殊模块的文档部分。</p>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>self</th>
</tr>
</thead>
<tbody>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">type(dst_type)
</code></pre>
<p>将所有的参数和缓冲区转化为 <code>dst_type</code>的数据类型。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dst_type</strong> (<a href="https://docs.python.org/3/library/functions.html#type" title="(in Python v3.7)"><em>type</em></a> <em>or</em> <em>string</em>) – 要转化的数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>self</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td><a href="#torch.nn.Module" title="torch.nn.Module">Module</a></td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">zero_grad()
</code></pre>
<p>讲模块所有参数的梯度设置为0。</p>
<h3 id="sequential">Sequential</h3>
<pre><code class="language-py">class torch.nn.Sequential(*args)
</code></pre>
<p>一种顺序容器。传入Sequential构造器中的模块会被按照他们传入的顺序依次添加到Sequential之上。相应的，一个由模块组成的顺序词典也可以被传入到Sequential的构造器中。</p>
<p>为了方便大家理解，举个简单的例子：</p>
<pre><code class="language-py"># 构建Sequential的例子
model = nn.Sequential(
          nn.Conv2d(1,20,5),
          nn.ReLU(),
          nn.Conv2d(20,64,5),
          nn.ReLU()
        )

# 利用OrderedDict构建Sequential的例子
model = nn.Sequential(OrderedDict([
          ('conv1', nn.Conv2d(1,20,5)),
          ('relu1', nn.ReLU()),
          ('conv2', nn.Conv2d(20,64,5)),
          ('relu2', nn.ReLU())
        ]))

</code></pre>
<h3 id="modulelist">ModuleList (模块列表)</h3>
<pre><code class="language-py">class torch.nn.ModuleList(modules=None)
</code></pre>
<p>ModuleList的作用是将一堆模块(module）存储在一个列表之中。</p>
<p>ModuleList 可以按一般的python列表的索引方式进行索引，但ModuleList中的模块都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable__,</em> <em>optional</em>) – 一个要添加到ModuleList中的由模块组成的可迭代结构(an iterable of modules)</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.linears = nn.ModuleList([nn.Linear(10, 10) for i in range(10)])

    def forward(self, x):
        # ModuleList可以被当作一个迭代器，同时也可以使用index索引
        for i, l in enumerate(self.linears):
            x = self.linears[i // 2](x) + l(x)
        return x

</code></pre>
<pre><code class="language-py">append(module)
</code></pre>
<p>将一个模块添加到ModuleList的末尾，与python list的append()一致。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 要添加的模块</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">extend(modules)
</code></pre>
<p>将一个由模块组成的可迭代结构添加到ModuleList的末尾，与python list的extend()一致。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable</em>) – 要添加到ModuleList末尾的由模块组成的可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">insert(index, module)
</code></pre>
<p>将给定的<code>module</code>插入到ModuleList的<code>index</code>位置。</p>
<p>insert()函数的参数: </p>
<ul>
<li><strong>index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 要插入的位置</li>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – 要插入的模块</li>
</ul>
<h3 id="moduledict">ModuleDict (模块词典)</h3>
<pre><code class="language-py">class torch.nn.ModuleDict(modules=None)
</code></pre>
<p>ModuleDict的作用是将一堆模块(module）存储在一个词典之中。</p>
<p>ModuleDict 可以按一般的python词典的索引方式进行索引，但ModuleDict中的模块都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable__,</em> <em>optional</em>) – 一个由(string: module)映射组成的映射集合(词典）或者 一个由(string, module)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.choices = nn.ModuleDict({
                'conv': nn.Conv2d(10, 10, 3),
                'pool': nn.MaxPool2d(3)
        })
        self.activations = nn.ModuleDict([
                ['lrelu', nn.LeakyReLU()],
                ['prelu', nn.PReLU()]
        ])

    def forward(self, x, choice, act):
        x = self.choices[choice](x)
        x = self.activations[act](x)
        return x

</code></pre>
<pre><code class="language-py">clear()
</code></pre>
<p>移除ModuleDict中所有的元素。</p>
<pre><code class="language-py">items()
</code></pre>
<p>返回一个由ModuleDict中的键/值对组成的可迭代结构。</p>
<pre><code class="language-py">keys()
</code></pre>
<p>返回一个由ModuleDict中的键组成的可迭代结构。</p>
<pre><code class="language-py">pop(key)
</code></pre>
<p>将<code>key</code>这个键从ModuleDict中删除，并将其对应的模块返回。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>key</strong> (<em>string</em>) – 要从ModuleDict中弹出的键</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">update(modules)
</code></pre>
<p>通过传入的映射或者由键/值对组成的可迭代结构对当前的ModuleDict进行更新，如果传入对象与当前ModuleDict中存在键重复，当前ModuleDict中这些重复的键所对应的值将被覆盖。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>modules</strong> (<em>iterable</em>) – 一个由(string: <code>Module</code>)映射组成的映射集合(词典）或者 一个由(string: <code>Module</code>)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">values()
</code></pre>
<p>返回一个由ModuleDict中的值组成的可迭代结构。</p>
<h3 id="parameterlist">ParameterList (参数列表)</h3>
<pre><code class="language-py">class torch.nn.ParameterList(parameters=None)
</code></pre>
<p>ParameterList的作用是将一堆参数(parameter）存储到一个列表中。</p>
<p>ParameterList 可以按一般的python列表的索引方式进行索引，但ParameterList中的参数(parameter）都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable__,</em> <em>optional</em>) – 要添加到ParameterList之上的由parameter组成的可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.params = nn.ParameterList([nn.Parameter(torch.randn(10, 10)) for i in range(10)])

    def forward(self, x):
        # ParameterList可以被当作一个迭代器，同时也可以使用index索引
        for i, p in enumerate(self.params):
            x = self.params[i // 2].mm(x) + p.mm(x)
        return x

</code></pre>
<pre><code class="language-py">append(parameter)
</code></pre>
<p>将一个parameter添加到ParameterList的末尾。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameter</strong> (<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><em>nn.Parameter</em></a>) – 要添加的参数</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">extend(parameters)
</code></pre>
<p>将一个由parameter组成的Python可迭代结构添加到ParameterList的末尾。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable</em>) – 要添加到ParameterList的末尾的由parameter组成的Python可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="parameterdict">ParameterDict (参数词典)</h3>
<pre><code class="language-py">class torch.nn.ParameterDict(parameters=None)
</code></pre>
<p>ParameterDict的作用是将一堆参数(Parameter）存储在一个词典之中。</p>
<p>ParameterDict 可以按一般的python词典的索引方式进行索引，但ParameterDictt中的参数都已被正确注册，并且对所有的Module method可见。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable__,</em> <em>optional</em>) – 一个由(string:<a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)映射组成的映射集合(词典）或者 一个由(string, <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>例子:</p>
<pre><code class="language-py">class MyModule(nn.Module):
    def __init__(self):
        super(MyModule, self).__init__()
        self.params = nn.ParameterDict({
                'left': nn.Parameter(torch.randn(5, 10)),
                'right': nn.Parameter(torch.randn(5, 10))
        })

    def forward(self, x, choice):
        x = self.params[choice].mm(x)
        return x

</code></pre>
<pre><code class="language-py">clear()
</code></pre>
<p>移除ParameterDict中所有的元素。</p>
<pre><code class="language-py">items()
</code></pre>
<p>返回一个由ParameterDict中的键/值对组成的可迭代结构。</p>
<pre><code class="language-py">keys()
</code></pre>
<p>返回一个由 ParameterDict中的键组成的可迭代结构。</p>
<pre><code class="language-py">pop(key)
</code></pre>
<p>将key这个键从ParameterDict中删除，并将其对应的模块返回。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>key</strong> (<em>string</em>) – 要从ParameterDict中弹出的键</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">update(parameters)
</code></pre>
<p>通过传入的映射或者由键/值对组成的可迭代结构对当前的ParameterDict进行更新，如果传入对象与当前ParameterDict中存在键重复，当前ParameterDict中这些重复的键所对应的值将被覆盖。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>iterable</em>) – modules (iterable) – 一个由(string: <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)映射组成的映射集合(词典）或者 一个由(string: <a href="#torch.nn.Parameter" title="torch.nn.Parameter"><code>Parameter</code></a>)键/值对组成的可迭代结构</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">values()
</code></pre>
<p>返回一个由ParameterDict中的值组成的可迭代结构。</p>
<h2 id="convolution-layers">Convolution layers (卷积层)</h2>
<h3 id="conv1d">Conv1d</h3>
<pre><code class="language-py">class torch.nn.Conv1d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)
</code></pre>
<p>利用指定大小的一维卷积核对输入的多通道一维输入信号进行一维卷积操作的卷积层。</p>
<p>在最简单的情况下，对于输入大小为<img alt="" src="../img/1dad4f3ff614c986028f7100e0205f6d.jpg" />，输出大小为<img alt="" src="../img/a03de8b18f61a493174a56530fb03f1d.jpg" />的一维卷积层，其卷积计算过程可以如下表述：</p>
<p><img alt="" src="../img/806f7530da55bf294a636b8c7ed38bcb.jpg" /></p>
<p>这里的<img alt="" src="../img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" />符号实际上是一个互相关(<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>） 操作符(大家可以自己查一下互相关和真卷积的区别，互相关因为实现起来很简单，所以一般的深度学习框架都是用互相关操作取代真卷积）, <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is a batch size, <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> 代表通道的数量, <img alt="" src="../img/db4a9fef02111450bf98261889de550c.jpg" /> 代表信号序列的长度。</p>
<ul>
<li>
<p><code>stride</code> 参数控制了互相关操作(伪卷积）的步长，参数的数据类型一般是单个数字或者一个只有一个元素的元组。</p>
</li>
<li>
<p><code>padding</code> 参数控制了要在一维卷积核的输入信号的各维度各边上要补齐0的层数。</p>
</li>
<li>
<p><code>dilation</code> 参数控制了卷积核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
</li>
<li>
<p><code>groups</code> 控制了输入输出之间的连接(connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子， </p>
<p>&gt; *   当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p>
<p>&gt; *   当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p>
<p>&gt; *   当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<img alt="" src="../img/19131f9f53448ae579b613bc7bc90158.jpg" /></p>
</li>
</ul>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列(最后几列）可能不会参与计算(比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p>当<code>groups == in_channels</code> 并且 <code>out_channels == K * in_channels</code>(其中K是正整数）的时候，这个操作也被称为深度卷积。
举个创建深度卷积层的例子，对于一个大小为 <img alt="" src="../img/7db3e5e5d600c81e77756d5eee050505.jpg" /> 的输入，要构建一个深度乘数为<code>K</code>的深度卷积层，可以通过以下参数来创建：<img alt="" src="../img/eab8f2745761d762e48a59446243af90.jpg" />。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法(nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性(可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Conv1d的参数: </p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输出通道个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输入数据各维度各边上要补齐0的层数。 默认： 0</li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/7db3e5e5d600c81e77756d5eee050505.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/3423094375906aa21d1b2e095e95c230.jpg" /> 其中</p>
<p><img alt="" src="../img/91d48a39a90c6b4ed37ac863c1a8ff7b.jpg" /></p>
</li>
</ul>
<p>| 内部Variables： | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Conv1d模块中的一个大小为(out_channels, in_channels, kernel_size)的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />， 其中<img alt="" src="../img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" />。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为(out_channels)，可训练学习。如果构造Conv1d时构造函数中的<code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />， 其中 <img alt="" src="../img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" />。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Conv1d(16, 33, 3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 50)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="conv2d">Conv2d</h3>
<pre><code class="language-py">class torch.nn.Conv2d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)
</code></pre>
<p>利用指定大小的二维卷积核对输入的多通道二维输入信号进行二维卷积操作的卷积层。</p>
<p>在最简单的情况下，对于输入大小为<img alt="" src="../img/a6c3a4e9779c159b39576bee3400a00b.jpg" />，输出大小为<img alt="" src="../img/4b354af142fb0f01680d390ef552829f.jpg" />的二维维卷积层，其卷积计算过程可以如下表述：</p>
<p><img alt="" src="../img/a4928651cb959fa7871eaebdb489b083.jpg" /></p>
<p>这里的<img alt="" src="../img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" />符号实际上是一个二维互相关(<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>） 操作符(大家可以自己查一下互相关和真卷积的区别，互相关因为实现起来很简单，所以一般的深度学习框架都是用互相关操作取代真卷积）, <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is a batch size, <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> 代表通道的数量, <img alt="" src="../img/9b7d9beafd65e2cf6493bdca741827a5.jpg" /> 是输入的二维数据的像素高度，<img alt="" src="../img/90490a34512e9bd1843ed4da713d0813.jpg" /> 是输入的二维数据的像素宽度。</p>
<ul>
<li>
<p><code>stride</code> 参数控制了互相关操作(伪卷积）的步长，参数的数据类型一般是单个数字或者一个只有一个元素的元组。</p>
</li>
<li>
<p><code>padding</code> 参数控制了要在二维卷积核的输入信号的各维度各边上要补齐0的层数。</p>
</li>
<li>
<p><code>dilation</code> 参数控制了卷积核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
</li>
<li>
<p><code>groups</code> 控制了输入输出之间的连接(connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子， </p>
<p>&gt; *   当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p>
<p>&gt; *   当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p>
<p>&gt; *   当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<img alt="" src="../img/19131f9f53448ae579b613bc7bc90158.jpg" /></p>
</li>
</ul>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code>这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 二维数据的高和宽这两个维度都会采用这一个数字。</li>
<li>一个由两个int数字组成的<code>tuple</code>– 这种情况下，二维数据的高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列(最后几列）可能不会参与计算(比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note
当<code>groups == in_channels</code> 并且 <code>out_channels == K * in_channels</code>(其中K是正整数）的时候，这个操作也被称为深度卷积。</p>
<p>换句话说，对于一个大小为<img alt="" src="../img/0385ad868fed790d36381b9e8788c18b.jpg" />的输入，要构建一个深度乘数为<code>K</code>的深度卷积层，可以通过以下参数来创建：<img alt="" src="../img/8aee041e54a302b342d50912ce67f44b.jpg" />。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法(nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性(可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Conv2d的参数: </p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输出通道个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) –卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输入数据各维度各边上要补齐0的层数。 默认： 0</li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) –卷积核各元素之间的距离。 默认： 1</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/0385ad868fed790d36381b9e8788c18b.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/d3edfe8a9bbdd73ba5c4b566353777f0.jpg" /> 其中</p>
<p><img alt="" src="../img/a89a5326ab89279b92f4720f63b4eaae.jpg" /></p>
<p><img alt="" src="../img/03f69d6e3dffc3254359e41f8b310667.jpg" /></p>
</li>
</ul>
<p>| 内部Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Conv2d模块中的一个大小为 (out_channels, in_channels, kernel_size[0], kernel_size[1])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是 <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />， 其中<img alt="" src="../img/c12e2153347b696ebb784e5675cc566e.jpg" />。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 块的偏差项，大小为(out_channels)，可训练学习。如果构造Conv2d时构造函数中的<code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />，其中<img alt="" src="../img/c12e2153347b696ebb784e5675cc566e.jpg" />。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.Conv2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding and dilation
&gt;&gt;&gt; m = nn.Conv2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2), dilation=(3, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="conv3d">Conv3d</h3>
<pre><code class="language-py">class torch.nn.Conv3d(in_channels, out_channels, kernel_size, stride=1, padding=0, dilation=1, groups=1, bias=True)
</code></pre>
<p>利用指定大小的三维卷积核对输入的多通道三维输入信号进行三维卷积操作的卷积层。</p>
<p>最简单的情况下，对于输入大小为<img alt="" src="../img/ca863d6b44a0246998de77c7c423ec32.jpg" />，输出大小为<img alt="" src="../img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" /> 的三维卷积层，其卷积计算过程可以如下表述：</p>
<p><img alt="" src="../img/39831867c152a21de6e580bf01c0cb7f.jpg" /></p>
<p>这里的 <img alt="" src="../img/d5d3d32b4a35f91edb54c3c3f87d582e.jpg" />符号实际上是一个三维互相关 <a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a> 操作符。</p>
<ul>
<li>
<p><code>stride</code> 数控制了互相关操作(伪卷积）的步长。</p>
</li>
<li>
<p><code>padding</code> 参数控制了要在三维卷积核的输入信号的各维度各边上要补齐0的层数。</p>
</li>
<li>
<p><code>dilation</code> 参数控制了卷积核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
</li>
<li>
<p><code>groups</code> 控制了输入输出之间的连接(connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p>
</li>
</ul>
<p>&gt; *   当 groups=1, 此Conv3d层会使用一个卷积层进行对所有输入到输出的卷积操作。</p>
<p>&gt; *   当 groups=2, 此时Conv3d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv3d层的输出。</p>
<p>&gt; *   当 groups= in_channels, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是 <img alt="" src="../img/648a514da1dace3deacf3f078287e157.jpg" />.</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code>这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 三维维数据的深度，高和宽这三个维度都会采用这一个数字。</li>
<li>一个由三个int数字组成的<code>tuple</code>– 这种情况下，三维数据的深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列(最后几列）可能不会参与计算(比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p>当<code>groups == in_channels</code> 并且 <code>out_channels == K * in_channels</code>(其中K是正整数）的时候，这个操作也被称为深度卷积。</p>
<p>换句话说，对于一个大小为  <img alt="" src="../img/a8d71105bc4954eb54660bc5d37c23de.jpg" /> 的输入，要构建一个深度乘数为<code>K</code>的深度卷积层，可以通过以下参数来创建：<img alt="" src="../img/8aee041e54a302b342d50912ce67f44b.jpg" />。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法(nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性(可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters: </p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输入数据各维度各边上要补齐0的层数。 默认： 0</li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/a8d71105bc4954eb54660bc5d37c23de.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" /> where</p>
<p><img alt="" src="../img/bbc2662490bb72269672fe81af1fe003.jpg" /></p>
<p><img alt="" src="../img/b7ca056f55603d0632bb03bdf9435d47.jpg" /></p>
<p><img alt="" src="../img/d040a26cd9a91c4d230afd4c15d0e1e6.jpg" /></p>
</li>
</ul>
<p>| 内部Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Conv3d模块中的一个大小为 (out_channels, in_channels, kernel_size[0], kernel_size[1], kernel_size[2]) 的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />，其中<img alt="" src="../img/378f5c5b47c36239b817ad23a612a9f7.jpg" />。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为(out_channels)，可训练学习。如果构造Conv1d时构造函数中的<code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> ，其中 <img alt="" src="../img/378f5c5b47c36239b817ad23a612a9f7.jpg" />。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.Conv3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.Conv3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(4, 2, 0))
&gt;&gt;&gt; input = torch.randn(20, 16, 10, 50, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="convtranspose1d">ConvTranspose1d</h3>
<pre><code class="language-py">class torch.nn.ConvTranspose1d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)
</code></pre>
<p>利用指定大小的一维转置卷积核对输入的多通道一维输入信号进行转置卷积(当然此卷积也是互相关操作，cross-correlation）操作的模块。</p>
<p>该模块可以看作是Conv1d相对于其输入的梯度(the gradient of Conv1d with respect to its input， 直译)， 转置卷积又被称为小数步长卷积或是反卷积(尽管这不是一个真正意义上的反卷积）。</p>
<ul>
<li>
<p><code>stride</code> 控制了转置卷积操作的步长</p>
</li>
<li>
<p><code>padding</code> 控制了要在输入的各维度的各边上补齐0的层数，与Conv1d不同的地方，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>，详情请见下面的note。</p>
</li>
<li>
<p><code>output_padding</code> 控制了转置卷积操作输出的各维度的长度增量，但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出大小为根据此参数pad后的大小。更多的详情请见下面的note。</p>
</li>
<li>
<p><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了dilation的作用。</p>
</li>
<li>
<p><code>groups</code> 控制了输入输出之间的连接(connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p>
<p>&gt; *   当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p>
<p>&gt; *   当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p>
<p>&gt; *   当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<img alt="" src="../img/648a514da1dace3deacf3f078287e157.jpg" />。</p>
</li>
</ul>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列(最后几列）可能不会参与计算(比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p><code>padding</code> 参数控制了要在输入的各维度各边上补齐0的层数，与在Conv1d中不同的是，在转置卷积操作过程中，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>， 这样设置的主要原因是当使用相同的参数构建<a href="#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> 和<a href="#torch.nn.ConvTranspose1d" title="torch.nn.ConvTranspose1d"><code>ConvTranspose1d</code></a>模块的时候，这种设置能够实现两个模块有正好相反的输入输出的大小，即Conv1d的输出大小是其对应的ConvTranspose1d模块的输入大小，而ConvTranspose1d的输出大小又恰好是其对应的Conv1d模块的输入大小。然而，当<code>stride &gt; 1</code>的时候，<a href="#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> 的一个输出大小可能会对应多个输入大小，上一个note中就详细的介绍了这种情况，这样的情况下要保持前面提到两种模块的输入输出保持反向一致，那就要用到 <code>output_padding</code>参数了，这个参数可以增加转置卷积输出的某一维度的大小，以此来达到前面提到的同参数构建的<a href="#torch.nn.Conv1d" title="torch.nn.Conv1d"><code>Conv1d</code></a> 和<a href="#torch.nn.ConvTranspose1d" title="torch.nn.ConvTranspose1d"><code>ConvTranspose1d</code></a>模块的输入输出方向一致。 但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出各维度的大小为根据此参数pad后的大小。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法(nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性(可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters: </p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – <code>kernel_size - 1 - padding</code> 层 0 会被补齐到输入数据的各边上。 默认： 0</li>
<li><strong>output_padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出的各维度要增加的大小。默认：0 </li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/7db3e5e5d600c81e77756d5eee050505.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/3423094375906aa21d1b2e095e95c230.jpg" /> 其中，</p>
<p><img alt="" src="../img/c37a7e44707d3c08522f44ab4e4d6841.jpg" /></p>
</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) –  模块中的一个大小为 (in_channels, out_channels, kernel_size[0])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />，其中 <img alt="" src="../img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" />。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为 (out_channels)， 如果构造函数中的 <code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> ，其中 <img alt="" src="../img/69aab1ce658aabc9a2d986ae8281e2ad.jpg" />。</li>
</ul>
<h3 id="convtranspose2d">ConvTranspose2d</h3>
<pre><code class="language-py">class torch.nn.ConvTranspose2d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)
</code></pre>
<p>利用指定大小的二维转置卷积核对输入的多通道二维输入信号进行转置卷积(当然此卷积也是互相关操作，cross-correlation）操作的模块。</p>
<p>该模块可以看作是Conv2d相对于其输入的梯度(the gradient of Conv2d with respect to its input， 直译)， 转置卷积又被称为小数步长卷积或是反卷积(尽管这不是一个真正意义上的反卷积）。</p>
<ul>
<li>
<p><code>stride</code> 控制了转置卷积操作的步长 </p>
</li>
<li>
<p><code>padding</code> 控制了要在输入的各维度的各边上补齐0的层数，与Conv1d不同的地方，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>，详情请见下面的note。</p>
</li>
<li>
<p><code>output_padding</code> 控制了转置卷积操作输出的各维度的长度增量，但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出大小为根据此参数pad后的大小。更多的详情请见下面的note。</p>
</li>
<li>
<p><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了dilation的作用。</p>
</li>
<li>
<p><code>groups</code> 控制了输入输出之间的连接(connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p>
<p>&gt; *   当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p>
<p>&gt; *   当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p>
<p>&gt; *   当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<img alt="" src="../img/648a514da1dace3deacf3f078287e157.jpg" />。</p>
</li>
</ul>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>output_padding</code> 这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 二维维数据的高和宽这两个维度都会采用这一个数字。</li>
<li>一个由两个int数字组成的<code>tuple</code>– 这种情况下，二维数据的高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列(最后几列）可能不会参与计算(比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p><code>padding</code> 参数控制了要在输入的各维度各边上补齐0的层数，与在Conv1d中不同的是，在转置卷积操作过程中，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>， 这样设置的主要原因是当使用相同的参数构建<a href="#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> 和<a href="#torch.nn.ConvTranspose2d" title="torch.nn.ConvTranspose2d"><code>ConvTranspose2d</code></a>模块的时候，这种设置能够实现两个模块有正好相反的输入输出的大小，即Conv2d的输出大小是其对应的ConvTranspose2d模块的输入大小，而ConvTranspose2d的输出大小又恰好是其对应的Conv2d模块的输入大小。然而，当<code>stride &gt; 1</code>的时候，<a href="#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> 的一个输出大小可能会对应多个输入大小，上一个note中就详细的介绍了这种情况，这样的情况下要保持前面提到两种模块的输入输出保持反向一致，那就要用到 <code>output_padding</code>参数了，这个参数可以增加转置卷积输出的某一维度的大小，以此来达到前面提到的同参数构建的<a href="#torch.nn.Conv2d" title="torch.nn.Conv2d"><code>Conv2d</code></a> 和<a href="#torch.nn.ConvTranspose2d" title="torch.nn.ConvTranspose2d"><code>ConvTranspose2d</code></a>模块的输入输出方向一致。 但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出各维度的大小为根据此参数pad后的大小。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法(nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性(可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – <code>kernel_size - 1 - padding</code> 层 0 会被补齐到输入数据的各边上。 默认： 0</li>
<li><strong>output_padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出的各维度要增加的大小。默认：0 </li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/0385ad868fed790d36381b9e8788c18b.jpg" /></li>
<li>输出: <img alt="" src="../img/d3edfe8a9bbdd73ba5c4b566353777f0.jpg" /> 其中</li>
</ul>
<p><img alt="" src="../img/a2616e3fb8e8e919b799c2e62921c374.jpg" /></p>
<p><img alt="" src="../img/dee6540c49e827b0ececaf0154154b54.jpg" /></p>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) –  模块中的一个大小为 (in_channels, out_channels, kernel_size[0], kernel_size[1])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />，其中 <img alt="" src="../img/c12e2153347b696ebb784e5675cc566e.jpg" />。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为 (out_channels)， 如果构造函数中的 <code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> ，其中 <img alt="" src="../img/c12e2153347b696ebb784e5675cc566e.jpg" />。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.ConvTranspose2d(16, 33, (3, 5), stride=(2, 1), padding=(4, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 100)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # exact output size can be also specified as an argument
&gt;&gt;&gt; input = torch.randn(1, 16, 12, 12)
&gt;&gt;&gt; downsample = nn.Conv2d(16, 16, 3, stride=2, padding=1)
&gt;&gt;&gt; upsample = nn.ConvTranspose2d(16, 16, 3, stride=2, padding=1)
&gt;&gt;&gt; h = downsample(input)
&gt;&gt;&gt; h.size()
torch.Size([1, 16, 6, 6])
&gt;&gt;&gt; output = upsample(h, output_size=input.size())
&gt;&gt;&gt; output.size()
torch.Size([1, 16, 12, 12])

</code></pre>
<h3 id="convtranspose3d">ConvTranspose3d</h3>
<pre><code class="language-py">class torch.nn.ConvTranspose3d(in_channels, out_channels, kernel_size, stride=1, padding=0, output_padding=0, groups=1, bias=True, dilation=1)
</code></pre>
<p>利用指定大小的三维转置卷积核对输入的多通道三维输入信号进行转置卷积(当然此卷积也是互相关操作，cross-correlation）操作的模块。转置卷积的操作本质是将各通道输入与卷积核做乘法，然后返回各通道与此卷积核乘积结果之和(卷积的定义）。</p>
<p>该模块可以看作是Conv3d相对于其输入的梯度(the gradient of Conv3d with respect to its input， 直译)， 转置卷积又被称为小数步长卷积或是反卷积(尽管这不是一个真正意义上的反卷积）。</p>
<ul>
<li>
<p><code>stride</code> 控制了转置卷积操作的步长 </p>
</li>
<li>
<p><code>padding</code> 控制了要在输入的各维度的各边上补齐0的层数，与Conv1d不同的地方，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>，详情请见下面的note。</p>
</li>
<li>
<p><code>output_padding</code> 控制了转置卷积操作输出的各维度的长度增量，但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出大小为根据此参数pad后的大小。更多的详情请见下面的note。</p>
</li>
<li>
<p><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了dilation的作用。</p>
</li>
<li>
<p><code>groups</code> 控制了输入输出之间的连接(connections）的数量。<code>in_channels</code> 和 <code>out_channels</code> 必须能被 <code>groups</code> 整除。举个栗子，</p>
<p>&gt; *   当 groups=1, 此Conv1d层会使用一个卷积层进行所有输入到输出的卷积操作。</p>
<p>&gt; *   当 groups=2, 此时Conv1d层会产生两个并列的卷积层。同时，输入通道被分为两半，两个卷积层分别处理一半的输入通道，同时各自产生一半的输出通道。最后这两个卷积层的输出会被concatenated一起，作为此Conv1d层的输出。</p>
<p>&gt; *   当 groups= <code>in_channels</code>, 每个输入通道都会被单独的一组卷积层处理，这个组的大小是<img alt="" src="../img/648a514da1dace3deacf3f078287e157.jpg" />。</p>
</li>
</ul>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>output_padding</code> 这几个参数均支持一下输入形式：</p>
<blockquote>
<ul>
<li>一个 <code>int</code> 数字 – 三维维数据的深度，高和宽这两个维度都会采用这一个数字。</li>
<li>一个由三个int数字组成的<code>tuple</code>– 这种情况下，三维数据的深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Note</p>
<p>取决于你卷积核的大小，有些时候输入数据中某些列(最后几列）可能不会参与计算(比如列数整除卷积核大小有余数，而又没有padding，那最后的余数列一般不会参与卷积计算），这主要是因为pytorch中的互相关操作<a href="https://en.wikipedia.org/wiki/Cross-correlation">cross-correlation</a>是保证计算正确的操作(valid operation)， 而不是满操作(full operation)。所以实际操作中，还是要亲尽量选择好合适的padding参数哦。</p>
<p>Note</p>
<p><code>padding</code> 参数控制了要在输入的各维度各边上补齐0的层数，与在Conv3d中不同的是，在转置卷积操作过程中，此padding参数与实际补齐0的层数的关系为<code>层数 = kernel_size - 1 - padding</code>， 这样设置的主要原因是当使用相同的参数构建<a href="#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> 和<a href="#torch.nn.ConvTranspose3d" title="torch.nn.ConvTranspose3d"><code>ConvTranspose3d</code></a>模块的时候，这种设置能够实现两个模块有正好相反的输入输出的大小，即Conv3d的输出大小是其对应的ConvTranspose3d模块的输入大小，而ConvTranspose3d的输出大小又恰好是其对应的Conv3d模块的输入大小。然而，当<code>stride &gt; 1</code>的时候，<a href="#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> 的一个输出大小可能会对应多个输入大小，上一个note中就详细的介绍了这种情况，这样的情况下要保持前面提到两种模块的输入输出保持反向一致，那就要用到 <code>output_padding</code>参数了，这个参数可以增加转置卷积输出的某一维度的大小，以此来达到前面提到的同参数构建的<a href="#torch.nn.Conv3d" title="torch.nn.Conv3d"><code>Conv3d</code></a> 和<a href="#torch.nn.ConvTranspose3d" title="torch.nn.ConvTranspose3d"><code>ConvTranspose3d</code></a>模块的输入输出方向一致。 但注意这个参数不是说要往转置卷积的输出上pad 0，而是直接控制转置卷积的输出各维度的大小为根据此参数pad后的大小。</p>
<p>Note</p>
<p>当程序的运行环境是使用了CuDNN的CUDA环境的时候，一些非确定性的算法(nondeterministic algorithm）可能会被采用以提高整个计算的性能。如果不想使用这些非确定性的算法，你可以通过设置<code>torch.backends.cudnn.deterministic = True</code>来让整个计算过程保持确定性(可能会损失一定的计算性能）。对于后端(background)，你可以看一下这一部分<a href="notes/randomness.html">Reproducibility</a>了解其相关信息。</p>
<p>Parameters:</p>
<ul>
<li><strong>in_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 输入通道的个数</li>
<li><strong>out_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 卷积操作输出通道的个数</li>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 卷积核大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积操作的步长。 默认： 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – <code>kernel_size - 1 - padding</code> 层 0 会被补齐到输入数据的各边上。 默认： 0</li>
<li><strong>output_padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 输出的各维度要增加的大小。默认：0 </li>
<li><strong>groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – 输入通道与输出通道之间相互隔离的连接的个数。 默认：1</li>
<li><strong>bias</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 如果被置为 <code>True</code>，向输出增加一个偏差量，此偏差是可学习参数。 默认：<code>True</code></li>
<li><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 卷积核各元素之间的距离。 默认： 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/a8d71105bc4954eb54660bc5d37c23de.jpg" /></li>
<li>输出: <img alt="" src="../img/f05e8faaf90b4c16b23ca0165e8e09f4.jpg" /> 其中</li>
</ul>
<p><img alt="" src="../img/35234de680c85870881b7f5d9e8de589.jpg" /></p>
<p><img alt="" src="../img/044bc4ee93fc4a1725b5b5dc5840b408.jpg" /></p>
<p><img alt="" src="../img/133b249f21b73617ee100c4c072eee15.jpg" /></p>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) –  模块中的一个大小为 (in_channels, out_channels, kernel_size[0], kernel_size[1], kernel_size[2])的权重张量，这些权重可训练学习(learnable)。这些权重的初始值的采样空间是<img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />，其中 <img alt="" src="../img/378f5c5b47c36239b817ad23a612a9f7.jpg" />。</li>
<li><strong>bias</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 模块的偏差项，大小为 (out_channels)， 如果构造函数中的 <code>bias</code> 被置为 <code>True</code>，那么这些权重的初始值的采样空间是 <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />，其中 <img alt="" src="../img/378f5c5b47c36239b817ad23a612a9f7.jpg" />。</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With square kernels and equal stride
&gt;&gt;&gt; m = nn.ConvTranspose3d(16, 33, 3, stride=2)
&gt;&gt;&gt; # non-square kernels and unequal stride and with padding
&gt;&gt;&gt; m = nn.ConvTranspose3d(16, 33, (3, 5, 2), stride=(2, 1, 1), padding=(0, 4, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 10, 50, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="unfold">Unfold</h3>
<pre><code class="language-py">class torch.nn.Unfold(kernel_size, dilation=1, padding=0, stride=1)
</code></pre>
<p>将一个batch的输入张量展开成由多个滑动局部块组成的形式。(im2col的扩展模块，起到基本类似im2col的作用）</p>
<p>以一个大小为<img alt="" src="../img/2468b226c29a7e754a9c20f0214fa85f.jpg" />的批次化(batched)输入张量为例，其中<img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" />是batch的大小，<img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" />是通道数量，<img alt="" src="../img/28ec51e742166ea3400be6e7343bbfa5.jpg" />代表了任意空间维度。那Unfold这个操作在此张量上的操作就是，将这个张量展开成由多个<code>kernel_size</code>大小的滑动块组成的大小为<img alt="" src="../img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" />的三维张量，其中<img alt="" src="../img/a8846766f2e1b47021f1520993773ccb.jpg" />是每个块中数的个数(每个块有<img alt="" src="../img/8c7a54ca7193bc3a6c5ace8c3b07d24c.jpg" />个空间位置，每个空间位置存储一个通道大小为<img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" />的向量），<img alt="" src="../img/db4a9fef02111450bf98261889de550c.jpg" />是块的个数：</p>
<p><img alt="" src="../img/1d2c6a9103e2b33f725602aebf90364e.jpg" />
(这张图有问题啊，编辑整理的时候注意修正一下）</p>
<p>其中 <img alt="" src="../img/42a2dca8a9cb6104321cf29ae30fd56a.jpg" /> 是由上面例子中的<code>input</code>各空间维度组成的，<img alt="" src="../img/9566974d45a96737f7e0ecf302d877b8.jpg" />遍历了各个空间维度。</p>
<p>因此，索引Fold操作的<code>output</code>的最后一个维度等价于索引某一个block，而索引操作的返回值是这个索引到的block中的所有值。</p>
<p><code>padding</code>, <code>stride</code> 和 <code>dilation</code> 参数指明了滑动块的相关性质。</p>
<ul>
<li><code>stride</code> 控制了滑动块的步长。</li>
<li><code>padding</code> 控制了在变换之前要向input的各维度各边上补齐的0的层数。 </li>
<li><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了dilation的作用。</li>
</ul>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 滑动块的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 滑动块在输入各维度上的步长。默认: 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 在输入各维度各边上补齐0的层数。</li>
<li>
<p><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 控制了各元素之间的距离(没有指明元素具体指的是谁的元素，猜测是输出的）。默认：1 </p>
</li>
<li>
<p>如果 <code>kernel_size</code>, <code>dilation</code>, <code>padding</code> 或者 <code>stride</code>的值是一个int，或是一个长度为1的int元组，在相关操作的时候各个空间维度上都会使用这同一个值。 </p>
</li>
<li>如果输出向量有两个空间维度，那么此Fold操作有时又被称为<code>im2col</code>。</li>
</ul>
<p>Note
<a href="#torch.nn.Fold" title="torch.nn.Fold"><code>Fold</code></a>在执行类<code>col2im</code>的操作的时候，主要是是通过集成此im(输出张量）分裂出所有对应位置的col(输入的滑动块）来复原原im。而<a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>则是通过从输入张量中不断拷贝数值到相应的block中来生成由滑动块组成的输出张量。所以，如果滑动块之间如果有数值重叠，那这些滑动块之间并不是互逆的。</p>
<p>Warning</p>
<p>目前，只有四维张量(比如批次化的图像张量）支持这个操作。</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/2468b226c29a7e754a9c20f0214fa85f.jpg" /></li>
<li>输出: <img alt="" src="../img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" /></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; unfold = nn.Unfold(kernel_size=(2, 3))
&gt;&gt;&gt; input = torch.randn(2, 5, 3, 4)
&gt;&gt;&gt; output = unfold(input)
&gt;&gt;&gt; # each patch contains 30 values (2x3=6 vectors, each of 5 channels)
&gt;&gt;&gt; # 4 blocks (2x3 kernels) in total in the 3x4 input
&gt;&gt;&gt; output.size()
torch.Size([2, 30, 4])

&gt;&gt;&gt; # Convolution is equivalent with Unfold + Matrix Multiplication + Fold (or view to output shape)
&gt;&gt;&gt; inp = torch.randn(1, 3, 10, 12)
&gt;&gt;&gt; w = torch.randn(2, 3, 4, 5)
&gt;&gt;&gt; inp_unf = torch.nn.functional.unfold(inp, (4, 5))
&gt;&gt;&gt; out_unf = inp_unf.transpose(1, 2).matmul(w.view(w.size(0), -1).t()).transpose(1, 2)
&gt;&gt;&gt; out = torch.nn.functional.fold(out_unf, (7, 8), (1, 1))
&gt;&gt;&gt; # or equivalently (and avoiding a copy),
&gt;&gt;&gt; # out = out_unf.view(1, 2, 7, 8)
&gt;&gt;&gt; (torch.nn.functional.conv2d(inp, w) - out).abs().max()
tensor(1.9073e-06)

</code></pre>
<h3 id="fold">Fold</h3>
<pre><code class="language-py">class torch.nn.Fold(output_size, kernel_size, dilation=1, padding=0, stride=1)
</code></pre>
<p>将由滑动局部块组成的数组集合为一个大张量。(类col2im)</p>
<p>考虑一个包含了很多个滑动局部块的输入张量，比如，一批图像分割块(patches of images)的集合，大小为<img alt="" src="../img/9e56ff5e3827b936da5cfa3a5258b12e.jpg" />，其中<img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" />是batch大小， <img alt="" src="../img/a8846766f2e1b47021f1520993773ccb.jpg" /> 是一个块中的数值个数(每个块有<img alt="" src="../img/8c7a54ca7193bc3a6c5ace8c3b07d24c.jpg" />个空间位置，每个空间位置存储一个通道大小为<img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" />的向量），<img alt="" src="../img/db4a9fef02111450bf98261889de550c.jpg" />是滑动块的个数。(这些大小参数严格遵循了<a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>操作的输出向量的大小规定。）Fold操作通过求和重叠值的方式来将这些局部块集合为一个大小为<img alt="" src="../img/c2176aae9e099eeee07cc00c4dc7b7e7.jpg" />的<code>output</code>张量。与 <a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>类似，这些参数必须满足：</p>
<p><img alt="" src="../img/465bba7070e80a7e5964f46f7f5ed8bb.jpg" /></p>
<p>其中<img alt="" src="../img/9566974d45a96737f7e0ecf302d877b8.jpg" />遍历了各个空间维度。</p>
<ul>
<li><code>output_size</code> 描述了要生成的output的各空间维度的大小。有时，同样数量的滑动块，可能会产生多种<code>input</code>的形状，比如，当<code>stride &gt; 0</code>的时候，这时候，设置<code>output_size</code>参数就会显得极为重要。</li>
</ul>
<p><code>padding</code>, <code>stride</code> 和 <code>dilation</code> 参数指明了滑动块的相关性质。</p>
<ul>
<li><code>stride</code> 控制了滑动块的步长。</li>
<li><code>padding</code> 控制了在变换之前要向input的各维度各边上补齐的0的层数。 </li>
<li><code>dilation</code> 控制了卷积核中各点之间的空间距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了dilation的作用。</li>
</ul>
<p>Parameters: </p>
<ul>
<li>
<p><strong>output_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) –  输出向量的各空间维度的大小 (i.e., <code>input.sizes()[2:]</code>)</p>
</li>
<li>
<p><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 滑动块的大小</p>
</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 滑动块在输入各维度上的步长。默认: 1</li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 在输入各维度各边上补齐0的层数。</li>
<li>
<p><strong>dilation</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – 控制了各元素之间的距离(没有指明元素具体指的是谁的元素，猜测是输出的）。默认：1 </p>
</li>
<li>
<p>如果<code>output_size</code>， <code>kernel_size</code>, <code>dilation</code>, <code>padding</code> 或者 <code>stride</code>是一个int或者长度为1的int元组，在相关操作的时候各个空间维度上都会使用这同一个值。 </p>
</li>
<li>如果此输出向量的空间维度数为2，那么此Fold操作有时又被称为<code>col2im</code>。</li>
</ul>
<p>Note
<a href="#torch.nn.Fold" title="torch.nn.Fold"><code>Fold</code></a>在执行类<code>col2im</code>的操作的时候，主要是是通过集成此im(输出张量）分裂出所有对应位置的col(输入的滑动块）来复原原im。而<a href="#torch.nn.Unfold" title="torch.nn.Unfold"><code>Unfold</code></a>则是通过从输入张量中不断拷贝数值到相应的block中来生成由滑动块组成的输出张量。所以，如果滑动块之间如果有数值重叠，那这些滑动块之间并不是互逆的。</p>
<p>Warning</p>
<p>目前，只有四维张量(比如批次化的图像张量）支持这个操作。</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/4e1cad10fa9480fa82adbe59a5ae81fa.jpg" /></li>
<li>输出: <img alt="" src="../img/c2176aae9e099eeee07cc00c4dc7b7e7.jpg" /> </li>
</ul>
<p>举例:</p>
<pre><code class="language-py">&gt;&gt;&gt; fold = nn.Fold(output_size=(4, 5), kernel_size=(2, 2))
&gt;&gt;&gt; input = torch.randn(1, 3 * 2 * 2, 1)
&gt;&gt;&gt; output = fold(input)
&gt;&gt;&gt; output.size()

</code></pre>
<p><code>卷积层部分Fold 与 Unfold 是1.0新增的内容，猜测其主要目的是开放col2im和im2col这两个通过矩阵乘法实现卷积操作的前序接口，要好好理解这部分可能要了解一下现在主流框架通过大矩阵乘法来实现卷积操作这一通用做法了，这一篇文章就介绍的很好[Implementing convolution as a matrix multiplication](https://buptldy.github.io/2016/10/01/2016-10-01-im2col/)，这一段如果感觉我的直译晦涩难懂，那我深感抱歉并建议看一下英文原版，虽然我觉得英文原版介绍的也是晦涩难懂</code></p>
<h2 id="pooling-layers">池化层(Pooling layers）</h2>
<h3 id="maxpool1d">MaxPool1d</h3>
<pre><code class="language-py">class torch.nn.MaxPool1d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行一维最大池化操作。</p>
<p>最简单的情况下，对于输入大小为 <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /> ，输出大小为<img alt="" src="../img/d131773750846713475c600aa8cd917a.jpg" />的池化操作，此池化过程可表述如下：</p>
<p><img alt="" src="../img/9e414c5b7df992e54f3227bb130be349.jpg" /></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。
<code>dilation</code> 参数控制了池化核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>dilation</strong> – 滑动窗中各元素之间的距离</li>
<li><strong>return_indices</strong> – 如果此参数被设置为<code>True</code>， 那么此池化层在返回输出信号的同时还会返回一连串滑动窗最大值的索引位置，即每个滑动窗的最大值位置信息。这些信息可以在后面的上采样<a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>torch.nn.MaxUnpool1d</code></a>中被用到。</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/3ceb415a2a1558bab9998c277f780ec3.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/d131773750846713475c600aa8cd917a.jpg" /> 其中</p>
<p><img alt="" src="../img/ff16cce6b4741640e8adc0a271cd4592.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool1d(3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 50)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="maxpool2d">MaxPool2d</h3>
<pre><code class="language-py">class torch.nn.MaxPool2d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行二维最大池化操作。</p>
<p>最简单的情况下，对于输入大小为 <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /> ，输出大小为<img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" />，<code>kernel_size</code>为<img alt="" src="../img/6384e001ad4c0989683deb86f6ffbd2f.jpg" />的池化操作，此池化过程可表述如下：</p>
<p><img alt="" src="../img/caa8cbcbb8bbbbc6b0e47f9daa80ab12.jpg" /></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。
<code>dilation</code> 参数控制了池化核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的宽和高这两个维度的大小</li>
<li>一个由两个<code>int</code>组成的<code>tuple</code> – 这种情况下，高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>dilation</strong> – 滑动窗中各元素之间的距离</li>
<li><strong>return_indices</strong> – 如果此参数被设置为<code>True</code>， 那么此池化层在返回输出信号的同时还会返回一连串滑动窗最大值的索引位置，即每个滑动窗的最大值位置信息。这些信息可以在后面的上采样<a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>torch.nn.MaxUnpool2d</code></a>中被用到。</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" />, 其中</p>
<p><img alt="" src="../img/991d42318f90dcb68b26938c542b8457.jpg" /></p>
<p><img alt="" src="../img/1e35edf42ee6921adb435b5ca638d406.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool2d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.MaxPool2d((3, 2), stride=(2, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="maxpool3d">MaxPool3d</h3>
<pre><code class="language-py">class torch.nn.MaxPool3d(kernel_size, stride=None, padding=0, dilation=1, return_indices=False, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行三维最大池化操作。</p>
<p>最简单的情况下，对于输入大小为 <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /> ，输出大小为<img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" />，<code>kernel_size</code>为 <img alt="" src="../img/f5dcdebf9a81b9d15227749ae7535eb7.jpg" /> 的池化操作，此池化过程可表述如下：</p>
<p><img alt="" src="../img/f0f7a770dcfb802e7fc0f8995cfad3d7.jpg" /></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。
<code>dilation</code> 参数控制了池化核中各元素之间的距离；这也被称为多孔算法(à trous algorithm)。这个概念有点难解释，这个链接<a href="https://github.com/vdumoulin/conv_arithmetic/blob/master/README.md">link</a>用可视化的方法很好地解释了<code>dilation</code>的作用。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的深度，宽和高这三个维度的大小</li>
<li>一个由三个<code>int</code>组成的<code>tuple</code> – 这种情况下，深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 最大池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>dilation</strong> – 滑动窗中各元素之间的距离</li>
<li><strong>return_indices</strong> – 如果此参数被设置为<code>True</code>， 那么此池化层在返回输出信号的同时还会返回一连串滑动窗最大值的索引位置，即每个滑动窗的最大值位置信息。这些信息可以在后面的上采样<a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>torch.nn.MaxUnpool3d</code></a>中被用到。</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/c187d190013d0785320e3412fe8cd669.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" />, 其中</p>
<p><img alt="" src="../img/0e49f319aa911192458f7b02321eff3a.jpg" /></p>
<p><img alt="" src="../img/b8fbd329439d7eba62abdf0df19f464d.jpg" /></p>
<p><img alt="" src="../img/eb1d0c30d1cf681f38e8391bd7d03dff.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.MaxPool3d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.MaxPool3d((3, 2, 2), stride=(2, 1, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 50,44, 31)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="maxunpool1d">MaxUnpool1d</h3>
<pre><code class="language-py">class torch.nn.MaxUnpool1d(kernel_size, stride=None, padding=0)
</code></pre>
<p><a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>的逆过程，不过并不是完全的逆过程，因为在<a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>的过程中，池化窗区域内的非最大值都已经丢失。 <a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>MaxUnpool1d</code></a>的输入是<a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>的输出，其中也包括包括滑动窗最大值的索引(即return_indices所控制的输出），逆池化操作的过程就是将<a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>过程中产生的最大值插回到原来的位置，并将非最大值区域置为0。</p>
<p>Note</p>
<p><a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>操作可以将多个大小不同的输入映射到相同的输出大小。因此，池化操作的反过程，<a href="#torch.nn.MaxUnpool1d" title="torch.nn.MaxUnpool1d"><code>MaxUnpool1d</code></a>的上采样过程的输出大小就不唯一了。为了适应这一点，可以在设置控制上采样输出大小的(<code>output_size</code>）参数。 具体用法，请参阅下面的输入和示例</p>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的步长。默认<code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输入信号的各维度各边要补齐0的层数</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<ul>
<li><code>input</code>: 要执行上采样操作的张量</li>
<li><code>indices</code>: <a href="#torch.nn.MaxPool1d" title="torch.nn.MaxPool1d"><code>MaxPool1d</code></a>池化过程中输出的池化窗最大值的位置索引</li>
<li><code>output_size</code> (选填): 指定的输出大小</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/ccc1792005f1eb97a439118aeba930e9.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/1b0403b4ee318895368afc8fa37b9407.jpg" />, 其中</p>
<p><img alt="" src="../img/9618fc866026e724d16c5481dd67dc4c.jpg" /></p>
<p>也可以使用<code>output_size</code>指定输出的大小</p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; pool = nn.MaxPool1d(2, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool1d(2, stride=2)
&gt;&gt;&gt; input = torch.tensor([[[1., 2, 3, 4, 5, 6, 7, 8]]])
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices)
tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.]]])

&gt;&gt;&gt; # Example showcasing the use of output_size
&gt;&gt;&gt; input = torch.tensor([[[1., 2, 3, 4, 5, 6, 7, 8, 9]]])
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices, output_size=input.size())
tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.,  0.]]])

&gt;&gt;&gt; unpool(output, indices)
tensor([[[ 0.,  2.,  0.,  4.,  0.,  6.,  0., 8.]]])

</code></pre>
<h3 id="maxunpool2d">MaxUnpool2d</h3>
<pre><code class="language-py">class torch.nn.MaxUnpool2d(kernel_size, stride=None, padding=0)
</code></pre>
<p><a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>的逆过程，不过并不是完全的逆过程，因为在<a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>的过程中，池化窗区域内的非最大值都已经丢失。 <a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>MaxUnpool2d</code></a>的输入是<a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>的输出，其中也包括包括滑动窗最大值的索引(即return_indices所控制的输出），逆池化操作的过程就是将<a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>过程中产生的最大值插回到原来的位置，并将非最大值区域置为0。</p>
<p>Note</p>
<p><a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>操作可以将多个大小不同的输入映射到相同的输出大小。因此，池化操作的反过程，<a href="#torch.nn.MaxUnpool2d" title="torch.nn.MaxUnpool2d"><code>MaxUnpool2d</code></a>的上采样过程的输出大小就不唯一了。为了适应这一点，可以在设置控制上采样输出大小的(<code>output_size</code>）参数。 具体用法，请参阅下面的输入和示例</p>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的步长。默认<code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输入信号的各维度各边要补齐0的层数</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<ul>
<li><code>input</code>: 要执行上采样操作的张量</li>
<li><code>indices</code>: <a href="#torch.nn.MaxPool2d" title="torch.nn.MaxPool2d"><code>MaxPool2d</code></a>池化过程中输出的池化窗最大值的位置索引</li>
<li><code>output_size</code> (选填): 指定的输出大小</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" />, 其中</p>
<p><img alt="" src="../img/f6dd707e18ccbf75f607d05338443e87.jpg" /></p>
<p><img alt="" src="../img/ac5d54ef9922f9e0dbe2dc916bf9d80b.jpg" /></p>
<p>也可以使用<code>output_size</code>指定输出的大小</p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; pool = nn.MaxPool2d(2, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool2d(2, stride=2)
&gt;&gt;&gt; input = torch.tensor([[[[ 1.,  2,  3,  4],
 [ 5,  6,  7,  8],
 [ 9, 10, 11, 12],
 [13, 14, 15, 16]]]])
&gt;&gt;&gt; output, indices = pool(input)
&gt;&gt;&gt; unpool(output, indices)
tensor([[[[  0.,   0.,   0.,   0.],
 [  0.,   6.,   0.,   8.],
 [  0.,   0.,   0.,   0.],
 [  0.,  14.,   0.,  16.]]]])

&gt;&gt;&gt; # specify a different output size than input size
&gt;&gt;&gt; unpool(output, indices, output_size=torch.Size([1, 1, 5, 5]))
tensor([[[[  0.,   0.,   0.,   0.,   0.],
 [  6.,   0.,   8.,   0.,   0.],
 [  0.,   0.,   0.,  14.,   0.],
 [ 16.,   0.,   0.,   0.,   0.],
 [  0.,   0.,   0.,   0.,   0.]]]])

</code></pre>
<h3 id="maxunpool3d">MaxUnpool3d</h3>
<pre><code class="language-py">class torch.nn.MaxUnpool3d(kernel_size, stride=None, padding=0)
</code></pre>
<p><a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>的逆过程，不过并不是完全的逆过程，因为在<a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>的过程中，池化窗区域内的非最大值都已经丢失。 <a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>MaxUnpool3d</code></a>的输入是<a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>的输出，其中也包括包括滑动窗最大值的索引(即return_indices所控制的输出），逆池化操作的过程就是将<a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>过程中产生的最大值插回到原来的位置，并将非最大值区域置为0。</p>
<p>Note</p>
<p><a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>操作可以将多个大小不同的输入映射到相同的输出大小。因此，池化操作的反过程，<a href="#torch.nn.MaxUnpool3d" title="torch.nn.MaxUnpool3d"><code>MaxUnpool3d</code></a>的上采样过程的输出大小就不唯一了。为了适应这一点，可以在设置控制上采样输出大小的(<code>output_size</code>）参数。 具体用法，请参阅下面的输入和示例</p>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的大小</li>
<li><strong>stride</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 最大池化窗的步长。默认<code>kernel_size</code></li>
<li><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 输入信号的各维度各边要补齐0的层数</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<ul>
<li><code>input</code>: 要执行上采样操作的张量</li>
<li><code>indices</code>: <a href="#torch.nn.MaxPool3d" title="torch.nn.MaxPool3d"><code>MaxPool3d</code></a>池化过程中输出的池化窗最大值的位置索引</li>
<li><code>output_size</code> (选填): 指定的输出大小</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/c187d190013d0785320e3412fe8cd669.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" />, 其中</p>
<p><img alt="" src="../img/190cbccb4ab554a9b19bfc3df956f982.jpg" /></p>
<p><img alt="" src="../img/785a4e892f32eee65446b4e269fc452b.jpg" /></p>
<p><img alt="" src="../img/e666e9d78ffab5d03b4cf1adf1a6e331.jpg" /></p>
<p>也可以使用<code>output_size</code>指定输出的大小</p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; pool = nn.MaxPool3d(3, stride=2, return_indices=True)
&gt;&gt;&gt; unpool = nn.MaxUnpool3d(3, stride=2)
&gt;&gt;&gt; output, indices = pool(torch.randn(20, 16, 51, 33, 15))
&gt;&gt;&gt; unpooled_output = unpool(output, indices)
&gt;&gt;&gt; unpooled_output.size()
torch.Size([20, 16, 51, 33, 15])

</code></pre>
<h3 id="avgpool1d">AvgPool1d</h3>
<pre><code class="language-py">class torch.nn.AvgPool1d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
</code></pre>
<p>对输入的多通道信号执行一维平均池化操作。</p>
<p>最简单的情况下，对于输入大小为 <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /> ，输出大小为<img alt="" src="../img/d131773750846713475c600aa8cd917a.jpg" />，<code>kernel_size</code>为<img alt="" src="../img/a1c2f8d5b1226e67bdb44b12a6ddf18b.jpg" />的池化操作，此池化过程可表述如下：</p>
<p><img alt="" src="../img/5df0036df168f4a16d4437d91968f640.jpg" /></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>, <code>dilation</code> 等参数均支持输入一个int或者由一个int组成的tuple。</p>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
<li><strong>count_include_pad</strong> – 如果被设置为True, 那么在进行平均运算的时候也会将用于补齐的0加入运算。</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/3ceb415a2a1558bab9998c277f780ec3.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/d131773750846713475c600aa8cd917a.jpg" />, 其中</p>
<p><img alt="" src="../img/ad61a9298a545292682229fef2f1a910.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool with window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool1d(3, stride=2)
&gt;&gt;&gt; m(torch.tensor([[[1.,2,3,4,5,6,7]]]))
tensor([[[ 2.,  4.,  6.]]])

</code></pre>
<h3 id="avgpool2d">AvgPool2d</h3>
<pre><code class="language-py">class torch.nn.AvgPool2d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
</code></pre>
<p>对输入的多通道信号执行二维平均池化操作。
最简单的情况下，对于输入大小为  <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /> ，输出大小为<img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" />，<code>kernel_size</code>为<img alt="" src="../img/6384e001ad4c0989683deb86f6ffbd2f.jpg" />的池化操作，此池化过程可表述如下：</p>
<p><img alt="" src="../img/b7a0e1d0a42a3626724c14d89a10a44f.jpg" /></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的宽和高这两个维度的大小</li>
<li>一个由两个<code>int</code>组成的<code>tuple</code> – 这种情况下，高这一维度会采用元组中的第一个<code>int</code>数字，宽这一维度会采用第二个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
<li><strong>count_include_pad</strong> – 如果被设置为True, 那么在进行平均运算的时候也会将用于补齐的0加入运算。</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" />, 其中</p>
<p><img alt="" src="../img/8b8b2b1a77c4f104a936efb1708366ef.jpg" /></p>
<p><img alt="" src="../img/2792347200dabe493ae8baee428f9bf8.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool2d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.AvgPool2d((3, 2), stride=(2, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="avgpool3d">AvgPool3d</h3>
<pre><code class="language-py">class torch.nn.AvgPool3d(kernel_size, stride=None, padding=0, ceil_mode=False, count_include_pad=True)
</code></pre>
<p>对输入的多通道信号执行三维平均池化操作。
最简单的情况下，对于输入大小为<img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" />，输出大小为<img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" />，<code>kernel_size</code>为<img alt="" src="../img/f5dcdebf9a81b9d15227749ae7535eb7.jpg" />的池化操作，此池化过程可表述如下：</p>
<p><img alt="" src="../img/79acedd31cd18baac8d97ab96a7092e0.jpg" /></p>
<p><code>padding</code> 参数控制了要在输入信号的各维度各边上要补齐0的层数。</p>
<p><code>kernel_size</code>, <code>stride</code>, <code>padding</code>等参数均支持以下类型输入：</p>
<blockquote>
<ul>
<li>一个单独的 <code>int</code> – 此时这个<code>int</code>会同时控制池化滑动窗的深度，宽和高这两个维度的大小</li>
<li>一个由三个<code>int</code>组成的<code>tuple</code> – 这种情况下，深度这一维度会采用元组中的第一个<code>int</code>数字，高这一维度会采用元组中的第二个<code>int</code>数字，宽这一维度会采用第三个<code>int</code>数字。</li>
</ul>
</blockquote>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 平均池化操作的滑动窗大小</li>
<li><strong>stride</strong> – 滑动窗的步长，默认值是 <code>kernel_size</code></li>
<li><strong>padding</strong> – 要在输入信号的各维度各边上要补齐0的层数</li>
<li><strong>ceil_mode</strong> – 如果此参数被设置为True，计算输出信号大小的时候，会使用向上取整，代替默认的向下取整的操作</li>
<li><strong>count_include_pad</strong> – 如果被设置为True, 那么在进行平均运算的时候也会将用于补齐的0加入运算。</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/c187d190013d0785320e3412fe8cd669.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" />, 其中</p>
<p><img alt="" src="../img/443035401ce7a1144122a862f34493cf.jpg" /></p>
<p><img alt="" src="../img/8488a299a75cb56e138e1dc5a24a10db.jpg" /></p>
<p><img alt="" src="../img/c799c115b670c02d039f828fe1afa443.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.AvgPool3d(3, stride=2)
&gt;&gt;&gt; # pool of non-square window
&gt;&gt;&gt; m = nn.AvgPool3d((3, 2, 2), stride=(2, 1, 2))
&gt;&gt;&gt; input = torch.randn(20, 16, 50,44, 31)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="fractionalmaxpool2d">FractionalMaxPool2d</h3>
<pre><code class="language-py">class torch.nn.FractionalMaxPool2d(kernel_size, output_size=None, output_ratio=None, return_indices=False, _random_samples=None)
</code></pre>
<p>对输入的多通道信号执行小数级二维最大池化操作。<code>小数级</code>指的是此操作的输出大小与输入大小成指定的小数倍数关系。</p>
<p>Ben Graham的这篇文章<a href="http://arxiv.org/abs/1412.6071">Fractional MaxPooling</a>中详细地介绍了小数级二维最大池化的基本思想和技术细节。</p>
<p>小数级二维最大池化的基本思想就是将最大池化操作应用于<img alt="" src="../img/52ec12db6613ee8a0f6f41143ab2e8a2.jpg" />个由随机步长大小采集的区域中，这些步长大小是由输出目标的大小决定的。小数级二维最大池化的输出特征的数量等于输入通道的数量。</p>
<p>Parameters: </p>
<ul>
<li><strong>kernel_size</strong> – 执行最大操作的窗口大小。支持的数据类型包括一个单独的数字k(生成一个大小为k x k的正方形kernal)，或者一个元组 <code>(kh x kw)</code></li>
<li><strong>output_size</strong> – 池化输出目标大小，具体形式是 <code>oH x oW</code>。支持的数据类型包括一个单独的数字<code>oH</code>，或者一个元组 <code>(oH, oW)</code>，注意此处<code>oH x oW</code>与<code>kernal_size</code>中的<code>kh x ow</code>相呼应，两者成一定的小数级倍数关系</li>
<li><strong>output_ratio</strong> – 如果想让输出目标的大小是输入目标大小的ratio倍，可以通过设置此参数来实现。此参数可以是一个小数数字或者小数元组，数字范围是(0, 1)</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool2d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # pool of square window of size=3, and target output size 13x12
&gt;&gt;&gt; m = nn.FractionalMaxPool2d(3, output_size=(13, 12))
&gt;&gt;&gt; # pool of square window and target output size being half of input image size
&gt;&gt;&gt; m = nn.FractionalMaxPool2d(3, output_ratio=(0.5, 0.5))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="lppool1d">LPPool1d</h3>
<pre><code class="language-py">class torch.nn.LPPool1d(norm_type, kernel_size, stride=None, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行一维幂平均池化操作。</p>
<p>对于每个池化窗口，此池化操作的计算方式如下：</p>
<p><img alt="" src="../img/e4451f809255881ee286970ddf3fb377.jpg" /></p>
<ul>
<li>当p为无穷大的时候时，等价于最大池化操作</li>
<li>当<code>p=1</code>时，等价于求和池化操作(一定程度上等价于平均池化）</li>
</ul>
<p>Note</p>
<p>如果某个特殊的输入导致这个输入关于幂指数<code>p</code>的求和是0，那上述池化函数在这一点是没有意义的。在实际实现过程中，此点的梯度被设置为0。</p>
<p>Parameters: </p>
<ul>
<li>kernel_size: 池化窗口的大小</li>
<li>stride：池化窗口移动的步长。默认值是<code>kernel_size</code></li>
<li>ceil_mode: 当此参数被设置为<code>True</code>时，在计算输出大小的时候将使用向下取整代替向上取整</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/3ceb415a2a1558bab9998c277f780ec3.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/d131773750846713475c600aa8cd917a.jpg" />，其中</p>
<p><img alt="" src="../img/5d246e9891509c48081bc89191e64418.jpg" /></p>
</li>
</ul>
<pre><code class="language-py">例子:
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; # power-2 pool of window of length 3, with stride 2.
&gt;&gt;&gt; m = nn.LPPool1d(2, 3, stride=2)
&gt;&gt;&gt; input = torch.randn(20, 16, 50)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="lppool2d">LPPool2d</h3>
<pre><code class="language-py">class torch.nn.LPPool2d(norm_type, kernel_size, stride=None, ceil_mode=False)
</code></pre>
<p>对输入的多通道信号执行二维幂平均池化操作。</p>
<p>对于每个池化窗口，此池化操作的计算方式如下：</p>
<p><img alt="" src="../img/e4451f809255881ee286970ddf3fb377.jpg" /></p>
<ul>
<li>当p等于<img alt="" src="../img/b0c1b8fa38555e0b1ca3265b84bb3974.jpg" />时候时，等价于最大池化操作</li>
<li>当<code>p=1</code>时，等价于求和池化操作(一定程度上等价于平均池化）</li>
</ul>
<p>参数<code>kernel_size</code>, <code>stride</code>支持的数据类型：</p>
<ul>
<li><code>int</code>，池化窗口的宽和高相等</li>
<li><code>tuple</code>数组(两个数字的），第一个元素是池化窗口的高，第二个是宽</li>
</ul>
<p>Note</p>
<p>如果某个特殊的输入导致这个输入关于幂指数<code>p</code>的求和是0，那上述池化函数在这一点是没有意义的。在实际实现过程中，此点的梯度被设置为0。</p>
<p>Parameters: </p>
<ul>
<li>kernel_size: 池化窗口的大小</li>
<li>stride：池化窗口移动的步长。默认值是<code>kernel_size</code></li>
<li>ceil_mode: 当此参数被设置为<code>True</code>时，在计算输出大小的时候将使用向下取整代替向上取整</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" />, 其中</p>
<p><img alt="" src="../img/44bfdaa5e6b603085c2da3eddb558556.jpg" /></p>
<p><img alt="" src="../img/d59b07475dea090e5f7110600d8f8bdc.jpg" /></p>
</li>
</ul>
<p>例子:</p>
<pre><code class="language-py">&gt;&gt;&gt; # power-2 pool of square window of size=3, stride=2
&gt;&gt;&gt; m = nn.LPPool2d(2, 3, stride=2)
&gt;&gt;&gt; # pool of non-square window of power 1.2
&gt;&gt;&gt; m = nn.LPPool2d(1.2, (3, 2), stride=(2, 1))
&gt;&gt;&gt; input = torch.randn(20, 16, 50, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivemaxpool1d">AdaptiveMaxPool1d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveMaxPool1d(output_size, return_indices=False)
</code></pre>
<p>对输入的多通道信号进行1维的自适应最大池化操作。</p>
<p>此池化层可以通过指定输出大小H，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters: </p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool1d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5
&gt;&gt;&gt; m = nn.AdaptiveMaxPool1d(5)
&gt;&gt;&gt; input = torch.randn(1, 64, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivemaxpool2d">AdaptiveMaxPool2d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveMaxPool2d(output_size, return_indices=False)
</code></pre>
<p>对输入的多通道信号进行2维的自适应最大池化操作。</p>
<p>此池化层可以通过指定输出大小H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters: </p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H x W。此参数支持的数据类型可以是一个元组(H, W)，又或者是一个单独的<code>int</code> H(等价于H x H）。H 和 W这两个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool2d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((5,7))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7 (square)
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 10x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((None, 7))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivemaxpool3d">AdaptiveMaxPool3d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveMaxPool3d(output_size, return_indices=False)
</code></pre>
<p>对输入的多通道信号进行3维的自适应最大池化操作。</p>
<p>此池化层可以通过指定输出大小D x H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters: </p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小D x H x W。此参数支持的数据类型可以是一个元组(D, H, W)，又或者是一个单独的<code>int</code> D(等价于D x D x D)。D, H 和 W这三个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
<li><strong>return_indices</strong> – 如果此参数设置为<code>True</code>, 那么在池化操作结束后，返回池化输出结果的同时也会返回每个池化区域中，最大值的位置信息。这些信息在<code>nn.MaxUnpool3d()</code>可以被用到。此参数默认为<code>False</code></li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7x9
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((5,7,9))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9, 10)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7x7 (cube)
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x9x8
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((7, None, None))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptiveavgpool1d">AdaptiveAvgPool1d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveAvgPool1d(output_size)
</code></pre>
<p>对输入的多通道信号进行1维的自适应平均池化操作。</p>
<p>此池化层可以通过指定输出大小H，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters: </p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H</li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5
&gt;&gt;&gt; m = nn.AdaptiveAvgPool1d(5)
&gt;&gt;&gt; input = torch.randn(1, 64, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptiveavgpool2d">AdaptiveAvgPool2d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveAvgPool2d(output_size)
</code></pre>
<p>对输入的多通道信号进行2维的自适应平均池化操作。</p>
<p>此池化层可以通过指定输出大小H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters: </p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小H x W。此参数支持的数据类型可以是一个元组(H, W)，又或者是一个单独的<code>int</code> H(等价于H x H）。H 和 W这两个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7
&gt;&gt;&gt; m = nn.AdaptiveAvgPool2d((5,7))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7 (square)
&gt;&gt;&gt; m = nn.AdaptiveAvgPool2d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 10x7
&gt;&gt;&gt; m = nn.AdaptiveMaxPool2d((None, 7))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptiveavgpool3d">AdaptiveAvgPool3d</h3>
<pre><code class="language-py">class torch.nn.AdaptiveAvgPool3d(output_size)
</code></pre>
<p>对输入的多通道信号进行3维的自适应平均池化操作。</p>
<p>此池化层可以通过指定输出大小D x H x W，将任意输入大小的输入强行的池化到指定的输出大小。不过输入和输出特征的通道数不会变化。</p>
<p>Parameters: </p>
<ul>
<li><strong>output_size</strong> – 指定的输出大小D x H x W。此参数支持的数据类型可以是一个元组(D, H, W)，又或者是一个单独的<code>int</code> D(等价于D x D x D)。D, H 和 W这三个参数支持输入一个<code>int</code>又或者是<code>None</code>, <code>None</code>表示此输出维度的大小等价于输入数据此维度的大小</li>
</ul>
<p>例子</p>
<pre><code class="language-py">&gt;&gt;&gt; # target output size of 5x7x9
&gt;&gt;&gt; m = nn.AdaptiveAvgPool3d((5,7,9))
&gt;&gt;&gt; input = torch.randn(1, 64, 8, 9, 10)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x7x7 (cube)
&gt;&gt;&gt; m = nn.AdaptiveAvgPool3d(7)
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # target output size of 7x9x8
&gt;&gt;&gt; m = nn.AdaptiveMaxPool3d((7, None, None))
&gt;&gt;&gt; input = torch.randn(1, 64, 10, 9, 8)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="padding-layers">填充层(Padding layers）</h2>
<h3 id="reflectionpad1d">ReflectionPad1d</h3>
<pre><code class="language-py">class torch.nn.ReflectionPad1d(padding)
</code></pre>
<p>以输入张量的各边界为轴，通过对输入张量数据的进行镜像复制的方式来对输入张量进行填充操作。</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个两个元素的元组，那么按照 (<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/964aa6df63e83f4468aa090441f01972.jpg" /></li>
<li>输出: <img alt="" src="../img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" /> 其中 <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReflectionPad1d(2)
&gt;&gt;&gt; input = torch.arange(8, dtype=torch.float).reshape(1, 2, 4)
&gt;&gt;&gt; input
tensor([[[0., 1., 2., 3.],
 [4., 5., 6., 7.]]])
&gt;&gt;&gt; m(input)
tensor([[[2., 1., 0., 1., 2., 3., 2., 1.],
 [6., 5., 4., 5., 6., 7., 6., 5.]]])
&gt;&gt;&gt; m(input)
tensor([[[2., 1., 0., 1., 2., 3., 2., 1.],
 [6., 5., 4., 5., 6., 7., 6., 5.]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReflectionPad1d((3, 1))
&gt;&gt;&gt; m(input)
tensor([[[3., 2., 1., 0., 1., 2., 3., 2.],
 [7., 6., 5., 4., 5., 6., 7., 6.]]])

</code></pre>
<h3 id="reflectionpad2d">ReflectionPad2d</h3>
<pre><code class="language-py">class torch.nn.ReflectionPad2d(padding)
</code></pre>
<p>以输入张量的各边界为轴，通过对输入张量数据的进行镜像复制的方式来对输入张量进行填充操作。</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个四个元素的元组，那么按照(<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />, <img alt="" src="../img/65f6ce26141c225acd502a7bef164f66.jpg" />, <img alt="" src="../img/9a98061e27ba6ed06e846767b9c77c3a.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></p>
</li>
<li>
<p>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> 其中</p>
<p><img alt="" src="../img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" /> <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></p>
</li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReflectionPad2d(2)
&gt;&gt;&gt; input = torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)
&gt;&gt;&gt; input
tensor([[[[0., 1., 2.],
 [3., 4., 5.],
 [6., 7., 8.]]]])
&gt;&gt;&gt; m(input)
tensor([[[[8., 7., 6., 7., 8., 7., 6.],
 [5., 4., 3., 4., 5., 4., 3.],
 [2., 1., 0., 1., 2., 1., 0.],
 [5., 4., 3., 4., 5., 4., 3.],
 [8., 7., 6., 7., 8., 7., 6.],
 [5., 4., 3., 4., 5., 4., 3.],
 [2., 1., 0., 1., 2., 1., 0.]]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReflectionPad2d((1, 1, 2, 0))
&gt;&gt;&gt; m(input)
tensor([[[[7., 6., 7., 8., 7.],
 [4., 3., 4., 5., 4.],
 [1., 0., 1., 2., 1.],
 [4., 3., 4., 5., 4.],
 [7., 6., 7., 8., 7.]]]])

</code></pre>
<h3 id="replicationpad1d">ReplicationPad1d</h3>
<pre><code class="language-py">class torch.nn.ReplicationPad1d(padding)
</code></pre>
<p>通过复制输入张量边界元素的方式对输入张量进行填充操作。</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个两个元素的元组，那么按照 (<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/964aa6df63e83f4468aa090441f01972.jpg" /></li>
<li>输出: <img alt="" src="../img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" /> 其中 <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad1d(2)
&gt;&gt;&gt; input = torch.arange(8, dtype=torch.float).reshape(1, 2, 4)
&gt;&gt;&gt; input
tensor([[[0., 1., 2., 3.],
 [4., 5., 6., 7.]]])
&gt;&gt;&gt; m(input)
tensor([[[0., 0., 0., 1., 2., 3., 3., 3.],
 [4., 4., 4., 5., 6., 7., 7., 7.]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReplicationPad1d((3, 1))
&gt;&gt;&gt; m(input)
tensor([[[0., 0., 0., 0., 1., 2., 3., 3.],
 [4., 4., 4., 4., 5., 6., 7., 7.]]])

</code></pre>
<h3 id="replicationpad2d">ReplicationPad2d</h3>
<pre><code class="language-py">class torch.nn.ReplicationPad2d(padding)
</code></pre>
<p>通过复制输入张量边界元素的方式对输入张量进行填充操作。</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个四个元素的元组，那么按照(<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />, <img alt="" src="../img/65f6ce26141c225acd502a7bef164f66.jpg" />, <img alt="" src="../img/9a98061e27ba6ed06e846767b9c77c3a.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></li>
<li>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> 其中 <img alt="" src="../img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" /> <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad2d(2)
&gt;&gt;&gt; input = torch.arange(9, dtype=torch.float).reshape(1, 1, 3, 3)
&gt;&gt;&gt; input
tensor([[[[0., 1., 2.],
 [3., 4., 5.],
 [6., 7., 8.]]]])
&gt;&gt;&gt; m(input)
tensor([[[[0., 0., 0., 1., 2., 2., 2.],
 [0., 0., 0., 1., 2., 2., 2.],
 [0., 0., 0., 1., 2., 2., 2.],
 [3., 3., 3., 4., 5., 5., 5.],
 [6., 6., 6., 7., 8., 8., 8.],
 [6., 6., 6., 7., 8., 8., 8.],
 [6., 6., 6., 7., 8., 8., 8.]]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReplicationPad2d((1, 1, 2, 0))
&gt;&gt;&gt; m(input)
tensor([[[[0., 0., 1., 2., 2.],
 [0., 0., 1., 2., 2.],
 [0., 0., 1., 2., 2.],
 [3., 3., 4., 5., 5.],
 [6., 6., 7., 8., 8.]]]])

</code></pre>
<h3 id="replicationpad3d">ReplicationPad3d</h3>
<pre><code class="language-py">class torch.nn.ReplicationPad3d(padding)
</code></pre>
<p>通过复制输入张量边界元素的方式对输入张量进行填充操作。</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个六个元素的元组，那么按照(<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />, <img alt="" src="../img/65f6ce26141c225acd502a7bef164f66.jpg" />, <img alt="" src="../img/9a98061e27ba6ed06e846767b9c77c3a.jpg" />, <img alt="" src="../img/bffb266183e8fa640240e16a45076c34.jpg" />, <img alt="" src="../img/9138ac0ee6f6e96dfe795ead91ec0003.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/c187d190013d0785320e3412fe8cd669.jpg" /></li>
<li>输出: <img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" /> 其中 <img alt="" src="../img/006114d9c80210ede5da92f2f3a44bb7.jpg" /> <img alt="" src="../img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" /> <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReplicationPad3d(3)
&gt;&gt;&gt; input = torch.randn(16, 3, 8, 320, 480)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ReplicationPad3d((3, 3, 6, 6, 1, 1))
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="zeropad2d">ZeroPad2d</h3>
<pre><code class="language-py">class torch.nn.ZeroPad2d(padding)
</code></pre>
<p>通过在各边上填充0的方式对输入张量进行填充操作。</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个四个元素的元组，那么按照(<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />, <img alt="" src="../img/65f6ce26141c225acd502a7bef164f66.jpg" />, <img alt="" src="../img/9a98061e27ba6ed06e846767b9c77c3a.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></li>
<li>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> 其中 <img alt="" src="../img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" /> <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ZeroPad2d(2)
&gt;&gt;&gt; input = torch.randn(1, 1, 3, 3)
&gt;&gt;&gt; input
tensor([[[[-0.1678, -0.4418,  1.9466],
 [ 0.9604, -0.4219, -0.5241],
 [-0.9162, -0.5436, -0.6446]]]])
&gt;&gt;&gt; m(input)
tensor([[[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000, -0.1678, -0.4418,  1.9466,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.9604, -0.4219, -0.5241,  0.0000,  0.0000],
 [ 0.0000,  0.0000, -0.9162, -0.5436, -0.6446,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ZeroPad2d((1, 1, 2, 0))
&gt;&gt;&gt; m(input)
tensor([[[[ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000],
 [ 0.0000, -0.1678, -0.4418,  1.9466,  0.0000],
 [ 0.0000,  0.9604, -0.4219, -0.5241,  0.0000],
 [ 0.0000, -0.9162, -0.5436, -0.6446,  0.0000]]]])

</code></pre>
<h3 id="constantpad1d">ConstantPad1d</h3>
<pre><code class="language-py">class torch.nn.ConstantPad1d(padding, value)
</code></pre>
<p>通过在各边上填充固定数字的方式对输入张量进行填充操作</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个两个元素的元组，那么按照 (<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/964aa6df63e83f4468aa090441f01972.jpg" /></li>
<li>输出: <img alt="" src="../img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" /> 其中 <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad1d(2, 3.5)
&gt;&gt;&gt; input = torch.randn(1, 2, 4)
&gt;&gt;&gt; input
tensor([[[-1.0491, -0.7152, -0.0749,  0.8530],
 [-1.3287,  1.8966,  0.1466, -0.2771]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000, -1.0491, -0.7152, -0.0749,  0.8530,  3.5000,
 3.5000],
 [ 3.5000,  3.5000, -1.3287,  1.8966,  0.1466, -0.2771,  3.5000,
 3.5000]]])
&gt;&gt;&gt; m = nn.ConstantPad1d(2, 3.5)
&gt;&gt;&gt; input = torch.randn(1, 2, 3)
&gt;&gt;&gt; input
tensor([[[ 1.6616,  1.4523, -1.1255],
 [-3.6372,  0.1182, -1.8652]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000,  3.5000],
 [ 3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000,  3.5000]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ConstantPad1d((3, 1), 3.5)
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  1.6616,  1.4523, -1.1255,  3.5000],
 [ 3.5000,  3.5000,  3.5000, -3.6372,  0.1182, -1.8652,  3.5000]]])

</code></pre>
<h3 id="constantpad2d">ConstantPad2d</h3>
<pre><code class="language-py">class torch.nn.ConstantPad2d(padding, value)
</code></pre>
<p>通过在各边上填充固定数字的方式对输入张量进行填充操作</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个四个元素的元组，那么按照(<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />, <img alt="" src="../img/65f6ce26141c225acd502a7bef164f66.jpg" />, <img alt="" src="../img/9a98061e27ba6ed06e846767b9c77c3a.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></li>
<li>输出: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> 其中 <img alt="" src="../img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" /> <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad2d(2, 3.5)
&gt;&gt;&gt; input = torch.randn(1, 2, 2)
&gt;&gt;&gt; input
tensor([[[ 1.6585,  0.4320],
 [-0.8701, -0.4649]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  1.6585,  0.4320,  3.5000,  3.5000],
 [ 3.5000,  3.5000, -0.8701, -0.4649,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  1.6585,  0.4320,  3.5000,  3.5000],
 [ 3.5000,  3.5000, -0.8701, -0.4649,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ConstantPad2d((3, 0, 2, 1), 3.5)
&gt;&gt;&gt; m(input)
tensor([[[ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000],
 [ 3.5000,  3.5000,  3.5000,  1.6585,  0.4320],
 [ 3.5000,  3.5000,  3.5000, -0.8701, -0.4649],
 [ 3.5000,  3.5000,  3.5000,  3.5000,  3.5000]]])

</code></pre>
<h3 id="constantpad3d">ConstantPad3d</h3>
<pre><code class="language-py">class torch.nn.ConstantPad3d(padding, value)
</code></pre>
<p>通过在各边上填充固定数字的方式对输入张量进行填充操作</p>
<p>对于<code>N</code>维的填充操作，调用<a href="#torch.nn.functional.pad" title="torch.nn.functional.pad"><code>torch.nn.functional.pad()</code></a>。</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>padding</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a>) – 要填充的范围大小。如果输入数据是一个<code>int</code>, 那各个边界上都会填充同样大小的数据。如果是一个六个元素的元组，那么按照(<img alt="" src="../img/08b2cac9ee37dde4cec3d372ebbfa0bd.jpg" />, <img alt="" src="../img/9f56071a00e2baa50d7fa9bde997852d.jpg" />, <img alt="" src="../img/65f6ce26141c225acd502a7bef164f66.jpg" />, <img alt="" src="../img/9a98061e27ba6ed06e846767b9c77c3a.jpg" />, <img alt="" src="../img/bffb266183e8fa640240e16a45076c34.jpg" />, <img alt="" src="../img/9138ac0ee6f6e96dfe795ead91ec0003.jpg" />)的大小设定来在各边上填充。</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/c187d190013d0785320e3412fe8cd669.jpg" /></li>
<li>输出: <img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" /> 其中 <img alt="" src="../img/006114d9c80210ede5da92f2f3a44bb7.jpg" /> <img alt="" src="../img/75aa7c4a6c84e0ccb8aa91592cf6a077.jpg" /> <img alt="" src="../img/e2294a717e6d12035072d23c45273863.jpg" /></li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ConstantPad3d(3, 3.5)
&gt;&gt;&gt; input = torch.randn(16, 3, 10, 20, 30)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; # using different paddings for different sides
&gt;&gt;&gt; m = nn.ConstantPad3d((3, 3, 6, 6, 0, 1), 3.5)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="non-linear-activations-weighted-sum-nonlinearity">非线性激活(加权求和，非线性) ( Non-linear activations (weighted sum, nonlinearity))</h2>
<h3 id="elu">ELU</h3>
<pre><code class="language-py">class torch.nn.ELU(alpha=1.0, inplace=False)
</code></pre>
<p>将下面的元素级函数应用到输入张量上：</p>
<p><img alt="" src="../img/1285687f031aec0751f4e0481f97b6b0.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>alpha</strong> – ELU操作的<img alt="" src="../img/82005cc2e0087e2a52c7e43df4a19a00.jpg" />值。 默认： 1.0</li>
<li><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//ELU.png" src="../img/5d789140032850b13d5c00493bf62412.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ELU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="hardshrink">Hardshrink</h3>
<pre><code class="language-py">class torch.nn.Hardshrink(lambd=0.5)
</code></pre>
<p>将下面的元素级hard shrinkage函数应用到输入张量上：</p>
<p><img alt="" src="../img/f934a1a7fa1553c38403f2e010708ed9.jpg" /></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>lambd</strong> – Hardshrink运算中的 <img alt="" src="../img/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" /> 值。 默认: 0.5</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Hardshrink.png" src="../img/45889773f687ed0d33a3ef9b66b0da32.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Hardshrink()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="hardtanh">Hardtanh</h3>
<pre><code class="language-py">class torch.nn.Hardtanh(min_val=-1.0, max_val=1.0, inplace=False, min_value=None, max_value=None)
</code></pre>
<p>将下面的元素级HardTanh函数应用到输入张量上。</p>
<p>HardTanh函数定义如下:</p>
<p><img alt="" src="../img/988cd664634d88b1e654ea5e8fe27d9a.jpg" /></p>
<p>线性区域<img alt="" src="../img/f30fa7744d61427a11bf0e75b1557a16.jpg" /> 的大小可以通过设置<code>min_val</code> 参数 <code>max_val</code>来进行调整。</p>
<p><img alt="https://pytorch.org/docs/stable/_images//Hardtanh.png" src="../img/b22ab176e5aca7ca2b17e84fe525620e.jpg" /></p>
<p>参数: </p>
<ul>
<li><strong>min_val</strong> – 线性区域的下限. 默认: -1</li>
<li><strong>max_val</strong> – 线性区域的上限. 默认: 1</li>
<li><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></li>
</ul>
<p>之前版本的<code>min_value</code> 和 <code>max_value</code> 参数已经被废弃掉了，改为<code>min_val</code> 和 <code>max_val</code>参数。</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Hardtanh(-2, 2)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="leakyrelu">LeakyReLU</h3>
<pre><code class="language-py">class torch.nn.LeakyReLU(negative_slope=0.01, inplace=False)
</code></pre>
<p>将下面的元素级函数应用到输入张量上：</p>
<p><img alt="" src="../img/92ce1c3da3211f30ef5273403da71c7a.jpg" /></p>
<p>或</p>
<p><img alt="" src="../img/377c237cda65f4c68e3138efcc2bfef4.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>negative_slope</strong> – 控制负数范围函数的斜率。 默认: 1e-2</li>
<li><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//LeakyReLU.png" src="../img/7df3c1e498d7d00e9e32ce7716e15fc3.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LeakyReLU(0.1)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="logsigmoid">LogSigmoid</h3>
<pre><code class="language-py">class torch.nn.LogSigmoid
</code></pre>
<p>将下面的元素级函数LogSigmoid应用到输入张量上：(此处漏了一张图，后期补一下)</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//LogSigmoid.png" src="../img/f03b653b702dcd536fbb404c6461b399.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LogSigmoid()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="prelu">PReLU</h3>
<pre><code class="language-py">class torch.nn.PReLU(num_parameters=1, init=0.25)
</code></pre>
<p>将下面的元素级函数应用到输入张量上：</p>
<p><img alt="" src="../img/96fb709d31ba330ca192080e660d4cf1.jpg" /></p>
<p>或</p>
<p><img alt="" src="../img/f460dc15bedfa96b8a320033b3f4fd6f.jpg" /></p>
<p>此处 <img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" /> 是一个可学习的参数。 如果在调用<code>nn.PReLU()</code>函数的时候没有传入参数，那么会默认在所有的输入通道上应用同一个<img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" /> 参数。 如果以<code>nn.PReLU(nChannels)</code>这种方式调用， 每个输入通道都会有一个单独的<img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" /> 参数。</p>
<p>Note</p>
<p>想要学一个好的<img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" />参数，最好不要用weight decay。</p>
<p>Note</p>
<p>通道维度是输入张量的第二个维度。当输入张量的维度数 &lt; 2的时候，那此输入张量就没有通道维度，而此时其通道数被认为是1。</p>
<p>Parameters: </p>
<ul>
<li><strong>num_parameters</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – 要进行训练学习的 <img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" /> 参数的数量。尽管此函数的输入是一个整形，但此函数要求输入的整形只能为两个值，1或者输入张量的通道数。默认：1 </li>
<li><strong>init</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – <img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" />的初始值，默认: 0.25</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – 大小为<code>num_parameters</code>的可学习参数。The attr:<code>dtype</code> is default to(这句话有点问题， to后面漏掉了）</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p><img alt="https://pytorch.org/docs/stable/_images//PReLU.png" src="../img/59baba7257ac05b747455a25a3457baf.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.PReLU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="relu">ReLU</h3>
<pre><code class="language-py">class torch.nn.ReLU(inplace=False)
</code></pre>
<p>将元素级线性整流函数函数应用到输入张量上<img alt="" src="../img/f859c48107afb47986b3297459048c80.jpg" />
Applies the rectified linear unit function element-wise </p>
<p><img alt="https://pytorch.org/docs/stable/_images//ReLU.png" src="../img/6bfe295d2f51e4e33648ffb4273723a6.jpg" /></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReLU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="relu6">ReLU6</h3>
<pre><code class="language-py">class torch.nn.ReLU6(inplace=False)
</code></pre>
<p>将下面的元素级函数应用到输入张量上:</p>
<p><img alt="" src="../img/38c45c0cb00fa6f9a372816012b26b01.jpg" /></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//ReLU6.png" src="../img/3a82f9216f0db7d59f6c0f1c169156b0.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.ReLU6()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="rrelu">RReLU</h3>
<pre><code class="language-py">class torch.nn.RReLU(lower=0.125, upper=0.3333333333333333, inplace=False)
</code></pre>
<p>将元素级随机线性整流函数函数应用到输入张量上，详情此文章：</p>
<p><a href="https://arxiv.org/abs/1505.00853">Empirical Evaluation of Rectified Activations in Convolutional Network</a>.</p>
<p>此函数定义如下:</p>
<p><img alt="" src="../img/69aa6828f2f0bcd0ee1e173223ff4640.jpg" /></p>
<p>其中 <img alt="" src="../img/070b1af5eca3a5c5d72884b536090f17.jpg" /> 是从此均匀分布中采样而来：<img alt="" src="../img/7323b93ed925c9e5b0ce10c8a6c99daf.jpg" />.</p>
<blockquote>
<p>详见: <a href="https://arxiv.org/pdf/1505.00853.pdf">https://arxiv.org/pdf/1505.00853.pdf</a></p>
</blockquote>
<p>Parameters: </p>
<ul>
<li><strong>lower</strong> – 均匀分布下限， 默认: <img alt="" src="../img/444fc0427eb64f0bd2c9c16edf680d4f.jpg" /></li>
<li><strong>upper</strong> – 均匀分布上限，默认: <img alt="" src="../img/a90c89c913a1fe1e9462d60d8668936b.jpg" /></li>
<li><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.RReLU(0.1, 0.3)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="selu">SELU</h3>
<pre><code class="language-py">class torch.nn.SELU(inplace=False)
</code></pre>
<p>将下面的元素级函数应用到输入张量上:</p>
<p><img alt="" src="../img/c6753a504d14886a424af779f5906dc5.jpg" /></p>
<p>其中 <img alt="" src="../img/e97a0b3de4bafa3464e17a8d8f66fd9d.jpg" /> 而且 <img alt="" src="../img/aa01199f9b814d719de1e728e4a44ac3.jpg" />.</p>
<p><img alt="https://pytorch.org/docs/stable/_images//SELU.png" src="../img/10123138310ae40f4a78f55cefe37008.jpg" /></p>
<p>More details can be found in the paper <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a> .</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – 是否进行原位操作。 默认： <code>False</code></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.SELU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="celu">CELU</h3>
<pre><code class="language-py">class torch.nn.CELU(alpha=1.0, inplace=False)
</code></pre>
<p>将下面的元素级函数应用到输入张量上：</p>
<p><img alt="" src="../img/86d69b42683362b7781f1a5809c0d0d1.jpg" /></p>
<p>更多细节请见paper: <a href="https://arxiv.org/abs/1704.07483">Continuously Differentiable Exponential Linear Units</a> .</p>
<p>Parameters: </p>
<ul>
<li><strong>alpha</strong> – CELU操作中的 <img alt="" src="../img/82005cc2e0087e2a52c7e43df4a19a00.jpg" /> 值，默认: 1.0</li>
<li><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//CELU.png" src="../img/8d5fd8f893fb491c170f9a38af6edef9.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.CELU()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="sigmoid">Sigmoid</h3>
<pre><code class="language-py">class torch.nn.Sigmoid
</code></pre>
<p>将下面的元素级函数应用到输入张量上：</p>
<p><img alt="" src="../img/8bf3a718397550598124548beb8c6b23.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Sigmoid.png" src="../img/961caeb46e669eb70392afd515f9bde7.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Sigmoid()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softplus">Softplus</h3>
<pre><code class="language-py">class torch.nn.Softplus(beta=1, threshold=20)
</code></pre>
<p>将下面的元素级函数应用到输入张量上:</p>
<p><img alt="" src="../img/a0855ca512a1ba09192648efd45082ad.jpg" /></p>
<p>SoftPlus是一个平滑的类ReLU函数，可以用于将输出结果规范到全正。</p>
<p>为了数值稳定性，在实现此函数的过程中，当 <code>x</code> 超过某个特定值之后，我们会将此函数转化为一个线性函数。</p>
<p>Parameters: </p>
<ul>
<li><strong>beta</strong> – Softplus操作的 <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> 值，默认: 1</li>
<li><strong>threshold</strong> – 将函数转化为线性函数的阈值， 默认: 20</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Softplus.png" src="../img/af06304134e1f56d7abc15570fa5adb9.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softplus()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softshrink">Softshrink</h3>
<pre><code class="language-py">class torch.nn.Softshrink(lambd=0.5)
</code></pre>
<p>将下面的元素级软收缩函数应用到输入张量上:</p>
<p><img alt="" src="../img/5baf58b3007cf434725f41bf2dfae2ce.jpg" /></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>lambd</strong> – 软收缩运算的<img alt="" src="../img/5e8df2ba7e47a784c714d176ed8bbb7a.jpg" />值，默认: 0.5</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Softshrink.png" src="../img/cec198ab680657d41c1d2ac2176e5664.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softshrink()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softsign">Softsign</h3>
<pre><code class="language-py">class torch.nn.Softsign
</code></pre>
<p>将下面的元素级函数应用到输入张量上:</p>
<p><img alt="" src="../img/39ba3e3786920ceb12bc26b08b00de1c.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Softsign.png" src="../img/b92a09469ce9fc0abfbe8c9af4228391.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softsign()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="tanh">Tanh</h3>
<pre><code class="language-py">class torch.nn.Tanh
</code></pre>
<p>将下面的元素级函数应用到输入张量上:</p>
<p><img alt="" src="../img/e3f58d9a8cbc89b247dd8de1c28bf7ce.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Tanh.png" src="../img/5605304fc1fec06669e17cc872d47580.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Tanh()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="tanhshrink">Tanhshrink</h3>
<pre><code class="language-py">class torch.nn.Tanhshrink
</code></pre>
<p>将下面的元素级函数应用到输入张量上:</p>
<p><img alt="" src="../img/136fda10bacf7ae9068ca487ba861805.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p><img alt="https://pytorch.org/docs/stable/_images//Tanhshrink.png" src="../img/8aea39259742ccdb14701a8f3c351b56.jpg" /></p>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Tanhshrink()
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="threshold">Threshold</h3>
<pre><code class="language-py">class torch.nn.Threshold(threshold, value, inplace=False)
</code></pre>
<p>使用阈值过滤输入张量的每个元素</p>
<p>阈值被定义如下：</p>
<p><img alt="" src="../img/3b32031caba73686c02a117e8e307c6f.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>threshold</strong> – 阈值大小 </li>
<li><strong>value</strong> – 小于阈值的元素的替换值</li>
<li><strong>inplace</strong> – 是否进行原位操作。 默认： <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>输入: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> 其中 <code>*</code> 代表支持任意大小的附加维度</li>
<li>输出: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, 与输入向量保持一样的形状大小</li>
</ul>
<p>示例:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Threshold(0.1, 20)
&gt;&gt;&gt; input = torch.randn(2)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="non-linear-activations-other">Non-linear activations (other)</h2>
<h3 id="softmin">Softmin</h3>
<pre><code class="language-py">class torch.nn.Softmin(dim=None)
</code></pre>
<p>Applies the Softmin function to an n-dimensional input Tensor rescaling them so that the elements of the n-dimensional output Tensor lie in the range <code>(0, 1)</code> and sum to 1</p>
<p><img alt="" src="../img/440f43280457a9287bbddf28553f8f70.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: any shape</li>
<li>Output: same as input</li>
</ul>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A dimension along which Softmin will be computed (so every slice along dim will sum to 1).</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a Tensor of the same dimension and shape as the input, with values in the range [0, 1]</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softmin()
&gt;&gt;&gt; input = torch.randn(2, 3)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softmax">Softmax</h3>
<pre><code class="language-py">class torch.nn.Softmax(dim=None)
</code></pre>
<p>Applies the Softmax function to an n-dimensional input Tensor rescaling them so that the elements of the n-dimensional output Tensor lie in the range (0,1) and sum to 1</p>
<p>Softmax is defined as:</p>
<p><img alt="" src="../img/cbfd37534eccdda606d4f8494c31d2c0.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: any shape</li>
<li>Output: same as input</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a Tensor of the same dimension and shape as the input with values in the range [0, 1]</th>
</tr>
</thead>
<tbody>
<tr>
<td>Parameters:</td>
<td><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A dimension along which Softmax will be computed (so every slice along dim will sum to 1).</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Note</p>
<p>This module doesn't work directly with NLLLoss, which expects the Log to be computed between the Softmax and itself. Use <code>LogSoftmax</code> instead (it's faster and has better numerical properties).</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softmax()
&gt;&gt;&gt; input = torch.randn(2, 3)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="softmax2d">Softmax2d</h3>
<pre><code class="language-py">class torch.nn.Softmax2d
</code></pre>
<p>Applies SoftMax over features to each spatial location.</p>
<p>When given an image of <code>Channels x Height x Width</code>, it will apply <code>Softmax</code> to each location <img alt="" src="../img/b16a2a186bda385e5f0016f5fe5a5c36.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /></li>
<li>Output: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /> (same shape as input)</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a Tensor of the same dimension and shape as the input with values in the range [0, 1]</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Softmax2d()
&gt;&gt;&gt; # you softmax over the 2nd dimension
&gt;&gt;&gt; input = torch.randn(2, 3, 12, 13)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="logsoftmax">LogSoftmax</h3>
<pre><code class="language-py">class torch.nn.LogSoftmax(dim=None)
</code></pre>
<p>Applies the <img alt="" src="../img/db163ba416e1349a426e6a137e082ae2.jpg" /> function to an n-dimensional input Tensor. The LogSoftmax formulation can be simplified as:</p>
<p><img alt="" src="../img/397c4cfa2f291306d481811192d2d5d9.jpg" /></p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: any shape</li>
<li>Output: same as input</li>
</ul>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – A dimension along which Softmax will be computed (so every slice along dim will sum to 1).</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a Tensor of the same dimension and shape as the input with values in the range [-inf, 0)</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; input = torch.randn(2, 3)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="adaptivelogsoftmaxwithloss">AdaptiveLogSoftmaxWithLoss</h3>
<pre><code class="language-py">class torch.nn.AdaptiveLogSoftmaxWithLoss(in_features, n_classes, cutoffs, div_value=4.0, head_bias=False)
</code></pre>
<p>Efficient softmax approximation as described in <a href="https://arxiv.org/abs/1609.04309">Efficient softmax approximation for GPUs</a> by Edouard Grave, Armand Joulin, Moustapha Cissé, David Grangier, and Hervé Jégou.</p>
<p>Adaptive softmax is an approximate strategy for training models with large output spaces. It is most effective when the label distribution is highly imbalanced, for example in natural language modelling, where the word frequency distribution approximately follows the <a href="https://en.wikipedia.org/wiki/Zipf%27s_law">Zipf's law</a>.</p>
<p>Adaptive softmax partitions the labels into several clusters, according to their frequency. These clusters may contain different number of targets each. Additionally, clusters containing less frequent labels assign lower dimensional embeddings to those labels, which speeds up the computation. For each minibatch, only clusters for which at least one target is present are evaluated.</p>
<p>The idea is that the clusters which are accessed frequently (like the first one, containing most frequent labels), should also be cheap to compute – that is, contain a small number of assigned labels.</p>
<p>We highly recommend taking a look at the original paper for more details.</p>
<ul>
<li><code>cutoffs</code> should be an ordered Sequence of integers sorted in the increasing order. It controls number of clusters and the partitioning of targets into clusters. For example setting <code>cutoffs = [10, 100, 1000]</code> means that first <code>10</code> targets will be assigned to the 'head' of the adaptive softmax, targets <code>11, 12, …, 100</code> will be assigned to the first cluster, and targets <code>101, 102, …, 1000</code> will be assigned to the second cluster, while targets <code>1001, 1002, …, n_classes - 1</code> will be assigned to the last, third cluster</li>
<li><code>div_value</code> is used to compute the size of each additional cluster, which is given as <img alt="" src="../img/32071c42affaaf731df4e3398b16de10.jpg" />, where <img alt="" src="../img/5df73ea97de3a7712b50ce2fecfea1a7.jpg" /> is the cluster index (with clusters for less frequent words having larger indices, and indices starting from <img alt="" src="../img/a3ea24a1f2a3549d3e5b0cacf3ecb7c7.jpg" />).</li>
<li><code>head_bias</code> if set to True, adds a bias term to the 'head' of the adaptive softmax. See paper for details. Set to False in the official implementation.</li>
</ul>
<p>Warning</p>
<p>Labels passed as inputs to this module should be sorted accoridng to their frequency. This means that the most frequent label should be represented by the index <code>0</code>, and the least frequent label should be represented by the index <code>n_classes - 1</code>.</p>
<p>Note</p>
<p>This module returns a <code>NamedTuple</code> with <code>output</code> and <code>loss</code> fields. See further documentation for details.</p>
<p>Note</p>
<p>To compute log-probabilities for all classes, the <code>log_prob</code> method can be used.</p>
<p>Parameters: </p>
<ul>
<li><strong>in_features</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of features in the input tensor</li>
<li><strong>n_classes</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – Number of classes in the dataset.</li>
<li><strong>cutoffs</strong> (<em>Sequence</em>) – Cutoffs used to assign targets to their buckets.</li>
<li><strong>div_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – value used as an exponent to compute sizes of the clusters. Default: 4.0</li>
</ul>
<p>| Returns: | </p>
<ul>
<li><strong>output</strong> is a Tensor of size <code>N</code> containing computed target log probabilities for each example</li>
<li><strong>loss</strong> is a Scalar representing the computed negative log likelihood loss</li>
</ul>
<table>
<thead>
<tr>
<th>Return type:</th>
<th><code>NamedTuple</code> with <code>output</code> and <code>loss</code> fields</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>input: <img alt="" src="../img/768be7688f5f58f4766106ddb821b007.jpg" /></li>
<li>target: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" /> where each value satisfies <img alt="" src="../img/fe1e80e9faca308456bc49d4e79013e0.jpg" /></li>
<li>output: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" /></li>
<li>loss: <code>Scalar</code></li>
</ul>
<pre><code class="language-py">log_prob(input)
</code></pre>
<p>Computes log probabilities for all <img alt="" src="../img/b285cfddea560d447d391e9d7ba660ba.jpg" /></p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – a minibatch of examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>log-probabilities of for each class <img alt="" src="../img/32624581da7de65d68eb11d4201f9bef.jpg" /> in range <img alt="" src="../img/4e4201057f969a42a8d2de89e5f7c728.jpg" />, where <img alt="" src="../img/b285cfddea560d447d391e9d7ba660ba.jpg" /> is a parameter passed to <code>AdaptiveLogSoftmaxWithLoss</code> constructor.</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/768be7688f5f58f4766106ddb821b007.jpg" /></li>
<li>Output: <img alt="" src="../img/f3bcbc1689556ad810d1c658d44bd970.jpg" /></li>
</ul>
<pre><code class="language-py">predict(input)
</code></pre>
<p>This is equivalent to <code>self.log_pob(input).argmax(dim=1)</code>, but is more efficient in some cases.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – a minibatch of examples</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a class with the highest probability for each example</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
<tr>
<td>Return type:</td>
<td>output (<a href="tensors.html#torch.Tensor" title="torch.Tensor">Tensor</a>)</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/768be7688f5f58f4766106ddb821b007.jpg" /></li>
<li>Output: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" /></li>
</ul>
<h2 id="normalization-layers">Normalization layers</h2>
<h3 id="batchnorm1d">BatchNorm1d</h3>
<pre><code class="language-py">class torch.nn.BatchNorm1d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
</code></pre>
<p>Applies Batch Normalization over a 2D or 3D input (a mini-batch of 1D inputs with optional additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a> .</p>
<p><img alt="" src="../img/beea63da4eceb7d4c8971e826bafbb1a.jpg" /></p>
<p>The mean and standard-deviation are calculated per-dimension over the mini-batches and <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size). By default, the elements of <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> are sampled from <img alt="" src="../img/7ad9c99a642c915c6d560cbca6352454.jpg" /> and the elements of <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are set to 0.</p>
<p>Also by default, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>If <code>track_running_stats</code> is set to <code>False</code>, this layer then does not keep running estimates, and batch statistics are instead used during evaluation time as well.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <img alt="" src="../img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" />, where <img alt="" src="../img/9d834e987d38585c39d150fe8f46bc74.jpg" /> is the estimated statistic and <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the new observed value.</p>
<p>Because the Batch Normalization is done over the <code>C</code> dimension, computing statistics on <code>(N, L)</code> slices, it's common terminology to call this Temporal Batch Normalization.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_features</strong> – <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> from an expected input of size <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /> or <img alt="" src="../img/db4a9fef02111450bf98261889de550c.jpg" /> from input of size <img alt="" src="../img/b6d0ccc6531c5d648e750c417c5cc72d.jpg" /></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Can be set to <code>None</code> for cumulative moving average (i.e. simple average). Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters. Default: <code>True</code></li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" /> or <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /></li>
<li>Output: <img alt="" src="../img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" /> or <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm1d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm1d(100, affine=False)
&gt;&gt;&gt; input = torch.randn(20, 100)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="batchnorm2d">BatchNorm2d</h3>
<pre><code class="language-py">class torch.nn.BatchNorm2d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
</code></pre>
<p>Applies Batch Normalization over a 4D input (a mini-batch of 2D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a> .</p>
<p><img alt="" src="../img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" /></p>
<p>The mean and standard-deviation are calculated per-dimension over the mini-batches and <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size). By default, the elements of <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> are sampled from <img alt="" src="../img/7ad9c99a642c915c6d560cbca6352454.jpg" /> and the elements of <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are set to 0.</p>
<p>Also by default, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>If <code>track_running_stats</code> is set to <code>False</code>, this layer then does not keep running estimates, and batch statistics are instead used during evaluation time as well.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <img alt="" src="../img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" />, where <img alt="" src="../img/9d834e987d38585c39d150fe8f46bc74.jpg" /> is the estimated statistic and <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the new observed value.</p>
<p>Because the Batch Normalization is done over the <code>C</code> dimension, computing statistics on <code>(N, H, W)</code> slices, it's common terminology to call this Spatial Batch Normalization.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_features</strong> – <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> from an expected input of size <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Can be set to <code>None</code> for cumulative moving average (i.e. simple average). Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters. Default: <code>True</code></li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /></li>
<li>Output: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm2d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm2d(100, affine=False)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="batchnorm3d">BatchNorm3d</h3>
<pre><code class="language-py">class torch.nn.BatchNorm3d(num_features, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)
</code></pre>
<p>Applies Batch Normalization over a 5D input (a mini-batch of 3D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1502.03167">Batch Normalization: Accelerating Deep Network Training by Reducing Internal Covariate Shift</a> .</p>
<p><img alt="" src="../img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" /></p>
<p>The mean and standard-deviation are calculated per-dimension over the mini-batches and <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size). By default, the elements of <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> are sampled from <img alt="" src="../img/7ad9c99a642c915c6d560cbca6352454.jpg" /> and the elements of <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are set to 0.</p>
<p>Also by default, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>If <code>track_running_stats</code> is set to <code>False</code>, this layer then does not keep running estimates, and batch statistics are instead used during evaluation time as well.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <img alt="" src="../img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" />, where <img alt="" src="../img/9d834e987d38585c39d150fe8f46bc74.jpg" /> is the estimated statistic and <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the new observed value.</p>
<p>Because the Batch Normalization is done over the <code>C</code> dimension, computing statistics on <code>(N, D, H, W)</code> slices, it's common terminology to call this Volumetric Batch Normalization or Spatio-temporal Batch Normalization.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_features</strong> – <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> from an expected input of size <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Can be set to <code>None</code> for cumulative moving average (i.e. simple average). Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters. Default: <code>True</code></li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /></li>
<li>Output: <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm3d(100)
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.BatchNorm3d(100, affine=False)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45, 10)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="groupnorm">GroupNorm</h3>
<pre><code class="language-py">class torch.nn.GroupNorm(num_groups, num_channels, eps=1e-05, affine=True)
</code></pre>
<p>Applies Group Normalization over a mini-batch of inputs as described in the paper <a href="https://arxiv.org/abs/1803.08494">Group Normalization</a> .</p>
<p><img alt="" src="../img/2fee766f06767b7b87b3531029d92e1d.jpg" /></p>
<p>The input channels are separated into <code>num_groups</code> groups, each containing <code>num_channels / num_groups</code> channels. The mean and standard-deviation are calculated separately over the each group. <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable per-channel affine transform parameter vectorss of size <code>num_channels</code> if <code>affine</code> is <code>True</code>.</p>
<p>This layer uses statistics computed from input data in both training and evaluation modes.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_groups</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of groups to separate the channels into</li>
<li><strong>num_channels</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – number of channels expected in input</li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable per-channel affine parameters initialized to ones (for weights) and zeros (for biases). Default: <code>True</code>.</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/f5be296779e9f325e5c8f0c2284bc073.jpg" /></li>
<li>Output: <img alt="" src="../img/f5be296779e9f325e5c8f0c2284bc073.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.randn(20, 6, 10, 10)
&gt;&gt;&gt; # Separate 6 channels into 3 groups
&gt;&gt;&gt; m = nn.GroupNorm(3, 6)
&gt;&gt;&gt; # Separate 6 channels into 6 groups (equivalent with InstanceNorm)
&gt;&gt;&gt; m = nn.GroupNorm(6, 6)
&gt;&gt;&gt; # Put all 6 channels into a single group (equivalent with LayerNorm)
&gt;&gt;&gt; m = nn.GroupNorm(1, 6)
&gt;&gt;&gt; # Activating the module
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="instancenorm1d">InstanceNorm1d</h3>
<pre><code class="language-py">class torch.nn.InstanceNorm1d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
</code></pre>
<p>Applies Instance Normalization over a 2D or 3D input (a mini-batch of 1D inputs with optional additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1607.08022">Instance Normalization: The Missing Ingredient for Fast Stylization</a> .</p>
<p><img alt="" src="../img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" /></p>
<p>The mean and standard-deviation are calculated per-dimension separately for each object in a mini-batch. <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size) if <code>affine</code> is <code>True</code>.</p>
<p>By default, this layer uses instance statistics computed from input data in both training and evaluation modes.</p>
<p>If <code>track_running_stats</code> is set to <code>True</code>, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <img alt="" src="../img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" />, where <img alt="" src="../img/9d834e987d38585c39d150fe8f46bc74.jpg" /> is the estimated statistic and <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the new observed value.</p>
<p>Note</p>
<p><a href="#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a> and <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> are very similar, but have some subtle differences. <a href="#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a> is applied on each channel of channeled data like multidimensional time series, but <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> is usually applied on entire sample and often in NLP tasks. Additionaly, <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> applies elementwise affine transform, while <a href="#torch.nn.InstanceNorm1d" title="torch.nn.InstanceNorm1d"><code>InstanceNorm1d</code></a> usually don't apply affine transform.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_features</strong> – <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> from an expected input of size <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /> or <img alt="" src="../img/db4a9fef02111450bf98261889de550c.jpg" /> from input of size <img alt="" src="../img/b6d0ccc6531c5d648e750c417c5cc72d.jpg" /></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /></li>
<li>Output: <img alt="" src="../img/5816e96aa78b7425cf792435bba8bc29.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm1d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm1d(100, affine=True)
&gt;&gt;&gt; input = torch.randn(20, 100, 40)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="instancenorm2d">InstanceNorm2d</h3>
<pre><code class="language-py">class torch.nn.InstanceNorm2d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
</code></pre>
<p>Applies Instance Normalization over a 4D input (a mini-batch of 2D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1607.08022">Instance Normalization: The Missing Ingredient for Fast Stylization</a> .</p>
<p><img alt="" src="../img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" /></p>
<p>The mean and standard-deviation are calculated per-dimension separately for each object in a mini-batch. <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable parameter vectors of size <code>C</code> (where <code>C</code> is the input size) if <code>affine</code> is <code>True</code>.</p>
<p>By default, this layer uses instance statistics computed from input data in both training and evaluation modes.</p>
<p>If <code>track_running_stats</code> is set to <code>True</code>, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <img alt="" src="../img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" />, where <img alt="" src="../img/9d834e987d38585c39d150fe8f46bc74.jpg" /> is the estimated statistic and <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the new observed value.</p>
<p>Note</p>
<p><a href="#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a> and <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> are very similar, but have some subtle differences. <a href="#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a> is applied on each channel of channeled data like RGB images, but <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> is usually applied on entire sample and often in NLP tasks. Additionaly, <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> applies elementwise affine transform, while <a href="#torch.nn.InstanceNorm2d" title="torch.nn.InstanceNorm2d"><code>InstanceNorm2d</code></a> usually don't apply affine transform.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_features</strong> – <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> from an expected input of size <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /></li>
<li>Output: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm2d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm2d(100, affine=True)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="instancenorm3d">InstanceNorm3d</h3>
<pre><code class="language-py">class torch.nn.InstanceNorm3d(num_features, eps=1e-05, momentum=0.1, affine=False, track_running_stats=False)
</code></pre>
<p>Applies Instance Normalization over a 5D input (a mini-batch of 3D inputs with additional channel dimension) as described in the paper <a href="https://arxiv.org/abs/1607.08022">Instance Normalization: The Missing Ingredient for Fast Stylization</a> .</p>
<p><img alt="" src="../img/63ee6938c8dea3b7cc66a2a245b15cfc.jpg" /></p>
<p>The mean and standard-deviation are calculated per-dimension separately for each object in a mini-batch. <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable parameter vectors of size C (where C is the input size) if <code>affine</code> is <code>True</code>.</p>
<p>By default, this layer uses instance statistics computed from input data in both training and evaluation modes.</p>
<p>If <code>track_running_stats</code> is set to <code>True</code>, during training this layer keeps running estimates of its computed mean and variance, which are then used for normalization during evaluation. The running estimates are kept with a default <code>momentum</code> of 0.1.</p>
<p>Note</p>
<p>This <code>momentum</code> argument is different from one used in optimizer classes and the conventional notion of momentum. Mathematically, the update rule for running statistics here is <img alt="" src="../img/05beed2a6202dfed2f2c4d1ddf9f445f.jpg" />, where <img alt="" src="../img/9d834e987d38585c39d150fe8f46bc74.jpg" /> is the estimated statistic and <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the new observed value.</p>
<p>Note</p>
<p><a href="#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a> and <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> are very similar, but have some subtle differences. <a href="#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a> is applied on each channel of channeled data like 3D models with RGB color, but <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> is usually applied on entire sample and often in NLP tasks. Additionaly, <a href="#torch.nn.LayerNorm" title="torch.nn.LayerNorm"><code>LayerNorm</code></a> applies elementwise affine transform, while <a href="#torch.nn.InstanceNorm3d" title="torch.nn.InstanceNorm3d"><code>InstanceNorm3d</code></a> usually don't apply affine transform.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_features</strong> – <img alt="" src="../img/6c8feca3b2da3d6cf371417edff4be4f.jpg" /> from an expected input of size <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /></li>
<li><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</li>
<li><strong>momentum</strong> – the value used for the running_mean and running_var computation. Default: 0.1</li>
<li><strong>affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable affine parameters, initialized the same way as done for batch normalization. Default: <code>False</code>.</li>
<li><strong>track_running_stats</strong> – a boolean value that when set to <code>True</code>, this module tracks the running mean and variance, and when set to <code>False</code>, this module does not track such statistics and always uses batch statistics in both training and eval modes. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /></li>
<li>Output: <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm3d(100)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.InstanceNorm3d(100, affine=True)
&gt;&gt;&gt; input = torch.randn(20, 100, 35, 45, 10)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="layernorm">LayerNorm</h3>
<pre><code class="language-py">class torch.nn.LayerNorm(normalized_shape, eps=1e-05, elementwise_affine=True)
</code></pre>
<p>Applies Layer Normalization over a mini-batch of inputs as described in the paper <a href="https://arxiv.org/abs/1607.06450">Layer Normalization</a> .</p>
<p><img alt="" src="../img/2fee766f06767b7b87b3531029d92e1d.jpg" /></p>
<p>The mean and standard-deviation are calculated separately over the last certain number dimensions which have to be of the shape specified by <code>normalized_shape</code>. <img alt="" src="../img/cdab9437b701fd21fb3294cfba7c4bc2.jpg" /> and <img alt="" src="../img/50705df736e9a7919e768cf8c4e4f794.jpg" /> are learnable affine transform parameters of <code>normalized_shape</code> if <code>elementwise_affine</code> is <code>True</code>.</p>
<p>Note</p>
<p>Unlike Batch Normalization and Instance Normalization, which applies scalar scale and bias for each entire channel/plane with the <code>affine</code> option, Layer Normalization applies per-element scale and bias with <code>elementwise_affine</code>.</p>
<p>This layer uses statistics computed from input data in both training and evaluation modes.</p>
<p>Parameters: </p>
<ul>
<li>
<p><strong>normalized_shape</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a> <em>or</em> <em>torch.Size</em>) –</p>
<p>input shape from an expected input of size</p>
<p><img alt="" src="../img/7058ab5ae52adb329c22fa5456ad910f.jpg" /></p>
<p>If a single integer is used, it is treated as a singleton list, and this module will normalize over the last dimension which is expected to be of that specific size.</p>
</li>
<li>
<p><strong>eps</strong> – a value added to the denominator for numerical stability. Default: 1e-5</p>
</li>
<li><strong>elementwise_affine</strong> – a boolean value that when set to <code>True</code>, this module has learnable per-element affine parameters initialized to ones (for weights) and zeros (for biases). Default: <code>True</code>.</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /></li>
<li>Output: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.randn(20, 5, 10, 10)
&gt;&gt;&gt; # With Learnable Parameters
&gt;&gt;&gt; m = nn.LayerNorm(input.size()[1:])
&gt;&gt;&gt; # Without Learnable Parameters
&gt;&gt;&gt; m = nn.LayerNorm(input.size()[1:], elementwise_affine=False)
&gt;&gt;&gt; # Normalize over last two dimensions
&gt;&gt;&gt; m = nn.LayerNorm([10, 10])
&gt;&gt;&gt; # Normalize over last dimension of size 10
&gt;&gt;&gt; m = nn.LayerNorm(10)
&gt;&gt;&gt; # Activating the module
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="localresponsenorm">LocalResponseNorm</h3>
<pre><code class="language-py">class torch.nn.LocalResponseNorm(size, alpha=0.0001, beta=0.75, k=1.0)
</code></pre>
<p>Applies local response normalization over an input signal composed of several input planes, where channels occupy the second dimension. Applies normalization across channels.</p>
<p><img alt="" src="../img/5522547c6e594dc7c5ffe998f57ad26b.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>size</strong> – amount of neighbouring channels used for normalization</li>
<li><strong>alpha</strong> – multiplicative factor. Default: 0.0001</li>
<li><strong>beta</strong> – exponent. Default: 0.75</li>
<li><strong>k</strong> – additive factor. Default: 1</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/0113f670591e6e2a1a50722e1affdce5.jpg" /></li>
<li>Output: <img alt="" src="../img/0113f670591e6e2a1a50722e1affdce5.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; lrn = nn.LocalResponseNorm(2)
&gt;&gt;&gt; signal_2d = torch.randn(32, 5, 24, 24)
&gt;&gt;&gt; signal_4d = torch.randn(16, 5, 7, 7, 7, 7)
&gt;&gt;&gt; output_2d = lrn(signal_2d)
&gt;&gt;&gt; output_4d = lrn(signal_4d)

</code></pre>
<h2 id="recurrent-layers">Recurrent layers</h2>
<h3 id="rnn">RNN</h3>
<pre><code class="language-py">class torch.nn.RNN(*args, **kwargs)
</code></pre>
<p>Applies a multi-layer Elman RNN with <img alt="" src="../img/73b754b4f63e76c0f0327be51d4b263c.jpg" /> or <img alt="" src="../img/86a6387f3ec09e33de3faaa24f784bca.jpg" /> non-linearity to an input sequence.</p>
<p>For each element in the input sequence, each layer computes the following function:</p>
<p><img alt="" src="../img/1d1bd72124738a26685d33ce01c89beb.jpg" /></p>
<p>where <img alt="" src="../img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" /> is the hidden state at time <code>t</code>, <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the input at time <code>t</code>, and <img alt="" src="../img/722edd552cee200694a3bfccd4f755df.jpg" /> is the hidden state of the previous layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>. If <code>nonlinearity</code> is <code>'relu'</code>, then <code>ReLU</code> is used instead of <code>tanh</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two RNNs together to form a <code>stacked RNN</code>, with the second RNN taking in outputs of the first RNN and computing the final results. Default: 1</li>
<li><strong>nonlinearity</strong> – The non-linearity to use. Can be either 'tanh' or 'relu'. Default: 'tanh'</li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as <code>(batch, seq, feature)</code>. Default: <code>False</code></li>
<li><strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each RNN layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li>
<li><strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional RNN. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Inputs: input, h_0
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(seq_len, batch, input_size)</code>: tensor containing the features of the input sequence. The input can also be a packed variable length sequence. See <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> or <a href="#torch.nn.utils.rnn.pack_sequence" title="torch.nn.utils.rnn.pack_sequence"><code>torch.nn.utils.rnn.pack_sequence()</code></a> for details.</li>
<li><strong>h_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</li>
</ul>
<pre><code class="language-py">Outputs: output, h_n
</code></pre>
<ul>
<li>
<p><strong>output</strong> of shape <code>(seq_len, batch, num_directions * hidden_size)</code>: tensor containing the output features (<code>h_k</code>) from the last layer of the RNN, for each <code>k</code>. If a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence.</p>
<p>For the unpacked case, the directions can be separated using <code>output.view(seq_len, batch, num_directions, hidden_size)</code>, with forward and backward being direction <code>0</code> and <code>1</code> respectively. Similarly, the directions can be separated in the packed case.</p>
</li>
<li>
<p><strong>h_n</strong> (num_layers * num_directions, batch, hidden_size): tensor containing the hidden state for <code>k = seq_len</code>.</p>
<p>Like <em>output</em>, the layers can be separated using <code>h_n.view(num_layers, num_directions, batch, hidden_size)</code>.</p>
</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the k-th layer, of shape <code>(hidden_size * input_size)</code> for <code>k = 0</code>. Otherwise, the shape is <code>(hidden_size * hidden_size)</code></li>
<li><strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the k-th layer, of shape <code>(hidden_size * hidden_size)</code></li>
<li><strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the k-th layer, of shape <code>(hidden_size)</code></li>
<li><strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the k-th layer, of shape <code>(hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" /></p>
<p>Note</p>
<p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.RNN(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, hn = rnn(input, h0)

</code></pre>
<h3 id="lstm">LSTM</h3>
<pre><code class="language-py">class torch.nn.LSTM(*args, **kwargs)
</code></pre>
<p>Applies a multi-layer long short-term memory (LSTM) RNN to an input sequence.</p>
<p>For each element in the input sequence, each layer computes the following function:</p>
<p><img alt="" src="../img/e45b4c4446dc36020077ab726cee248f.jpg" /></p>
<p>where <img alt="" src="../img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" /> is the hidden state at time <code>t</code>, <img alt="" src="../img/a96fd1792ebb964c44e6a4802fe73a45.jpg" /> is the cell state at time <code>t</code>, <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the input at time <code>t</code>, <img alt="" src="../img/722edd552cee200694a3bfccd4f755df.jpg" /> is the hidden state of the layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>, and <img alt="" src="../img/0c33b098890c73bacbf2dbe5476b8ea0.jpg" />, <img alt="" src="../img/39e0c3cfa9742216d02b21de5ed57650.jpg" />, <img alt="" src="../img/2fe3fba6f09d597fd2b3cd6a1e0b4547.jpg" />, <img alt="" src="../img/8b4c3e8be7da971e832789294ddd61d4.jpg" /> are the input, forget, cell, and output gates, respectively. <img alt="" src="../img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" /> is the sigmoid function.</p>
<p>In a multilayer LSTM, the input <img alt="" src="../img/3aef28832238eb9de1c3d226cc4f026e.jpg" /> of the <img alt="" src="../img/4c55f62a52ee5572ab96494e9e0a2876.jpg" /> -th layer (<img alt="" src="../img/c2c7ccc0042019ca7a1bb7d536da8a87.jpg" />) is the hidden state <img alt="" src="../img/aa2a9f5361143e6f3a32d54920079b52.jpg" /> of the previous layer multiplied by dropout <img alt="" src="../img/5e5fffda0db50ff1fedeef29921cdf85.jpg" /> where each <img alt="" src="../img/5b70351b42153bea8ab63d8e783cc0ac.jpg" /> is a Bernoulli random variable which is <img alt="" src="../img/28256dd5af833c877d63bfabfaa7b301.jpg" /> with probability <code>dropout</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two LSTMs together to form a <code>stacked LSTM</code>, with the second LSTM taking in outputs of the first LSTM and computing the final results. Default: 1</li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as (batch, seq, feature). Default: <code>False</code></li>
<li><strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each LSTM layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li>
<li><strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional LSTM. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Inputs: input, (h_0, c_0)
</code></pre>
<ul>
<li>
<p><strong>input</strong> of shape <code>(seq_len, batch, input_size)</code>: tensor containing the features of the input sequence. The input can also be a packed variable length sequence. See <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> or <a href="#torch.nn.utils.rnn.pack_sequence" title="torch.nn.utils.rnn.pack_sequence"><code>torch.nn.utils.rnn.pack_sequence()</code></a> for details.</p>
</li>
<li>
<p><strong>h_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</p>
</li>
<li>
<p><strong>c_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial cell state for each element in the batch.</p>
<p>If <code>(h_0, c_0)</code> is not provided, both <strong>h_0</strong> and <strong>c_0</strong> default to zero.</p>
</li>
</ul>
<pre><code class="language-py">Outputs: output, (h_n, c_n)
</code></pre>
<ul>
<li>
<p><strong>output</strong> of shape <code>(seq_len, batch, num_directions * hidden_size)</code>: tensor containing the output features <code>(h_t)</code> from the last layer of the LSTM, for each t. If a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence.</p>
<p>For the unpacked case, the directions can be separated using <code>output.view(seq_len, batch, num_directions, hidden_size)</code>, with forward and backward being direction <code>0</code> and <code>1</code> respectively. Similarly, the directions can be separated in the packed case.</p>
</li>
<li>
<p><strong>h_n</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the hidden state for <code>t = seq_len</code>.</p>
<p>Like <em>output</em>, the layers can be separated using <code>h_n.view(num_layers, num_directions, batch, hidden_size)</code> and similarly for <em>c_n</em>.</p>
</li>
<li>
<p><strong>c_n</strong> (num_layers * num_directions, batch, hidden_size): tensor containing the cell state for <code>t = seq_len</code></p>
</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer <code>(W_ii&amp;#124;W_if&amp;#124;W_ig&amp;#124;W_io)</code>, of shape <code>(4*hidden_size x input_size)</code></li>
<li><strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer <code>(W_hi&amp;#124;W_hf&amp;#124;W_hg&amp;#124;W_ho)</code>, of shape <code>(4*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer <code>(b_ii&amp;#124;b_if&amp;#124;b_ig&amp;#124;b_io)</code>, of shape <code>(4*hidden_size)</code></li>
<li><strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer <code>(b_hi&amp;#124;b_hf&amp;#124;b_hg&amp;#124;b_ho)</code>, of shape <code>(4*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" /></p>
<p>Note</p>
<p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.LSTM(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; c0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, (hn, cn) = rnn(input, (h0, c0))

</code></pre>
<h3 id="gru">GRU</h3>
<pre><code class="language-py">class torch.nn.GRU(*args, **kwargs)
</code></pre>
<p>Applies a multi-layer gated recurrent unit (GRU) RNN to an input sequence.</p>
<p>For each element in the input sequence, each layer computes the following function:</p>
<p><img alt="" src="../img/76771dd2e48bad7097dc9524356200ef.jpg" /></p>
<p>where <img alt="" src="../img/a048a5bfcc0242b6427d15ed11ef7e23.jpg" /> is the hidden state at time <code>t</code>, <img alt="" src="../img/22c5ed7653e3fae804006a00210327fc.jpg" /> is the input at time <code>t</code>, <img alt="" src="../img/722edd552cee200694a3bfccd4f755df.jpg" /> is the hidden state of the layer at time <code>t-1</code> or the initial hidden state at time <code>0</code>, and <img alt="" src="../img/33becaceee3dd4f30f106b6a8605226f.jpg" />, <img alt="" src="../img/98ba4bd98c899c9f15a00fe76fe782b2.jpg" />, <img alt="" src="../img/4d63033e7717e68b17fc937ffcbcde4b.jpg" /> are the reset, update, and new gates, respectively. <img alt="" src="../img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" /> is the sigmoid function.</p>
<p>In a multilayer GRU, the input <img alt="" src="../img/3aef28832238eb9de1c3d226cc4f026e.jpg" /> of the <img alt="" src="../img/4c55f62a52ee5572ab96494e9e0a2876.jpg" /> -th layer (<img alt="" src="../img/c2c7ccc0042019ca7a1bb7d536da8a87.jpg" />) is the hidden state <img alt="" src="../img/aa2a9f5361143e6f3a32d54920079b52.jpg" /> of the previous layer multiplied by dropout <img alt="" src="../img/5e5fffda0db50ff1fedeef29921cdf85.jpg" /> where each <img alt="" src="../img/5b70351b42153bea8ab63d8e783cc0ac.jpg" /> is a Bernoulli random variable which is <img alt="" src="../img/28256dd5af833c877d63bfabfaa7b301.jpg" /> with probability <code>dropout</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>num_layers</strong> – Number of recurrent layers. E.g., setting <code>num_layers=2</code> would mean stacking two GRUs together to form a <code>stacked GRU</code>, with the second GRU taking in outputs of the first GRU and computing the final results. Default: 1</li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>batch_first</strong> – If <code>True</code>, then the input and output tensors are provided as (batch, seq, feature). Default: <code>False</code></li>
<li><strong>dropout</strong> – If non-zero, introduces a <code>Dropout</code> layer on the outputs of each GRU layer except the last layer, with dropout probability equal to <code>dropout</code>. Default: 0</li>
<li><strong>bidirectional</strong> – If <code>True</code>, becomes a bidirectional GRU. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Inputs: input, h_0
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(seq_len, batch, input_size)</code>: tensor containing the features of the input sequence. The input can also be a packed variable length sequence. See <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>torch.nn.utils.rnn.pack_padded_sequence()</code></a> for details.</li>
<li><strong>h_0</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided. If the RNN is bidirectional, num_directions should be 2, else it should be 1.</li>
</ul>
<pre><code class="language-py">Outputs: output, h_n
</code></pre>
<ul>
<li>
<p><strong>output</strong> of shape <code>(seq_len, batch, num_directions * hidden_size)</code>: tensor containing the output features h_t from the last layer of the GRU, for each t. If a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>torch.nn.utils.rnn.PackedSequence</code></a> has been given as the input, the output will also be a packed sequence. For the unpacked case, the directions can be separated using <code>output.view(seq_len, batch, num_directions, hidden_size)</code>, with forward and backward being direction <code>0</code> and <code>1</code> respectively.</p>
<p>Similarly, the directions can be separated in the packed case.</p>
</li>
<li>
<p><strong>h_n</strong> of shape <code>(num_layers * num_directions, batch, hidden_size)</code>: tensor containing the hidden state for <code>t = seq_len</code></p>
<p>Like <em>output</em>, the layers can be separated using <code>h_n.view(num_layers, num_directions, batch, hidden_size)</code>.</p>
</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih_l[k]</strong> – the learnable input-hidden weights of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer (W_ir&#124;W_iz&#124;W_in), of shape <code>(3*hidden_size x input_size)</code></li>
<li><strong>weight_hh_l[k]</strong> – the learnable hidden-hidden weights of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer (W_hr&#124;W_hz&#124;W_hn), of shape <code>(3*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih_l[k]</strong> – the learnable input-hidden bias of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer (b_ir&#124;b_iz&#124;b_in), of shape <code>(3*hidden_size)</code></li>
<li><strong>bias_hh_l[k]</strong> – the learnable hidden-hidden bias of the <img alt="" src="../img/3daedae8ea4977a42453935c04c06ad0.jpg" /> layer (b_hr&#124;b_hz&#124;b_hn), of shape <code>(3*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" /></p>
<p>Note</p>
<p>If the following conditions are satisfied: 1) cudnn is enabled, 2) input data is on the GPU 3) input data has dtype <code>torch.float16</code> 4) V100 GPU is used, 5) input data is not in <code>PackedSequence</code> format persistent algorithm can be selected to improve performance.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.GRU(10, 20, 2)
&gt;&gt;&gt; input = torch.randn(5, 3, 10)
&gt;&gt;&gt; h0 = torch.randn(2, 3, 20)
&gt;&gt;&gt; output, hn = rnn(input, h0)

</code></pre>
<h3 id="rnncell">RNNCell</h3>
<pre><code class="language-py">class torch.nn.RNNCell(input_size, hidden_size, bias=True, nonlinearity='tanh')
</code></pre>
<p>An Elman RNN cell with tanh or ReLU non-linearity.</p>
<p><img alt="" src="../img/e748fe354d996221dbfa5f8e3412451e.jpg" /></p>
<p>If <code>nonlinearity</code> is <code>'relu'</code>, then ReLU is used in place of tanh.</p>
<p>Parameters: </p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
<li><strong>nonlinearity</strong> – The non-linearity to use. Can be either 'tanh' or 'relu'. Default: 'tanh'</li>
</ul>
<pre><code class="language-py">Inputs: input, hidden
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(batch, input_size)</code>: tensor containing input features</li>
<li><strong>hidden</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided.</li>
</ul>
<pre><code class="language-py">Outputs: h'
</code></pre>
<ul>
<li><strong>h'</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next hidden state for each element in the batch</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih</strong> – the learnable input-hidden weights, of shape <code>(hidden_size x input_size)</code></li>
<li><strong>weight_hh</strong> – the learnable hidden-hidden weights, of shape <code>(hidden_size x hidden_size)</code></li>
<li><strong>bias_ih</strong> – the learnable input-hidden bias, of shape <code>(hidden_size)</code></li>
<li><strong>bias_hh</strong> – the learnable hidden-hidden bias, of shape <code>(hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" /></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.RNNCell(10, 20)
&gt;&gt;&gt; input = torch.randn(6, 3, 10)
&gt;&gt;&gt; hx = torch.randn(3, 20)
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
 hx = rnn(input[i], hx)
 output.append(hx)

</code></pre>
<h3 id="lstmcell">LSTMCell</h3>
<pre><code class="language-py">class torch.nn.LSTMCell(input_size, hidden_size, bias=True)
</code></pre>
<p>A long short-term memory (LSTM) cell.</p>
<p><img alt="" src="../img/fb4d6ec81b25bb8201fbedd23b71b45f.jpg" /></p>
<p>where <img alt="" src="../img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" /> is the sigmoid function.</p>
<p>Parameters: </p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Inputs: input, (h_0, c_0)
</code></pre>
<ul>
<li>
<p><strong>input</strong> of shape <code>(batch, input_size)</code>: tensor containing input features</p>
</li>
<li>
<p><strong>h_0</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch.</p>
</li>
<li>
<p><strong>c_0</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial cell state for each element in the batch.</p>
<p>If <code>(h_0, c_0)</code> is not provided, both <strong>h_0</strong> and <strong>c_0</strong> default to zero.</p>
</li>
</ul>
<pre><code class="language-py">Outputs: h_1, c_1
</code></pre>
<ul>
<li><strong>h_1</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next hidden state for each element in the batch</li>
<li><strong>c_1</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next cell state for each element in the batch</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih</strong> – the learnable input-hidden weights, of shape <code>(4*hidden_size x input_size)</code></li>
<li><strong>weight_hh</strong> – the learnable hidden-hidden weights, of shape <code>(4*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih</strong> – the learnable input-hidden bias, of shape <code>(4*hidden_size)</code></li>
<li><strong>bias_hh</strong> – the learnable hidden-hidden bias, of shape <code>(4*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" /></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.LSTMCell(10, 20)
&gt;&gt;&gt; input = torch.randn(6, 3, 10)
&gt;&gt;&gt; hx = torch.randn(3, 20)
&gt;&gt;&gt; cx = torch.randn(3, 20)
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
 hx, cx = rnn(input[i], (hx, cx))
 output.append(hx)

</code></pre>
<h3 id="grucell">GRUCell</h3>
<pre><code class="language-py">class torch.nn.GRUCell(input_size, hidden_size, bias=True)
</code></pre>
<p>A gated recurrent unit (GRU) cell</p>
<p><img alt="" src="../img/a557e5b089bda248c2e25791d88d4b2a.jpg" /></p>
<p>where <img alt="" src="../img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" /> is the sigmoid function.</p>
<p>Parameters: </p>
<ul>
<li><strong>input_size</strong> – The number of expected features in the input <code>x</code></li>
<li><strong>hidden_size</strong> – The number of features in the hidden state <code>h</code></li>
<li><strong>bias</strong> – If <code>False</code>, then the layer does not use bias weights <code>b_ih</code> and <code>b_hh</code>. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Inputs: input, hidden
</code></pre>
<ul>
<li><strong>input</strong> of shape <code>(batch, input_size)</code>: tensor containing input features</li>
<li><strong>hidden</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the initial hidden state for each element in the batch. Defaults to zero if not provided.</li>
</ul>
<pre><code class="language-py">Outputs: h'
</code></pre>
<ul>
<li><strong>h'</strong> of shape <code>(batch, hidden_size)</code>: tensor containing the next hidden state for each element in the batch</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight_ih</strong> – the learnable input-hidden weights, of shape <code>(3*hidden_size x input_size)</code></li>
<li><strong>weight_hh</strong> – the learnable hidden-hidden weights, of shape <code>(3*hidden_size x hidden_size)</code></li>
<li><strong>bias_ih</strong> – the learnable input-hidden bias, of shape <code>(3*hidden_size)</code></li>
<li><strong>bias_hh</strong> – the learnable hidden-hidden bias, of shape <code>(3*hidden_size)</code></li>
</ul>
<p>Note</p>
<p>All the weights and biases are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/cb80fd45c1b2dc2b84b2e80eb48d111e.jpg" /></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; rnn = nn.GRUCell(10, 20)
&gt;&gt;&gt; input = torch.randn(6, 3, 10)
&gt;&gt;&gt; hx = torch.randn(3, 20)
&gt;&gt;&gt; output = []
&gt;&gt;&gt; for i in range(6):
 hx = rnn(input[i], hx)
 output.append(hx)

</code></pre>
<h2 id="linear-layers">Linear layers</h2>
<h3 id="linear">Linear</h3>
<pre><code class="language-py">class torch.nn.Linear(in_features, out_features, bias=True)
</code></pre>
<p>Applies a linear transformation to the incoming data: <img alt="" src="../img/8c4834b7cb4b9c7a795bf354412e8dd3.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>in_features</strong> – size of each input sample</li>
<li><strong>out_features</strong> – size of each output sample</li>
<li><strong>bias</strong> – If set to False, the layer will not learn an additive bias. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/37251f14c8c7345b66309c1ce6181e4d.jpg" /> where <img alt="" src="../img/28ec51e742166ea3400be6e7343bbfa5.jpg" /> means any number of additional dimensions</li>
<li>Output: <img alt="" src="../img/052531b4914630967eb9a6ed4f143697.jpg" /> where all but the last dimension are the same shape as the input.</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> – the learnable weights of the module of shape <img alt="" src="../img/7bdd499093e2167451c56eb5c4480786.jpg" />. The values are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />, where <img alt="" src="../img/9d1dd979275f32a1bcc00f4e3885e68c.jpg" /></li>
<li><strong>bias</strong> – the learnable bias of the module of shape <img alt="" src="../img/27eac2d9aa3b57eabe07fcce145717d2.jpg" />. If <code>bias</code> is <code>True</code>, the values are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" /> where <img alt="" src="../img/9d1dd979275f32a1bcc00f4e3885e68c.jpg" /></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Linear(20, 30)
&gt;&gt;&gt; input = torch.randn(128, 20)
&gt;&gt;&gt; output = m(input)
&gt;&gt;&gt; print(output.size())
torch.Size([128, 30])

</code></pre>
<h3 id="bilinear">Bilinear</h3>
<pre><code class="language-py">class torch.nn.Bilinear(in1_features, in2_features, out_features, bias=True)
</code></pre>
<p>Applies a bilinear transformation to the incoming data: <img alt="" src="../img/a0d89d1240ed669c322d042acea66b2c.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>in1_features</strong> – size of each first input sample</li>
<li><strong>in2_features</strong> – size of each second input sample</li>
<li><strong>out_features</strong> – size of each output sample</li>
<li><strong>bias</strong> – If set to False, the layer will not learn an additive bias. Default: <code>True</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/9cf39fb88b1a94018532514fcb3e125c.jpg" />, <img alt="" src="../img/5b3219dff177846f3a5aebdb36ae5d30.jpg" /> where <img alt="" src="../img/28ec51e742166ea3400be6e7343bbfa5.jpg" /> means any number of additional dimensions. All but the last dimension of the inputs should be the same.</li>
<li>Output: <img alt="" src="../img/052531b4914630967eb9a6ed4f143697.jpg" /> where all but the last dimension are the same shape as the input.</li>
</ul>
<p>| Variables: | </p>
<ul>
<li><strong>weight</strong> – the learnable weights of the module of shape <img alt="" src="../img/3f2a47921a3568c8f0f8c45847fd2ad3.jpg" />. The values are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />, where <img alt="" src="../img/76606e23079bb41cbaeb5fa9ddc71c86.jpg" /></li>
<li><strong>bias</strong> – the learnable bias of the module of shape <img alt="" src="../img/27eac2d9aa3b57eabe07fcce145717d2.jpg" /> If <code>bias</code> is <code>True</code>, the values are initialized from <img alt="" src="../img/3d305f1c240ff844b6cb2c1c6660e0af.jpg" />, where <img alt="" src="../img/76606e23079bb41cbaeb5fa9ddc71c86.jpg" /></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Bilinear(20, 30, 40)
&gt;&gt;&gt; input1 = torch.randn(128, 20)
&gt;&gt;&gt; input2 = torch.randn(128, 30)
&gt;&gt;&gt; output = m(input1, input2)
&gt;&gt;&gt; print(output.size())
torch.Size([128, 40])

</code></pre>
<h2 id="dropout-layers">Dropout layers</h2>
<h3 id="dropout">Dropout</h3>
<pre><code class="language-py">class torch.nn.Dropout(p=0.5, inplace=False)
</code></pre>
<p>During training, randomly zeroes some of the elements of the input tensor with probability <code>p</code> using samples from a Bernoulli distribution. Each channel will be zeroed out independently on every forward call.</p>
<p>This has proven to be an effective technique for regularization and preventing the co-adaptation of neurons as described in the paper <a href="https://arxiv.org/abs/1207.0580">Improving neural networks by preventing co-adaptation of feature detectors</a> .</p>
<p>Furthermore, the outputs are scaled by a factor of <img alt="" src="../img/37052da8591fea742432c58ac3a4dc59.jpg" /> during training. This means that during evaluation the module simply computes an identity function.</p>
<p>Parameters: </p>
<ul>
<li><strong>p</strong> – probability of an element to be zeroed. Default: 0.5</li>
<li><strong>inplace</strong> – If set to <code>True</code>, will do this operation in-place. Default: <code>False</code></li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <code>Any</code>. Input can be of any shape</li>
<li>Output: <code>Same</code>. Output is of the same shape as input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Dropout(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="dropout2d">Dropout2d</h3>
<pre><code class="language-py">class torch.nn.Dropout2d(p=0.5, inplace=False)
</code></pre>
<p>Randomly zero out entire channels (a channel is a 2D feature map, e.g., the <img alt="" src="../img/d8fdd0e28cfb03738fc5227885ee035a.jpg" />-th channel of the <img alt="" src="../img/31df9c730e19ca29b59dce64b99d98c1.jpg" />-th sample in the batched input is a 2D tensor <img alt="" src="../img/5bc8fbe2fea3359e55846184c5eb123a.jpg" />) of the input tensor). Each channel will be zeroed out independently on every forward call. with probability <code>p</code> using samples from a Bernoulli distribution.</p>
<p>Usually the input comes from <code>nn.Conv2d</code> modules.</p>
<p>As described in the paper <a href="http://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> , if adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then i.i.d. dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.</p>
<p>In this case, <code>nn.Dropout2d()</code> will help promote independence between feature maps and should be used instead.</p>
<p>Parameters: </p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – probability of an element to be zero-ed.</li>
<li><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If set to <code>True</code>, will do this operation in-place</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /></li>
<li>Output: <img alt="" src="../img/23f8772594b27bd387be708fe9c085e1.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Dropout2d(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16, 32, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="dropout3d">Dropout3d</h3>
<pre><code class="language-py">class torch.nn.Dropout3d(p=0.5, inplace=False)
</code></pre>
<p>Randomly zero out entire channels (a channel is a 3D feature map, e.g., the <img alt="" src="../img/d8fdd0e28cfb03738fc5227885ee035a.jpg" />-th channel of the <img alt="" src="../img/31df9c730e19ca29b59dce64b99d98c1.jpg" />-th sample in the batched input is a 3D tensor <img alt="" src="../img/5bc8fbe2fea3359e55846184c5eb123a.jpg" />) of the input tensor). Each channel will be zeroed out independently on every forward call. with probability <code>p</code> using samples from a Bernoulli distribution.</p>
<p>Usually the input comes from <code>nn.Conv3d</code> modules.</p>
<p>As described in the paper <a href="http://arxiv.org/abs/1411.4280">Efficient Object Localization Using Convolutional Networks</a> , if adjacent pixels within feature maps are strongly correlated (as is normally the case in early convolution layers) then i.i.d. dropout will not regularize the activations and will otherwise just result in an effective learning rate decrease.</p>
<p>In this case, <code>nn.Dropout3d()</code> will help promote independence between feature maps and should be used instead.</p>
<p>Parameters: </p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – probability of an element to be zeroed.</li>
<li><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If set to <code>True</code>, will do this operation in-place</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /></li>
<li>Output: <img alt="" src="../img/f5a45f7b445db562b21cfcb525637aab.jpg" /> (same shape as input)</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Dropout3d(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16, 4, 32, 32)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h3 id="alphadropout">AlphaDropout</h3>
<pre><code class="language-py">class torch.nn.AlphaDropout(p=0.5, inplace=False)
</code></pre>
<p>Applies Alpha Dropout over the input.</p>
<p>Alpha Dropout is a type of Dropout that maintains the self-normalizing property. For an input with zero mean and unit standard deviation, the output of Alpha Dropout maintains the original mean and standard deviation of the input. Alpha Dropout goes hand-in-hand with SELU activation function, which ensures that the outputs have zero mean and unit standard deviation.</p>
<p>During training, it randomly masks some of the elements of the input tensor with probability <em>p</em> using samples from a bernoulli distribution. The elements to masked are randomized on every forward call, and scaled and shifted to maintain zero mean and unit standard deviation.</p>
<p>During evaluation the module simply computes an identity function.</p>
<p>More details can be found in the paper <a href="https://arxiv.org/abs/1706.02515">Self-Normalizing Neural Networks</a> .</p>
<p>Parameters: </p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a>) – probability of an element to be dropped. Default: 0.5</li>
<li><strong>inplace</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If set to <code>True</code>, will do this operation in-place</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <code>Any</code>. Input can be of any shape</li>
<li>Output: <code>Same</code>. Output is of the same shape as input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.AlphaDropout(p=0.2)
&gt;&gt;&gt; input = torch.randn(20, 16)
&gt;&gt;&gt; output = m(input)

</code></pre>
<h2 id="sparse-layers">Sparse layers</h2>
<h3 id="embedding">Embedding</h3>
<pre><code class="language-py">class torch.nn.Embedding(num_embeddings, embedding_dim, padding_idx=None, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, sparse=False, _weight=None)
</code></pre>
<p>A simple lookup table that stores embeddings of a fixed dictionary and size.</p>
<p>This module is often used to store word embeddings and retrieve them using indices. The input to the module is a list of indices, and the output is the corresponding word embeddings.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_embeddings</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – size of the dictionary of embeddings</li>
<li><strong>embedding_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of each embedding vector</li>
<li><strong>padding_idx</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – If given, pads the output with the embedding vector at <code>padding_idx</code> (initialized to zeros) whenever it encounters the index.</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – If given, each embedding vector with norm larger than <code>max_norm</code> is renormalized to have norm <code>max_norm</code>.</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – The p of the p-norm to compute for the <code>max_norm</code> option. Default <code>2</code>.</li>
<li><strong>scale_grad_by_freq</strong> (<em>boolean__,</em> <em>optional</em>) – If given, this will scale gradients by the inverse of frequency of the words in the mini-batch. Default <code>False</code>.</li>
<li><strong>sparse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – If <code>True</code>, gradient w.r.t. <code>weight</code> matrix will be a sparse tensor. See Notes for more details regarding sparse gradients.</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the learnable weights of the module of shape (num_embeddings, embedding_dim) initialized from <img alt="" src="../img/dd84ddbf2f8040d87fb315eeeba51f6d.jpg" /></th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Shape:</p>
<blockquote>
<ul>
<li>Input: LongTensor of arbitrary shape containing the indices to extract</li>
<li>Output: <code>(*, embedding_dim)</code>, where <code>*</code> is the input shape</li>
</ul>
</blockquote>
<p>Note</p>
<p>Keep in mind that only a limited number of optimizers support sparse gradients: currently it's <code>optim.SGD</code> (<code>CUDA</code> and <code>CPU</code>), <code>optim.SparseAdam</code> (<code>CUDA</code> and <code>CPU</code>) and <code>optim.Adagrad</code> (<code>CPU</code>)</p>
<p>Note</p>
<p>With <code>padding_idx</code> set, the embedding vector at <code>padding_idx</code> is initialized to all zeros. However, note that this vector can be modified afterwards, e.g., using a customized initialization method, and thus changing the vector used to pad the output. The gradient for this vector from <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> is always zero.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3
&gt;&gt;&gt; embedding = nn.Embedding(10, 3)
&gt;&gt;&gt; # a batch of 2 samples of 4 indices each
&gt;&gt;&gt; input = torch.LongTensor([[1,2,4,5],[4,3,2,9]])
&gt;&gt;&gt; embedding(input)
tensor([[[-0.0251, -1.6902,  0.7172],
 [-0.6431,  0.0748,  0.6969],
 [ 1.4970,  1.3448, -0.9685],
 [-0.3677, -2.7265, -0.1685]],

 [[ 1.4970,  1.3448, -0.9685],
 [ 0.4362, -0.4004,  0.9400],
 [-0.6431,  0.0748,  0.6969],
 [ 0.9124, -2.3616,  1.1151]]])

&gt;&gt;&gt; # example with padding_idx
&gt;&gt;&gt; embedding = nn.Embedding(10, 3, padding_idx=0)
&gt;&gt;&gt; input = torch.LongTensor([[0,2,0,5]])
&gt;&gt;&gt; embedding(input)
tensor([[[ 0.0000,  0.0000,  0.0000],
 [ 0.1535, -2.0309,  0.9315],
 [ 0.0000,  0.0000,  0.0000],
 [-0.1655,  0.9897,  0.0635]]])

</code></pre>
<pre><code class="language-py">classmethod from_pretrained(embeddings, freeze=True, sparse=False)
</code></pre>
<p>Creates Embedding instance from given 2-dimensional FloatTensor.</p>
<p>Parameters: </p>
<ul>
<li><strong>embeddings</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – FloatTensor containing weights for the Embedding. First dimension is being passed to Embedding as 'num_embeddings', second as 'embedding_dim'.</li>
<li><strong>freeze</strong> (<em>boolean__,</em> <em>optional</em>) – If <code>True</code>, the tensor does not get updated in the learning process. Equivalent to <code>embedding.weight.requires_grad = False</code>. Default: <code>True</code></li>
<li><strong>sparse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, gradient w.r.t. weight matrix will be a sparse tensor. See Notes for more details regarding sparse gradients.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # FloatTensor containing pretrained weights
&gt;&gt;&gt; weight = torch.FloatTensor([[1, 2.3, 3], [4, 5.1, 6.3]])
&gt;&gt;&gt; embedding = nn.Embedding.from_pretrained(weight)
&gt;&gt;&gt; # Get embeddings for index 1
&gt;&gt;&gt; input = torch.LongTensor([1])
&gt;&gt;&gt; embedding(input)
tensor([[ 4.0000,  5.1000,  6.3000]])

</code></pre>
<h3 id="embeddingbag">EmbeddingBag</h3>
<pre><code class="language-py">class torch.nn.EmbeddingBag(num_embeddings, embedding_dim, max_norm=None, norm_type=2.0, scale_grad_by_freq=False, mode='mean', sparse=False)
</code></pre>
<p>Computes sums or means of 'bags' of embeddings, without instantiating the intermediate embeddings.</p>
<p>For bags of constant length, this class</p>
<blockquote>
<ul>
<li>with <code>mode="sum"</code> is equivalent to <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> followed by <code>torch.sum(dim=1)</code>,</li>
<li>with <code>mode="mean"</code> is equivalent to <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> followed by <code>torch.mean(dim=1)</code>,</li>
<li>with <code>mode="max"</code> is equivalent to <a href="#torch.nn.Embedding" title="torch.nn.Embedding"><code>Embedding</code></a> followed by <code>torch.max(dim=1)</code>.</li>
</ul>
</blockquote>
<p>However, <a href="#torch.nn.EmbeddingBag" title="torch.nn.EmbeddingBag"><code>EmbeddingBag</code></a> is much more time and memory efficient than using a chain of these operations.</p>
<p>Parameters: </p>
<ul>
<li><strong>num_embeddings</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – size of the dictionary of embeddings</li>
<li><strong>embedding_dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – the size of each embedding vector</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – If given, each embedding vector with norm larger than <code>max_norm</code> is renormalized to have norm <code>max_norm</code>.</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – The p of the p-norm to compute for the <code>max_norm</code> option. Default <code>2</code>.</li>
<li><strong>scale_grad_by_freq</strong> (<em>boolean__,</em> <em>optional</em>) – if given, this will scale gradients by the inverse of frequency of the words in the mini-batch. Default <code>False</code>. Note: this option is not supported when <code>mode="max"</code>.</li>
<li><strong>mode</strong> (<em>string__,</em> <em>optional</em>) – <code>"sum"</code>, <code>"mean"</code> or <code>"max"</code>. Specifies the way to reduce the bag. Default: <code>"mean"</code></li>
<li><strong>sparse</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, gradient w.r.t. <code>weight</code> matrix will be a sparse tensor. See Notes for more details regarding sparse gradients. Note: this option is not supported when <code>mode="max"</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – the learnable weights of the module of shape <code>(num_embeddings x embedding_dim)</code> initialized from <img alt="" src="../img/dd84ddbf2f8040d87fb315eeeba51f6d.jpg" />.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Inputs: <code>input</code> (LongTensor) and <code>offsets</code> (LongTensor, optional)</p>
<blockquote>
<ul>
<li>
<p>If <code>input</code> is 2D of shape <code>B x N</code>,</p>
<p>it will be treated as <code>B</code> bags (sequences) each of fixed length <code>N</code>, and this will return <code>B</code> values aggregated in a way depending on the <code>mode</code>. <code>offsets</code> is ignored and required to be <code>None</code> in this case.</p>
</li>
<li>
<p>If <code>input</code> is 1D of shape <code>N</code>,</p>
<p>it will be treated as a concatenation of multiple bags (sequences). <code>offsets</code> is required to be a 1D tensor containing the starting index positions of each bag in <code>input</code>. Therefore, for <code>offsets</code> of shape <code>B</code>, <code>input</code> will be viewed as having <code>B</code> bags. Empty bags (i.e., having 0-length) will have returned vectors filled by zeros.</p>
</li>
</ul>
</blockquote>
<p>Output shape: <code>B x embedding_dim</code></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; # an Embedding module containing 10 tensors of size 3
&gt;&gt;&gt; embedding_sum = nn.EmbeddingBag(10, 3, mode='sum')
&gt;&gt;&gt; # a batch of 2 samples of 4 indices each
&gt;&gt;&gt; input = torch.LongTensor([1,2,4,5,4,3,2,9])
&gt;&gt;&gt; offsets = torch.LongTensor([0,4])
&gt;&gt;&gt; embedding_sum(input, offsets)
tensor([[-0.8861, -5.4350, -0.0523],
 [ 1.1306, -2.5798, -1.0044]])

</code></pre>
<h2 id="distance-functions">Distance functions</h2>
<h3 id="cosinesimilarity">CosineSimilarity</h3>
<pre><code class="language-py">class torch.nn.CosineSimilarity(dim=1, eps=1e-08)
</code></pre>
<p>Returns cosine similarity between <img alt="" src="../img/abdadb44ea35aecb39004dd7f55d9543.jpg" /> and <img alt="" src="../img/88fdc6eeb68ef4aacf7cd6bd43fa176e.jpg" />, computed along dim.</p>
<p><img alt="" src="../img/93f92bee7ec6c9e48618f7c929ab51e3.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Dimension where cosine similarity is computed. Default: 1</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Small value to avoid division by zero. Default: 1e-8</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input1: <img alt="" src="../img/c2101d997ef86641ad9f92513b080e8a.jpg" /> where D is at position <code>dim</code></li>
<li>Input2: <img alt="" src="../img/c2101d997ef86641ad9f92513b080e8a.jpg" />, same shape as the Input1</li>
<li>Output: <img alt="" src="../img/999c5fb65c1a9ba017a0d60c030400c5.jpg" /></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input1 = torch.randn(100, 128)
&gt;&gt;&gt; input2 = torch.randn(100, 128)
&gt;&gt;&gt; cos = nn.CosineSimilarity(dim=1, eps=1e-6)
&gt;&gt;&gt; output = cos(input1, input2)

</code></pre>
<h3 id="pairwisedistance">PairwiseDistance</h3>
<pre><code class="language-py">class torch.nn.PairwiseDistance(p=2.0, eps=1e-06, keepdim=False)
</code></pre>
<p>Computes the batchwise pairwise distance between vectors <img alt="" src="../img/2f0f406e2d42300da1a9891d89381576.jpg" />, <img alt="" src="../img/60787776d6fd54b3adfd3762b910bd3f.jpg" /> using the p-norm:</p>
<p><img alt="" src="../img/4206b08d53423c6d6f77c51751d33cae.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>p</strong> (<em>real</em>) – the norm degree. Default: 2</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Small value to avoid division by zero. Default: 1e-6</li>
<li><strong>keepdim</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Determines whether or not to keep the batch dimension. Default: False</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input1: <img alt="" src="../img/3dc464d2e10c731f17264e33e497c1a8.jpg" /> where <code>D = vector dimension</code></li>
<li>Input2: <img alt="" src="../img/3dc464d2e10c731f17264e33e497c1a8.jpg" />, same shape as the Input1</li>
<li>Output: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" />. If <code>keepdim</code> is <code>False</code>, then <img alt="" src="../img/f1b7cdb5b976f1adde1e8b2850a1c127.jpg" />.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; pdist = nn.PairwiseDistance(p=2)
&gt;&gt;&gt; input1 = torch.randn(100, 128)
&gt;&gt;&gt; input2 = torch.randn(100, 128)
&gt;&gt;&gt; output = pdist(input1, input2)

</code></pre>
<h2 id="loss-functions">Loss functions</h2>
<h3 id="l1loss">L1Loss</h3>
<pre><code class="language-py">class torch.nn.L1Loss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the mean absolute error (MAE) between each element in the input <code>x</code> and target <code>y</code>.</p>
<p>The loss can be described as:</p>
<p><img alt="" src="../img/415564bfa6c89ba182a02fe2a3d0ca49.jpg" /></p>
<p>where <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is the batch size. If reduce is <code>True</code>, then:</p>
<p><img alt="" src="../img/dd1952e377a9b618cc6538b18165a417.jpg" /></p>
<p><code>x</code> and <code>y</code> are tensors of arbitrary shapes with a total of <code>n</code> elements each.</p>
<p>The sum operation still operates over all the elements, and divides by <code>n</code>.</p>
<p>The division by <code>n</code> can be avoided if one sets the constructor argument <code>size_average=False</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
<li>Output: scalar. If reduce is <code>False</code>, then <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.L1Loss()
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; target = torch.randn(3, 5)
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="mseloss">MSELoss</h3>
<pre><code class="language-py">class torch.nn.MSELoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the mean squared error (squared L2 norm) between each element in the input <code>x</code> and target <code>y</code>.</p>
<p>The loss can be described as:</p>
<p><img alt="" src="../img/e67b64ef5017709a433d1214a681717e.jpg" /></p>
<p>where <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is the batch size. If reduce is <code>True</code>, then:</p>
<p><img alt="" src="../img/f3a00c026a75843dd3a04c64f9cecb47.jpg" /></p>
<p>The sum operation still operates over all the elements, and divides by <code>n</code>.</p>
<p>The division by <code>n</code> can be avoided if one sets <code>size_average</code> to <code>False</code>.</p>
<p>To get a batch of losses, a loss per batch element, set <code>reduce</code> to <code>False</code>. These losses are not averaged and are not affected by <code>size_average</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.MSELoss()
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; target = torch.randn(3, 5)
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="crossentropyloss">CrossEntropyLoss</h3>
<pre><code class="language-py">class torch.nn.CrossEntropyLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')
</code></pre>
<p>This criterion combines <code>nn.LogSoftmax()</code> and <code>nn.NLLLoss()</code> in one single class.</p>
<p>It is useful when training a classification problem with <code>C</code> classes. If provided, the optional argument <code>weight</code> should be a 1D <code>Tensor</code> assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set.</p>
<p>The <code>input</code> is expected to contain scores for each class.</p>
<p><code>input</code> has to be a Tensor of size either <img alt="" src="../img/cca0c8da541b81bec031e4e52161d2c7.jpg" /> or <img alt="" src="../img/f30f7531b252dc52c6bb945ebb508cc4.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> for the <code>K</code>-dimensional case (described later).</p>
<p>This criterion expects a class index (0 to <code>C-1</code>) as the <code>target</code> for each value of a 1D tensor of size <code>minibatch</code></p>
<p>The loss can be described as:</p>
<p><img alt="" src="../img/29028e6a28821a298d2a456d6bb175f9.jpg" /></p>
<p>or in the case of the <code>weight</code> argument being specified:</p>
<p><img alt="" src="../img/bc344720164c2bc94ebd3f405b898216.jpg" /></p>
<p>The losses are averaged across observations for each minibatch.</p>
<p>Can also be used for higher dimension inputs, such as 2D images, by providing an input of size <img alt="" src="../img/f30f7531b252dc52c6bb945ebb508cc4.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" />, where <img alt="" src="../img/a5db490cd70a38a0bb9f3de58c51589f.jpg" /> is the number of dimensions, and a target of appropriate shape (see below).</p>
<p>Parameters: </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, has to be a Tensor of size <code>C</code></li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>ignore_index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Specifies a target value that is ignored and does not contribute to the input gradient. When <code>size_average</code> is <code>True</code>, the loss is averaged over non-ignored targets.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p><code>py
    Input: \((N, C)\) where C = number of classes, or</code></p>
<p><img alt="" src="../img/ddeb501040934760370435d1c223e6b6.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> in the case of <code>K</code>-dimensional loss.
*   <code>py
Target: \((N)\) where each value is \(0 \leq \text{targets}[i] \leq C-1\), or</code></p>
<p><img alt="" src="../img/5981db74a9cd434c7580e6ba530e21b6.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> in the case of K-dimensional loss.
*   <code>py
Output: scalar. If reduce is False, then the same size</code></p>
<p>as the target: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" />, or <img alt="" src="../img/5981db74a9cd434c7580e6ba530e21b6.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> in the case of K-dimensional loss.</p>
</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.CrossEntropyLoss()
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; target = torch.empty(3, dtype=torch.long).random_(5)
&gt;&gt;&gt; output = loss(input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="ctcloss">CTCLoss</h3>
<pre><code class="language-py">class torch.nn.CTCLoss(blank=0, reduction='mean')
</code></pre>
<p>The Connectionist Temporal Classification loss.</p>
<p>Parameters: </p>
<ul>
<li><strong>blank</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – blank label. Default <img alt="" src="../img/28256dd5af833c877d63bfabfaa7b301.jpg" />.</li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the output losses will be divided by the target lengths and then the mean over the batch is taken. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Inputs:
</code></pre>
<pre><code class="language-py">log_probs: Tensor of size \((T, N, C)\) where C = number of characters in alphabet including blank,
</code></pre>
<p><cite>T = input length</cite>, and <cite>N = batch size</cite>. The logarithmized probabilities of the outputs (e.g. obtained with <a href="#torch.nn.functional.log_softmax" title="torch.nn.functional.log_softmax"><code>torch.nn.functional.log_softmax()</code></a>).</p>
<pre><code class="language-py">targets: Tensor of size \((N, S)\) or (sum(target_lengths)).
</code></pre>
<p>Targets (cannot be blank). In the second form, the targets are assumed to be concatenated.</p>
<pre><code class="language-py">input_lengths: Tuple or tensor of size \((N)\).
</code></pre>
<p>Lengths of the inputs (must each be <img alt="" src="../img/0063f9a7d145aadc1082a0c4c8712a62.jpg" />)</p>
<pre><code class="language-py">target_lengths: Tuple or tensor of size  \((N)\).
</code></pre>
<p>Lengths of the targets</p>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; ctc_loss = nn.CTCLoss()
&gt;&gt;&gt; log_probs = torch.randn(50, 16, 20).log_softmax(2).detach().requires_grad_()
&gt;&gt;&gt; targets = torch.randint(1, 20, (16, 30), dtype=torch.long)
&gt;&gt;&gt; input_lengths = torch.full((16,), 50, dtype=torch.long)
&gt;&gt;&gt; target_lengths = torch.randint(10,30,(16,), dtype=torch.long)
&gt;&gt;&gt; loss = ctc_loss(log_probs, targets, input_lengths, target_lengths)
&gt;&gt;&gt; loss.backward()

</code></pre>
<pre><code class="language-py">Reference:
</code></pre>
<p>A. Graves et al.: Connectionist Temporal Classification: Labelling Unsegmented Sequence Data with Recurrent Neural Networks: <a href="https://www.cs.toronto.edu/~graves/icml_2006.pdf">https://www.cs.toronto.edu/~graves/icml_2006.pdf</a></p>
<p>Note</p>
<p>In order to use CuDNN, the following must be satisfied: <code>targets</code> must be in concatenated format, all <code>input_lengths</code> must be <code>T</code>. <img alt="" src="../img/e465f6009cd227a31d00f005c2cb1c5b.jpg" />, <code>target_lengths</code> <img alt="" src="../img/3a2535723ad2261fbfc71d099a993883.jpg" />, the integer arguments must be of dtype <code>torch.int32</code>.</p>
<p>The regular implementation uses the (more common in PyTorch) <code>torch.long</code> dtype.</p>
<p>Note</p>
<p>In some circumstances when using the CUDA backend with CuDNN, this operator may select a nondeterministic algorithm to increase performance. If this is undesirable, you can try to make the operation deterministic (potentially at a performance cost) by setting <code>torch.backends.cudnn.deterministic = True</code>. Please see the notes on <a href="notes/randomness.html">Reproducibility</a> for background.</p>
<h3 id="nllloss">NLLLoss</h3>
<pre><code class="language-py">class torch.nn.NLLLoss(weight=None, size_average=None, ignore_index=-100, reduce=None, reduction='mean')
</code></pre>
<p>The negative log likelihood loss. It is useful to train a classification problem with <code>C</code> classes.</p>
<p>If provided, the optional argument <code>weight</code> should be a 1D Tensor assigning weight to each of the classes. This is particularly useful when you have an unbalanced training set.</p>
<p>The input given through a forward call is expected to contain log-probabilities of each class. <code>input</code> has to be a Tensor of size either <img alt="" src="../img/cca0c8da541b81bec031e4e52161d2c7.jpg" /> or <img alt="" src="../img/f30f7531b252dc52c6bb945ebb508cc4.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> for the <code>K</code>-dimensional case (described later).</p>
<p>Obtaining log-probabilities in a neural network is easily achieved by adding a <code>LogSoftmax</code> layer in the last layer of your network. You may use <code>CrossEntropyLoss</code> instead, if you prefer not to add an extra layer.</p>
<p>The target that this loss expects is a class index <code>(0 to C-1, where C = number of classes)</code></p>
<p>If <code>reduce</code> is <code>False</code>, the loss can be described as:</p>
<p><img alt="" src="../img/edf1079de0e5df9633d0de83b68250f2.jpg" /></p>
<p>where <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is the batch size. If <code>reduce</code> is <code>True</code> (default), then</p>
<p><img alt="" src="../img/6eeb4eee2867f6565cb78f3d2e8503f2.jpg" /></p>
<p>Can also be used for higher dimension inputs, such as 2D images, by providing an input of size <img alt="" src="../img/f30f7531b252dc52c6bb945ebb508cc4.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" />, where <img alt="" src="../img/a5db490cd70a38a0bb9f3de58c51589f.jpg" /> is the number of dimensions, and a target of appropriate shape (see below). In the case of images, it computes NLL loss per-pixel.</p>
<p>Parameters: </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, it has to be a Tensor of size <code>C</code>. Otherwise, it is treated as if having all ones.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>ignore_index</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Specifies a target value that is ignored and does not contribute to the input gradient. When <code>size_average</code> is <code>True</code>, the loss is averaged over non-ignored targets.</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>
<p><code>py
    Input: \((N, C)\) where C = number of classes, or</code></p>
<p><img alt="" src="../img/ddeb501040934760370435d1c223e6b6.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> in the case of <code>K</code>-dimensional loss.
*   <code>py
Target: \((N)\) where each value is \(0 \leq \text{targets}[i] \leq C-1\), or</code></p>
<p><img alt="" src="../img/5981db74a9cd434c7580e6ba530e21b6.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> in the case of K-dimensional loss.
*   <code>py
Output: scalar. If reduce is False, then the same size</code></p>
<p>as the target: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" />, or <img alt="" src="../img/5981db74a9cd434c7580e6ba530e21b6.jpg" /> with <img alt="" src="../img/6573879e7d2cf58e8dfdbf8baa9f7a1a.jpg" /> in the case of K-dimensional loss.</p>
</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; loss = nn.NLLLoss()
&gt;&gt;&gt; # input is of size N x C = 3 x 5
&gt;&gt;&gt; input = torch.randn(3, 5, requires_grad=True)
&gt;&gt;&gt; # each element in target has to have 0 &lt;= value &lt; C
&gt;&gt;&gt; target = torch.tensor([1, 0, 4])
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()
&gt;&gt;&gt;
&gt;&gt;&gt;
&gt;&gt;&gt; # 2D loss example (used, for example, with image inputs)
&gt;&gt;&gt; N, C = 5, 4
&gt;&gt;&gt; loss = nn.NLLLoss()
&gt;&gt;&gt; # input is of size N x C x height x width
&gt;&gt;&gt; data = torch.randn(N, 16, 10, 10)
&gt;&gt;&gt; conv = nn.Conv2d(16, C, (3, 3))
&gt;&gt;&gt; m = nn.LogSoftmax()
&gt;&gt;&gt; # each element in target has to have 0 &lt;= value &lt; C
&gt;&gt;&gt; target = torch.empty(N, 8, 8, dtype=torch.long).random_(0, C)
&gt;&gt;&gt; output = loss(m(conv(data)), target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="poissonnllloss">PoissonNLLLoss</h3>
<pre><code class="language-py">class torch.nn.PoissonNLLLoss(log_input=True, full=False, size_average=None, eps=1e-08, reduce=None, reduction='mean')
</code></pre>
<p>Negative log likelihood loss with Poisson distribution of target.</p>
<p>The loss can be described as:</p>
<p><img alt="" src="../img/f50aaec015c8f6f2ef26d16a60023ea1.jpg" /></p>
<p>The last term can be omitted or approximated with Stirling formula. The approximation is used for target values more than 1. For targets less or equal to 1 zeros are added to the loss.</p>
<p>Parameters: </p>
<ul>
<li><strong>log_input</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code> the loss is computed as <img alt="" src="../img/18729f59c6d4705e1945b3d7b3e09e32.jpg" />, if <code>False</code> the loss is <img alt="" src="../img/036591dc90f1dafaa138920518e2b05b.jpg" />.</li>
<li>
<p><strong>full</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) –</p>
<p>whether to compute full loss, i. e. to add the Stirling approximation term</p>
<p><img alt="" src="../img/b063f11c809ea98839d91fc34d0b4bf0.jpg" /></p>
</li>
<li>
<p><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></p>
</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Small value to avoid evaluation of <img alt="" src="../img/f6dcd4f69520c309a6d71002bd330cb8.jpg" /> when <code>log_input == False</code>. Default: 1e-8</li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; loss = nn.PoissonNLLLoss()
&gt;&gt;&gt; log_input = torch.randn(5, 2, requires_grad=True)
&gt;&gt;&gt; target = torch.randn(5, 2)
&gt;&gt;&gt; output = loss(log_input, target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="kldivloss">KLDivLoss</h3>
<pre><code class="language-py">class torch.nn.KLDivLoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>The <a href="https://en.wikipedia.org/wiki/Kullback-Leibler_divergence">Kullback-Leibler divergence</a> Loss</p>
<p>KL divergence is a useful distance measure for continuous distributions and is often useful when performing direct regression over the space of (discretely sampled) continuous output distributions.</p>
<p>As with <a href="#torch.nn.NLLLoss" title="torch.nn.NLLLoss"><code>NLLLoss</code></a>, the <code>input</code> given is expected to contain <em>log-probabilities</em>. However, unlike <a href="#torch.nn.NLLLoss" title="torch.nn.NLLLoss"><code>NLLLoss</code></a>, <code>input</code> is not restricted to a 2D Tensor. The targets are given as <em>probabilities</em> (i.e. without taking the logarithm).</p>
<p>This criterion expects a <code>target</code> <code>Tensor</code> of the same size as the <code>input</code> <code>Tensor</code>.</p>
<p>The unreduced (i.e. with <code>reduce</code> set to <code>False</code>) loss can be described as:</p>
<p><img alt="" src="../img/eba993f61a08816ebd5f577851d521f2.jpg" /></p>
<p>where the index <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> spans all dimensions of <code>input</code> and <img alt="" src="../img/db4a9fef02111450bf98261889de550c.jpg" /> has the same shape as <code>input</code>. If <code>reduce</code> is <code>True</code> (the default), then:</p>
<p><img alt="" src="../img/d88944e162eff94bddc1b9a94bcaa3a6.jpg" /></p>
<p>In default reduction mode 'mean', the losses are averaged for each minibatch over observations <strong>as well as</strong> over dimensions. 'batchmean' mode gives the correct KL divergence where losses are averaged over batch dimension only. 'mean' mode's behavior will be changed to the same as 'batchmean' in the next major release.</p>
<p>Parameters: </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'batchmean' &#124; 'sum' &#124; 'mean'. 'none': no reduction will be applied. 'batchmean': the sum of the output will be divided by batchsize. 'sum': the output will be summed. 'mean': the output will be divided by the number of elements in the output. Default: 'mean'</li>
</ul>
<p>:param .. note:: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated,: and in the meantime, specifying either of those two args will override <code>reduction</code>. :param .. note:: <code>reduction='mean'</code> doesn't return the true kl divergence value, please use: <code>reduction='batchmean'</code> which aligns with KL math definition.</p>
<blockquote>
<p>In the next major release, 'mean' will be changed to be the same as 'batchmean'.</p>
</blockquote>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>input: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> where <code>*</code> means, any number of additional dimensions</li>
<li>target: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
<li>
<p><code>py
    output: scalar by default. If reduce is False, then \((N, *)\),</code></p>
<p>the same shape as the input</p>
</li>
</ul>
<h3 id="bceloss">BCELoss</h3>
<pre><code class="language-py">class torch.nn.BCELoss(weight=None, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the Binary Cross Entropy between the target and the output:</p>
<p>The loss can be described as:</p>
<p><img alt="" src="../img/f233882012c0c24fcad1869a163b5b7c.jpg" /></p>
<p>where <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is the batch size. If reduce is <code>True</code>, then</p>
<p><img alt="" src="../img/d88944e162eff94bddc1b9a94bcaa3a6.jpg" /></p>
<p>This is used for measuring the error of a reconstruction in for example an auto-encoder. Note that the targets <code>y</code> should be numbers between 0 and 1.</p>
<p>Parameters: </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to the loss of each batch element. If given, has to be a Tensor of size “nbatch”.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N, *)</code>, same shape as input.</li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = nn.Sigmoid()
&gt;&gt;&gt; loss = nn.BCELoss()
&gt;&gt;&gt; input = torch.randn(3, requires_grad=True)
&gt;&gt;&gt; target = torch.empty(3).random_(2)
&gt;&gt;&gt; output = loss(m(input), target)
&gt;&gt;&gt; output.backward()

</code></pre>
<h3 id="bcewithlogitsloss">BCEWithLogitsLoss</h3>
<pre><code class="language-py">class torch.nn.BCEWithLogitsLoss(weight=None, size_average=None, reduce=None, reduction='mean', pos_weight=None)
</code></pre>
<p>This loss combines a <code>Sigmoid</code> layer and the <code>BCELoss</code> in one single class. This version is more numerically stable than using a plain <code>Sigmoid</code> followed by a <code>BCELoss</code> as, by combining the operations into one layer, we take advantage of the log-sum-exp trick for numerical stability.</p>
<p>The loss can be described as:</p>
<p><img alt="" src="../img/0c49aad6f81ec7936e313096f7a53f97.jpg" /></p>
<p>where <img alt="" src="../img/9341d9048ac485106d2b2ee8de14876f.jpg" /> is the batch size. If reduce is <code>True</code>, then</p>
<p><img alt="" src="../img/0a16102d9320f70f18d7c8b152000489.jpg" /></p>
<p>This is used for measuring the error of a reconstruction in for example an auto-encoder. Note that the targets <code>t[i]</code> should be numbers between 0 and 1.</p>
<p>It's possible to trade off recall and precision by adding weights to positive examples. In this case the loss can be described as:</p>
<p><img alt="" src="../img/d5ca42e0ee1490d1dea4d5f38cc120d7.jpg" /></p>
<p>where <img alt="" src="../img/76dc369e067e5fa42a4b32b6afd5e570.jpg" /> is the positive weight of class <img alt="" src="../img/493731e423d5db62086d0b8705dda0c8.jpg" />. <img alt="" src="../img/65abc7465f8ac5056f8562962f0ae02e.jpg" /> increases the recall, <img alt="" src="../img/989afd86a6407cf24295ae8d52ff0080.jpg" /> increases the precision.</p>
<p>For example, if a dataset contains 100 positive and 300 negative examples of a single class, then <code>pos_weight</code> for the class should be equal to <img alt="" src="../img/6a003751ded2d5e5198d93ee7db1ba5d.jpg" />. The loss would act as if the dataset contains <img alt="" src="../img/fb2ad75ea1ac3ba3ae507a3c8a34db12.jpg" /> positive examples.</p>
<p>Parameters: </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to the loss of each batch element. If given, has to be a Tensor of size “nbatch”.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
<li><strong>pos_weight</strong> – a weight of positive examples. Must be a vector with length equal to the number of classes.</li>
</ul>
<h3 id="marginrankingloss">MarginRankingLoss</h3>
<pre><code class="language-py">class torch.nn.MarginRankingLoss(margin=0.0, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the loss given inputs <code>x1</code>, <code>x2</code>, two 1D mini-batch <code>Tensor</code>s, and a label 1D mini-batch tensor <code>y</code> with values (<code>1</code> or <code>-1</code>).</p>
<p>If <code>y == 1</code> then it assumed the first input should be ranked higher (have a larger value) than the second input, and vice-versa for <code>y == -1</code>.</p>
<p>The loss function for each sample in the mini-batch is:</p>
<p><img alt="" src="../img/1664f71bed4b6591f02c8bbb10f2d389.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>0</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/3dc464d2e10c731f17264e33e497c1a8.jpg" /> where <code>N</code> is the batch size and <code>D</code> is the size of a sample.</li>
<li>Target: <img alt="" src="../img/2a3e2b832e04fe8d66596083b23da518.jpg" /></li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<h3 id="hingeembeddingloss">HingeEmbeddingLoss</h3>
<pre><code class="language-py">class torch.nn.HingeEmbeddingLoss(margin=1.0, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Measures the loss given an input tensor <code>x</code> and a labels tensor <code>y</code> containing values (<code>1</code> or <code>-1</code>). This is usually used for measuring whether two inputs are similar or dissimilar, e.g. using the L1 pairwise distance as <code>x</code>, and is typically used for learning nonlinear embeddings or semi-supervised learning.</p>
<p>The loss function for <img alt="" src="../img/493731e423d5db62086d0b8705dda0c8.jpg" />-th sample in the mini-batch is</p>
<p><img alt="" src="../img/1e176ed632f1cbc86eb8db4bf6034f24.jpg" /></p>
<p>and the total loss functions is</p>
<p><img alt="" src="../img/0a16102d9320f70f18d7c8b152000489.jpg" /></p>
<p>where <img alt="" src="../img/97b4908568a8d2f8549d90e683a8efa2.jpg" />.</p>
<p>Parameters: </p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>1</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: Tensor of arbitrary shape. The sum operation operates over all the elements.</li>
<li>Target: Same shape as input.</li>
<li>Output: scalar. If reduce is <code>False</code>, then same shape as the input</li>
</ul>
<h3 id="multilabelmarginloss">MultiLabelMarginLoss</h3>
<pre><code class="language-py">class torch.nn.MultiLabelMarginLoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a multi-class multi-classification hinge loss (margin-based loss) between input <code>x</code> (a 2D mini-batch <code>Tensor</code>) and output <code>y</code> (which is a 2D <code>Tensor</code> of target class indices). For each sample in the mini-batch:</p>
<p><img alt="" src="../img/f4d7e37a53b15d27b3a25c9dc586cd00.jpg" /></p>
<p>where <img alt="" src="../img/b75aa938b45ed55c0aa471218a7224ce.jpg" /> to <img alt="" src="../img/c915dd214c2340e40ac8e79013465783.jpg" />, <img alt="" src="../img/4da95e4f78bfe10987f5549ced63a7e6.jpg" /> to <img alt="" src="../img/ec0f8a278c4b73ccb95d3a4c1d129697.jpg" />, <img alt="" src="../img/8058aac8e03495c71f75b04169d5baca.jpg" />, and <img alt="" src="../img/27b5f368a27d1e15b3656796a28a4411.jpg" /> for all <img alt="" src="../img/31df9c730e19ca29b59dce64b99d98c1.jpg" /> and <img alt="" src="../img/d8fdd0e28cfb03738fc5227885ee035a.jpg" />.</p>
<p><code>y</code> and <code>x</code> must have the same size.</p>
<p>The criterion only considers a contiguous block of non-negative targets that starts at the front.</p>
<p>This allows for different samples to have variable amounts of target classes</p>
<p>Parameters: </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/861a7d7a604a97f5620afad259a4c26d.jpg" /> or <img alt="" src="../img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" /> where <code>N</code> is the batch size and <code>C</code> is the number of classes.</li>
<li>Target: <img alt="" src="../img/861a7d7a604a97f5620afad259a4c26d.jpg" /> or <img alt="" src="../img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" />, same shape as the input.</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<h3 id="smoothl1loss">SmoothL1Loss</h3>
<pre><code class="language-py">class torch.nn.SmoothL1Loss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that uses a squared term if the absolute element-wise error falls below 1 and an L1 term otherwise. It is less sensitive to outliers than the <code>MSELoss</code> and in some cases prevents exploding gradients (e.g. see “Fast R-CNN” paper by Ross Girshick). Also known as the Huber loss:</p>
<p><img alt="" src="../img/cd503c18d22f0e18a5109f3f13d028b2.jpg" /></p>
<p>where <img alt="" src="../img/bbfcb7c1428a33547e15f8853dbe6e4f.jpg" /> is given by:</p>
<p><img alt="" src="../img/621fa336f1f8b6169430fa6b42a00b6d.jpg" /></p>
<p><code>x</code> and <code>y</code> arbitrary shapes with a total of <code>n</code> elements each the sum operation still operates over all the elements, and divides by <code>n</code>.</p>
<p>The division by <code>n</code> can be avoided if one sets <code>size_average</code> to <code>False</code></p>
<p>Parameters: </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" /> where <code>*</code> means, any number of additional dimensions</li>
<li>Target: <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
<li>Output: scalar. If reduce is <code>False</code>, then <img alt="" src="../img/eb7a3f5bc15cc379e78f768e821eb094.jpg" />, same shape as the input</li>
</ul>
<h3 id="softmarginloss">SoftMarginLoss</h3>
<pre><code class="language-py">class torch.nn.SoftMarginLoss(size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a two-class classification logistic loss between input tensor <code>x</code> and target tensor <code>y</code> (containing 1 or -1).</p>
<p><img alt="" src="../img/811f3185227a964c048126484987ef1c.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: Tensor of arbitrary shape.</li>
<li>Target: Same shape as input.</li>
<li>Output: scalar. If reduce is <code>False</code>, then same shape as the input</li>
</ul>
<h3 id="multilabelsoftmarginloss">MultiLabelSoftMarginLoss</h3>
<pre><code class="language-py">class torch.nn.MultiLabelSoftMarginLoss(weight=None, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a multi-label one-versus-all loss based on max-entropy, between input <code>x</code> and target <code>y</code> of size <code>(N, C)</code>. For each sample in the minibatch:</p>
<p><img alt="" src="../img/342414ff43adf5d0fa0b62fcde9538a2.jpg" /></p>
<p>where <code>i == 0</code> to <code>x.nElement()-1</code>, <code>y[i] in {0,1}</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, it has to be a Tensor of size <code>C</code>. Otherwise, it is treated as if having all ones.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" /> where <code>N</code> is the batch size and <code>C</code> is the number of classes.</li>
<li>Target: <img alt="" src="../img/9b9aebaa467ad07dca05b5086bd21ca2.jpg" />, same shape as the input.</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<h3 id="cosineembeddingloss">CosineEmbeddingLoss</h3>
<pre><code class="language-py">class torch.nn.CosineEmbeddingLoss(margin=0.0, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the loss given input tensors <img alt="" src="../img/abdadb44ea35aecb39004dd7f55d9543.jpg" />, <img alt="" src="../img/88fdc6eeb68ef4aacf7cd6bd43fa176e.jpg" /> and a <code>Tensor</code> label <code>y</code> with values 1 or -1. This is used for measuring whether two inputs are similar or dissimilar, using the cosine distance, and is typically used for learning nonlinear embeddings or semi-supervised learning.</p>
<p>The loss function for each sample is:</p>
<p><img alt="" src="../img/f894a052d4408e0269216f8b803d074a.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Should be a number from <code>-1</code> to <code>1</code>, <code>0</code> to <code>0.5</code> is suggested. If <code>margin</code> is missing, the default value is <code>0</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<h3 id="multimarginloss">MultiMarginLoss</h3>
<pre><code class="language-py">class torch.nn.MultiMarginLoss(p=1, margin=1.0, weight=None, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that optimizes a multi-class classification hinge loss (margin-based loss) between input <code>x</code> (a 2D mini-batch <code>Tensor</code>) and output <code>y</code> (which is a 1D tensor of target class indices, <img alt="" src="../img/fffe5e09046ebb236f89daa5091946f6.jpg" />):</p>
<p>For each mini-batch sample, the loss in terms of the 1D input <code>x</code> and scalar output <code>y</code> is:</p>
<p><img alt="" src="../img/0f825c52299de2e574d5903469e1af9c.jpg" /></p>
<p>where <code>i == 0</code> to <code>x.size(0)</code> and <img alt="" src="../img/99e4beebf24a180393aa15ec3740cf3a.jpg" />.</p>
<p>Optionally, you can give non-equal weighting on the classes by passing a 1D <code>weight</code> tensor into the constructor.</p>
<p>The loss function then becomes:</p>
<p><img alt="" src="../img/03b7ccf64bc071a7c2abbeab89f12d08.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>1</code>. <code>1</code> and <code>2</code> are the only supported values</li>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Has a default value of <code>1</code>.</li>
<li><strong>weight</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>,</em> <em>optional</em>) – a manual rescaling weight given to each class. If given, it has to be a Tensor of size <code>C</code>. Otherwise, it is treated as if having all ones.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<h3 id="tripletmarginloss">TripletMarginLoss</h3>
<pre><code class="language-py">class torch.nn.TripletMarginLoss(margin=1.0, p=2.0, eps=1e-06, swap=False, size_average=None, reduce=None, reduction='mean')
</code></pre>
<p>Creates a criterion that measures the triplet loss given an input tensors x1, x2, x3 and a margin with a value greater than 0. This is used for measuring a relative similarity between samples. A triplet is composed by <code>a</code>, <code>p</code> and <code>n</code>: anchor, positive examples and negative example respectively. The shapes of all input tensors should be <img alt="" src="../img/3dc464d2e10c731f17264e33e497c1a8.jpg" />.</p>
<p>The distance swap is described in detail in the paper <a href="http://www.iis.ee.ic.ac.uk/%7Evbalnt/shallow_descr/TFeat_paper.pdf">Learning shallow convolutional feature descriptors with triplet losses</a> by V. Balntas, E. Riba et al.</p>
<p>The loss function for each sample in the mini-batch is:</p>
<p><img alt="" src="../img/a2c4faa5dd95a547388c1b7f69bbc4db.jpg" /></p>
<p>where</p>
<p><img alt="" src="../img/bac339e9cf6ad679fa9ce3ce33c431ab.jpg" /></p>
<p>Parameters: </p>
<ul>
<li><strong>margin</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – Default: <code>1</code>.</li>
<li><strong>p</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – The norm degree for pairwise distance. Default: <code>2</code>.</li>
<li><strong>swap</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – The distance swap is described in detail in the paper <code>Learning shallow convolutional feature descriptors with triplet losses</code> by V. Balntas, E. Riba et al. Default: <code>False</code>.</li>
<li><strong>size_average</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged over each loss element in the batch. Note that for some losses, there multiple elements per sample. If the field <code>size_average</code> is set to <code>False</code>, the losses are instead summed for each minibatch. Ignored when reduce is <code>False</code>. Default: <code>True</code></li>
<li><strong>reduce</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – Deprecated (see <code>reduction</code>). By default, the losses are averaged or summed over observations for each minibatch depending on <code>size_average</code>. When <code>reduce</code> is <code>False</code>, returns a loss per batch element instead and ignores <code>size_average</code>. Default: <code>True</code></li>
<li><strong>reduction</strong> (<em>string__,</em> <em>optional</em>) – Specifies the reduction to apply to the output: 'none' &#124; 'mean' &#124; 'sum'. 'none': no reduction will be applied, 'mean': the sum of the output will be divided by the number of elements in the output, 'sum': the output will be summed. Note: <code>size_average</code> and <code>reduce</code> are in the process of being deprecated, and in the meantime, specifying either of those two args will override <code>reduction</code>. Default: 'mean'</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/3dc464d2e10c731f17264e33e497c1a8.jpg" /> where <code>D</code> is the vector dimension.</li>
<li>Output: scalar. If <code>reduce</code> is False, then <code>(N)</code>.</li>
</ul>
<pre><code class="language-py">&gt;&gt;&gt; triplet_loss = nn.TripletMarginLoss(margin=1.0, p=2)
&gt;&gt;&gt; input1 = torch.randn(100, 128, requires_grad=True)
&gt;&gt;&gt; input2 = torch.randn(100, 128, requires_grad=True)
&gt;&gt;&gt; input3 = torch.randn(100, 128, requires_grad=True)
&gt;&gt;&gt; output = triplet_loss(input1, input2, input3)
&gt;&gt;&gt; output.backward()

</code></pre>
<h2 id="vision-layers">Vision layers</h2>
<h3 id="pixelshuffle">PixelShuffle</h3>
<pre><code class="language-py">class torch.nn.PixelShuffle(upscale_factor)
</code></pre>
<p>Rearranges elements in a tensor of shape <img alt="" src="../img/1bc8a113de558f2e7d966e72ae39cb95.jpg" /> to a tensor of shape <img alt="" src="../img/d4e6de257f72abc5a96af64211b7f909.jpg" />.</p>
<p>This is useful for implementing efficient sub-pixel convolution with a stride of <img alt="" src="../img/71c5422a7f21b7096aa6d904d5a4f78d.jpg" />.</p>
<p>Look at the paper: <a href="https://arxiv.org/abs/1609.05158">Real-Time Single Image and Video Super-Resolution Using an Efficient Sub-Pixel Convolutional Neural Network</a> by Shi et. al (2016) for more details.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>upscale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – factor to increase spatial resolution by</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/d6770cccc0ae9886c3b91d55efa20b28.jpg" /></li>
<li>Output: <img alt="" src="../img/a162cf8e9185f67b3f5b084d1031dc7e.jpg" /></li>
</ul>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; pixel_shuffle = nn.PixelShuffle(3)
&gt;&gt;&gt; input = torch.randn(1, 9, 4, 4)
&gt;&gt;&gt; output = pixel_shuffle(input)
&gt;&gt;&gt; print(output.size())
torch.Size([1, 1, 12, 12])

</code></pre>
<h3 id="upsample">Upsample</h3>
<pre><code class="language-py">class torch.nn.Upsample(size=None, scale_factor=None, mode='nearest', align_corners=None)
</code></pre>
<p>Upsamples a given multi-channel 1D (temporal), 2D (spatial) or 3D (volumetric) data.</p>
<p>The input data is assumed to be of the form <code>minibatch x channels x [optional depth] x [optional height] x width</code>. Hence, for spatial inputs, we expect a 4D Tensor and for volumetric inputs, we expect a 5D Tensor.</p>
<p>The algorithms available for upsampling are nearest neighbor and linear, bilinear and trilinear for 3D, 4D and 5D input Tensor, respectively.</p>
<p>One can either give a <code>scale_factor</code> or the target output <code>size</code> to calculate the output size. (You cannot give both, as it is ambiguous)</p>
<p>Parameters: </p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – a tuple of ints <code>([optional D_out], [optional H_out], W_out)</code> output sizes</li>
<li><strong>scale_factor</strong> (<em>int / tuple of python:ints__,</em> <em>optional</em>) – the multiplier for the image height / width / depth</li>
<li><strong>mode</strong> (<em>string__,</em> <em>optional</em>) – the upsampling algorithm: one of <code>nearest</code>, <code>linear</code>, <code>bilinear</code> and <code>trilinear</code>. Default: <code>nearest</code></li>
<li><strong>align_corners</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if True, the corner pixels of the input and output tensors are aligned, and thus preserving the values at those pixels. This only has effect when <code>mode</code> is <code>linear</code>, <code>bilinear</code>, or <code>trilinear</code>. Default: False</li>
</ul>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/964aa6df63e83f4468aa090441f01972.jpg" />, <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /> or <img alt="" src="../img/c187d190013d0785320e3412fe8cd669.jpg" /></li>
<li>Output: <img alt="" src="../img/ac2661719f40fc422e2b1590a1e7b4a4.jpg" />, <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> or <img alt="" src="../img/41ca4c8d4c65c979d2d643c6f62ea280.jpg" />, where</li>
</ul>
<p><img alt="" src="../img/da11a1265058248a851d6d0331110214.jpg" /></p>
<p><img alt="" src="../img/828543b18440713aad6ad023732327ec.jpg" /></p>
<p><img alt="" src="../img/5a7c5c22409d4ab3c83641508bf72cb6.jpg" /></p>
<p>Warning</p>
<p>With <code>align_corners = True</code>, the linearly interpolating modes (<code>linear</code>, <code>bilinear</code>, and <code>trilinear</code>) don't proportionally align the output and input pixels, and thus the output values can depend on the input size. This was the default behavior for these modes up to version 0.3.1. Since then, the default behavior is <code>align_corners = False</code>. See below for concrete examples on how this affects the outputs.</p>
<p>Note</p>
<p>If you want downsampling/general resizing, you should use <code>interpolate()</code>.</p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.arange(1, 5).view(1, 1, 2, 2).float()
&gt;&gt;&gt; input
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='nearest')
&gt;&gt;&gt; m(input)
tensor([[[[ 1.,  1.,  2.,  2.],
 [ 1.,  1.,  2.,  2.],
 [ 3.,  3.,  4.,  4.],
 [ 3.,  3.,  4.,  4.]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear')  # align_corners=False
&gt;&gt;&gt; m(input)
tensor([[[[ 1.0000,  1.2500,  1.7500,  2.0000],
 [ 1.5000,  1.7500,  2.2500,  2.5000],
 [ 2.5000,  2.7500,  3.2500,  3.5000],
 [ 3.0000,  3.2500,  3.7500,  4.0000]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
&gt;&gt;&gt; m(input)
tensor([[[[ 1.0000,  1.3333,  1.6667,  2.0000],
 [ 1.6667,  2.0000,  2.3333,  2.6667],
 [ 2.3333,  2.6667,  3.0000,  3.3333],
 [ 3.0000,  3.3333,  3.6667,  4.0000]]]])

&gt;&gt;&gt; # Try scaling the same data in a larger tensor
&gt;&gt;&gt;
&gt;&gt;&gt; input_3x3 = torch.zeros(3, 3).view(1, 1, 3, 3)
&gt;&gt;&gt; input_3x3[:, :, :2, :2].copy_(input)
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])
&gt;&gt;&gt; input_3x3
tensor([[[[ 1.,  2.,  0.],
 [ 3.,  4.,  0.],
 [ 0.,  0.,  0.]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear')  # align_corners=False
&gt;&gt;&gt; # Notice that values in top left corner are the same with the small input (except at boundary)
&gt;&gt;&gt; m(input_3x3)
tensor([[[[ 1.0000,  1.2500,  1.7500,  1.5000,  0.5000,  0.0000],
 [ 1.5000,  1.7500,  2.2500,  1.8750,  0.6250,  0.0000],
 [ 2.5000,  2.7500,  3.2500,  2.6250,  0.8750,  0.0000],
 [ 2.2500,  2.4375,  2.8125,  2.2500,  0.7500,  0.0000],
 [ 0.7500,  0.8125,  0.9375,  0.7500,  0.2500,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])

&gt;&gt;&gt; m = nn.Upsample(scale_factor=2, mode='bilinear', align_corners=True)
&gt;&gt;&gt; # Notice that values in top left corner are now changed
&gt;&gt;&gt; m(input_3x3)
tensor([[[[ 1.0000,  1.4000,  1.8000,  1.6000,  0.8000,  0.0000],
 [ 1.8000,  2.2000,  2.6000,  2.2400,  1.1200,  0.0000],
 [ 2.6000,  3.0000,  3.4000,  2.8800,  1.4400,  0.0000],
 [ 2.4000,  2.7200,  3.0400,  2.5600,  1.2800,  0.0000],
 [ 1.2000,  1.3600,  1.5200,  1.2800,  0.6400,  0.0000],
 [ 0.0000,  0.0000,  0.0000,  0.0000,  0.0000,  0.0000]]]])

</code></pre>
<h3 id="upsamplingnearest2d">UpsamplingNearest2d</h3>
<pre><code class="language-py">class torch.nn.UpsamplingNearest2d(size=None, scale_factor=None)
</code></pre>
<p>Applies a 2D nearest neighbor upsampling to an input signal composed of several input channels.</p>
<p>To specify the scale, it takes either the <code>size</code> or the <code>scale_factor</code> as it's constructor argument.</p>
<p>When <code>size</code> is given, it is the output size of the image <code>(h, w)</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – a tuple of ints <code>(H_out, W_out)</code> output sizes</li>
<li><strong>scale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the multiplier for the image height or width</li>
</ul>
<p>Warning</p>
<p>This class is deprecated in favor of <code>interpolate()</code>.</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></li>
<li>Output: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> where</li>
</ul>
<p><img alt="" src="../img/682de298a3561bebd964280ba0d59633.jpg" /></p>
<p><img alt="" src="../img/2a53007c25abe7f8f65f1a2e958fa146.jpg" /></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.arange(1, 5).view(1, 1, 2, 2)
&gt;&gt;&gt; input
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])

&gt;&gt;&gt; m = nn.UpsamplingNearest2d(scale_factor=2)
&gt;&gt;&gt; m(input)
tensor([[[[ 1.,  1.,  2.,  2.],
 [ 1.,  1.,  2.,  2.],
 [ 3.,  3.,  4.,  4.],
 [ 3.,  3.,  4.,  4.]]]])

</code></pre>
<h3 id="upsamplingbilinear2d">UpsamplingBilinear2d</h3>
<pre><code class="language-py">class torch.nn.UpsamplingBilinear2d(size=None, scale_factor=None)
</code></pre>
<p>Applies a 2D bilinear upsampling to an input signal composed of several input channels.</p>
<p>To specify the scale, it takes either the <code>size</code> or the <code>scale_factor</code> as it's constructor argument.</p>
<p>When <code>size</code> is given, it is the output size of the image <code>(h, w)</code>.</p>
<p>Parameters: </p>
<ul>
<li><strong>size</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.7)"><em>tuple</em></a><em>,</em> <em>optional</em>) – a tuple of ints <code>(H_out, W_out)</code> output sizes</li>
<li><strong>scale_factor</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – the multiplier for the image height or width</li>
</ul>
<p>Warning</p>
<p>This class is deprecated in favor of <code>interpolate()</code>. It is equivalent to <code>nn.functional.interpolate(..., mode='bilinear', align_corners=True)</code>.</p>
<pre><code class="language-py">Shape:
</code></pre>
<ul>
<li>Input: <img alt="" src="../img/ff71b16eb10237262566c6907acaaf1f.jpg" /></li>
<li>Output: <img alt="" src="../img/a0ef05f779873fc4dcbf020b1ea14754.jpg" /> where</li>
</ul>
<p><img alt="" src="../img/682de298a3561bebd964280ba0d59633.jpg" /></p>
<p><img alt="" src="../img/2a53007c25abe7f8f65f1a2e958fa146.jpg" /></p>
<p>Examples:</p>
<pre><code class="language-py">&gt;&gt;&gt; input = torch.arange(1, 5).view(1, 1, 2, 2)
&gt;&gt;&gt; input
tensor([[[[ 1.,  2.],
 [ 3.,  4.]]]])

&gt;&gt;&gt; m = nn.UpsamplingBilinear2d(scale_factor=2)
&gt;&gt;&gt; m(input)
tensor([[[[ 1.0000,  1.3333,  1.6667,  2.0000],
 [ 1.6667,  2.0000,  2.3333,  2.6667],
 [ 2.3333,  2.6667,  3.0000,  3.3333],
 [ 3.0000,  3.3333,  3.6667,  4.0000]]]])

</code></pre>
<h2 id="dataparallel-layers-multi-gpu-distributed">DataParallel layers (multi-GPU, distributed)</h2>
<h3 id="dataparallel">DataParallel</h3>
<pre><code class="language-py">class torch.nn.DataParallel(module, device_ids=None, output_device=None, dim=0)
</code></pre>
<p>Implements data parallelism at the module level.</p>
<p>This container parallelizes the application of the given <code>module</code> by splitting the input across the specified devices by chunking in the batch dimension (other objects will be copied once per device). In the forward pass, the module is replicated on each device, and each replica handles a portion of the input. During the backwards pass, gradients from each replica are summed into the original module.</p>
<p>The batch size should be larger than the number of GPUs used.</p>
<p>See also: <a href="notes/cuda.html#cuda-nn-dataparallel-instead">Use nn.DataParallel instead of multiprocessing</a></p>
<p>Arbitrary positional and keyword inputs are allowed to be passed into DataParallel EXCEPT Tensors. All tensors will be scattered on dim specified (default 0). Primitive types will be broadcasted, but all other types will be a shallow copy and can be corrupted if written to in the model's forward pass.</p>
<p>The parallelized <code>module</code> must have its parameters and buffers on <code>device_ids[0]</code> before running this <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a> module.</p>
<p>Warning</p>
<p>In each forward, <code>module</code> is <strong>replicated</strong> on each device, so any updates to the runing module in <code>forward</code> will be lost. For example, if <code>module</code> has a counter attribute that is incremented in each <code>forward</code>, it will always stay at the initial value becasue the update is done on the replicas which are destroyed after <code>forward</code>. However, <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a> guarantees that the replica on <code>device[0]</code> will have its parameters and buffers sharing storage with the base parallelized <code>module</code>. So <strong>in-place</strong> updates to the parameters or buffers on <code>device[0]</code> will be recorded. E.g., <a href="#torch.nn.BatchNorm2d" title="torch.nn.BatchNorm2d"><code>BatchNorm2d</code></a> and <a href="#torch.nn.utils.spectral_norm" title="torch.nn.utils.spectral_norm"><code>spectral_norm()</code></a> rely on this behavior to update the buffers.</p>
<p>Warning</p>
<p>Forward and backward hooks defined on <code>module</code> and its submodules will be invoked <code>len(device_ids)</code> times, each with inputs located on a particular device. Particularly, the hooks are only guaranteed to be executed in correct order with respect to operations on corresponding devices. For example, it is not guaranteed that hooks set via <a href="#torch.nn.Module.register_forward_pre_hook" title="torch.nn.Module.register_forward_pre_hook"><code>register_forward_pre_hook()</code></a> be executed before <code>all</code> <code>len(device_ids)</code> <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> calls, but that each such hook be executed before the corresponding <a href="#torch.nn.Module.forward" title="torch.nn.Module.forward"><code>forward()</code></a> call of that device.</p>
<p>Warning</p>
<p>When <code>module</code> returns a scalar (i.e., 0-dimensional tensor) in <code>forward()</code>, this wrapper will return a vector of length equal to number of devices used in data parallelism, containing the result from each device.</p>
<p>Note</p>
<p>There is a subtlety in using the <code>pack sequence -&amp;gt; recurrent network -&amp;gt; unpack sequence</code> pattern in a <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> wrapped in <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a>. See <a href="notes/faq.html#pack-rnn-unpack-with-data-parallelism">My recurrent network doesn't work with data parallelism</a> section in FAQ for details.</p>
<p>Parameters: </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – module to be parallelized</li>
<li><strong>device_ids</strong> (<em>list of python:int</em> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – CUDA devices (default: all devices)</li>
<li><strong>output_device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – device location of output (default: device_ids[0])</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – the module to be parallelized</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; net = torch.nn.DataParallel(model, device_ids=[0, 1, 2])
&gt;&gt;&gt; output = net(input_var)

</code></pre>
<h3 id="distributeddataparallel">DistributedDataParallel</h3>
<pre><code class="language-py">class torch.nn.parallel.DistributedDataParallel(module, device_ids=None, output_device=None, dim=0, broadcast_buffers=True, process_group=None, bucket_cap_mb=25, check_reduction=False)
</code></pre>
<p>Implements distributed data parallelism that is based on torch.distributed package at the module level.</p>
<p>This container parallelizes the application of the given module by splitting the input across the specified devices by chunking in the batch dimension. The module is replicated on each machine and each device, and each such replica handles a portion of the input. During the backwards pass, gradients from each node are averaged.</p>
<p>The batch size should be larger than the number of GPUs used locally. It should also be an integer multiple of the number of GPUs so that each chunk is the same size (so that each GPU processes the same number of samples).</p>
<p>See also: <a href="distributed.html#distributed-basics">Basics</a> and <a href="notes/cuda.html#cuda-nn-dataparallel-instead">Use nn.DataParallel instead of multiprocessing</a>. The same constraints on input as in <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> apply.</p>
<p>Creation of this class requires that <code>torch.distributed</code> to be already initialized, by calling <a href="distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a></p>
<p><code>DistributedDataParallel</code> can be used in the following two ways:</p>
<ol>
<li>Single-Process Multi-GPU</li>
</ol>
<p>In this case, a single process will be spawned on each host/node and each process will operate on all the GPUs of the node where it's running. To use <code>DistributedDataParallel</code> in this way, you can simply construct the model as the following:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(backend=&quot;nccl&quot;)
&gt;&gt;&gt; model = DistributedDataParallel(model) # device_ids will include all GPU devices be default

</code></pre>
<ol>
<li>Multi-Process Single-GPU</li>
</ol>
<p>This is the highly recommended way to use <code>DistributedDataParallel</code>, with multiple processes, each of which operates on a single GPU. This is currently the fastest approach to do data parallel training using PyTorch and applies to both single-node(multi-GPU) and multi-node data parallel training. It is proven to be significantly faster than <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>torch.nn.DataParallel</code></a> for single-node multi-GPU data parallel training.</p>
<p>Here is how to use it: on each host with N GPUs, you should spawn up N processes, while ensuring that each process invidually works on a single GPU from 0 to N-1. Therefore, it is your job to ensure that your training script operates on a single given GPU by calling:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.cuda.set_device(i)

</code></pre>
<p>where i is from 0 to N-1. In each process, you should refer the following to construct this module:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(backend='nccl', world_size=4, init_method='...')
&gt;&gt;&gt; model = DistributedDataParallel(model, device_ids=[i], output_device=i)

</code></pre>
<p>In order to spawn up multiple processes per node, you can use either <code>torch.distributed.launch</code> or <code>torch.multiprocessing.spawn</code></p>
<p>Note</p>
<p><code>nccl</code> backend is currently the fastest and highly recommended backend to be used with Multi-Process Single-GPU distributed training and this applies to both single-node and multi-node distributed training</p>
<p>Warning</p>
<p>This module works only with the <code>gloo</code> and <code>nccl</code> backends.</p>
<p>Warning</p>
<p>Constructor, forward method, and differentiation of the output (or a function of the output of this module) is a distributed synchronization point. Take that into account in case different processes might be executing different code.</p>
<p>Warning</p>
<p>This module assumes all parameters are registered in the model by the time it is created. No parameters should be added nor removed later. Same applies to buffers.</p>
<p>Warning</p>
<p>This module assumes all parameters are registered in the model of each distributed processes are in the same order. The module itself will conduct gradient all-reduction following the reverse order of the registered parameters of the model. In other wise, it is users' responsibility to ensure that each distributed process has the exact same model and thus the exact parameter registeration order.</p>
<p>Warning</p>
<p>This module assumes all buffers and gradients are dense.</p>
<p>Warning</p>
<p>This module doesn't work with <a href="autograd.html#torch.autograd.grad" title="torch.autograd.grad"><code>torch.autograd.grad()</code></a> (i.e. it will only work if gradients are to be accumulated in <code>.grad</code> attributes of parameters).</p>
<p>Warning</p>
<p>If you plan on using this module with a <code>nccl</code> backend or a <code>gloo</code> backend (that uses Infiniband), together with a DataLoader that uses multiple workers, please change the multiprocessing start method to <code>forkserver</code> (Python 3 only) or <code>spawn</code>. Unfortunately Gloo (that uses Infiniband) and NCCL2 are not fork safe, and you will likely experience deadlocks if you don't change this setting.</p>
<p>Warning</p>
<p>Forward and backward hooks defined on <code>module</code> and its submodules won't be invoked anymore, unless the hooks are initialized in the <code>forward()</code> method.</p>
<p>Warning</p>
<p>You should never try to change your model's parameters after wrapping up your model with DistributedDataParallel. In other words, when wrapping up your model with DistributedDataParallel, the constructor of DistributedDataParallel will register the additional gradient reduction functions on all the parameters of the model itself at the time of construction. If you change the model's parameters after the DistributedDataParallel construction, this is not supported and unexpected behaviors can happen, since some parameters' gradient reduction functions might not get called.</p>
<p>Note</p>
<p>Parameters are never broadcast between processes. The module performs an all-reduce step on gradients and assumes that they will be modified by the optimizer in all processes in the same way. Buffers (e.g. BatchNorm stats) are broadcast from the module in process of rank 0, to all other replicas in the system in every iteration.</p>
<p>Parameters: </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – module to be parallelized</li>
<li><strong>device_ids</strong> (<em>list of python:int</em> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – CUDA devices (default: all devices)</li>
<li><strong>output_device</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a> <em>or</em> <a href="tensor_attributes.html#torch.torch.device" title="torch.torch.device"><em>torch.device</em></a>) – device location of output (default: device_ids[0])</li>
<li><strong>broadcast_buffers</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a>) – flag that enables syncing (broadcasting) buffers of the module at beginning of the forward function. (default: True)</li>
<li><strong>process_group</strong> – the process group to be used for distributed data all-reduction. If None, the default process group, which is created by <code>torch.distributed.init_process_group</code>, will be used. (default: None)</li>
<li><strong>bucket_cap_mb</strong> – DistributedDataParallel will bucket parameters into multiple buckets so that gradient reduction of each bucket can potentially overlap with backward computation. bucket_cap_mb controls the bucket size in MegaBytes (MB) (default: 25)</li>
<li><strong>check_reduction</strong> – when setting to True, it enables DistributedDataParallel to automatically check if the previous iteration's backward reductions were successfully issued at the beginning of every iteration's forward function. You normally don't need this option enabled unless you are observing weird behaviors such as different ranks are getting different gradients, which should not happen if DistributedDataParallel is corrected used. (default: False)</li>
</ul>
<table>
<thead>
<tr>
<th>Variables:</th>
<th><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>Module</em></a>) – the module to be parallelized</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<pre><code class="language-py">Example::
</code></pre>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(backend='nccl', world_size=4, init_method='...')
&gt;&gt;&gt; net = torch.nn.DistributedDataParallel(model, pg)

</code></pre>
<h3 id="distributeddataparallelcpu">DistributedDataParallelCPU</h3>
<pre><code class="language-py">class torch.nn.parallel.DistributedDataParallelCPU(module)
</code></pre>
<p>Implements distributed data parallelism for CPU at the module level.</p>
<p>This module supports the <code>mpi</code> and <code>gloo</code> backends.</p>
<p>This container parallelizes the application of the given module by splitting the input across the specified devices by chunking in the batch dimension. The module is replicated on each machine, and each such replica handles a portion of the input. During the backwards pass, gradients from each node are averaged.</p>
<p>This module could be used in conjunction with the DistributedSampler, (see :class <code>torch.utils.data.distributed.DistributedSampler</code>) which will load a subset of the original datset for each node with the same batch size. So strong scaling should be configured like this:</p>
<p>n = 1, batch size = 12</p>
<p>n = 2, batch size = 64</p>
<p>n = 4, batch size = 32</p>
<p>n = 8, batch size = 16</p>
<p>Creation of this class requires the distributed package to be already initialized in the process group mode (see <a href="distributed.html#torch.distributed.init_process_group" title="torch.distributed.init_process_group"><code>torch.distributed.init_process_group()</code></a>).</p>
<p>Warning</p>
<p>Constructor, forward method, and differentiation of the output (or a function of the output of this module) is a distributed synchronization point. Take that into account in case different node might be executing different code.</p>
<p>Warning</p>
<p>This module assumes all parameters are registered in the model by the time it is created. No parameters should be added nor removed later.</p>
<p>Warning</p>
<p>This module assumes all gradients are dense.</p>
<p>Warning</p>
<p>This module doesn't work with <a href="autograd.html#torch.autograd.grad" title="torch.autograd.grad"><code>torch.autograd.grad()</code></a> (i.e. it will only work if gradients are to be accumulated in <code>.grad</code> attributes of parameters).</p>
<p>Warning</p>
<p>Forward and backward hooks defined on <code>module</code> and its submodules won't be invoked anymore, unless the hooks are initialized in the <code>forward()</code> method.</p>
<p>Note</p>
<p>Parameters are broadcast between nodes in the <strong>init</strong>() function. The module performs an all-reduce step on gradients and assumes that they will be modified by the optimizer in all nodes in the same way.</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>module</strong> – module to be parallelized</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; torch.distributed.init_process_group(world_size=4, init_method='...')
&gt;&gt;&gt; net = torch.nn.DistributedDataParallelCPU(model)

</code></pre>
<h2 id="utilities">Utilities</h2>
<h3 id="clip_grad_norm_">clip_grad_norm_</h3>
<pre><code class="language-py">torch.nn.utils.clip_grad_norm_(parameters, max_norm, norm_type=2)
</code></pre>
<p>Clips gradient norm of an iterable of parameters.</p>
<p>The norm is computed over all gradients together, as if they were concatenated into a single vector. Gradients are modified in-place.</p>
<p>Parameters: </p>
<ul>
<li><strong>parameters</strong> (<em>Iterable__[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>] or</em> <a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – an iterable of Tensors or a single Tensor that will have gradients normalized</li>
<li><strong>max_norm</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – max norm of the gradients</li>
<li><strong>norm_type</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – type of the used p-norm. Can be <code>'inf'</code> for infinity norm.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Total norm of the parameters (viewed as a single vector).</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="clip_grad_value_">clip_grad_value_</h3>
<pre><code class="language-py">torch.nn.utils.clip_grad_value_(parameters, clip_value)
</code></pre>
<p>Clips gradient of an iterable of parameters at specified value.</p>
<p>Gradients are modified in-place.</p>
<p>Parameters: </p>
<ul>
<li><strong>parameters</strong> (<em>Iterable__[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>] or</em> <a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – an iterable of Tensors or a single Tensor that will have gradients normalized</li>
<li><strong>clip_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a> <em>or</em> <a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a>) – maximum allowed value of the gradients The gradients are clipped in the range [-clip_value, clip_value]</li>
</ul>
<h3 id="parameters_to_vector">parameters_to_vector</h3>
<pre><code class="language-py">torch.nn.utils.parameters_to_vector(parameters)
</code></pre>
<p>Convert parameters to one vector</p>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>parameters</strong> (<em>Iterable__[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>]</em>) – an iterator of Tensors that are the parameters of a model.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>The parameters represented by a single vector</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<h3 id="vector_to_parameters">vector_to_parameters</h3>
<pre><code class="language-py">torch.nn.utils.vector_to_parameters(vec, parameters)
</code></pre>
<p>Convert one vector to the parameters</p>
<p>Parameters: </p>
<ul>
<li><strong>vec</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – a single vector represents the parameters of a model.</li>
<li><strong>parameters</strong> (<em>Iterable__[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>]</em>) – an iterator of Tensors that are the parameters of a model.</li>
</ul>
<h3 id="weight_norm">weight_norm</h3>
<pre><code class="language-py">torch.nn.utils.weight_norm(module, name='weight', dim=0)
</code></pre>
<p>Applies weight normalization to a parameter in the given module.</p>
<p><img alt="" src="../img/06160be4a838f9d6d20cabc64f32670e.jpg" /></p>
<p>Weight normalization is a reparameterization that decouples the magnitude of a weight tensor from its direction. This replaces the parameter specified by <code>name</code> (e.g. “weight”) with two parameters: one specifying the magnitude (e.g. “weight_g”) and one specifying the direction (e.g. “weight_v”). Weight normalization is implemented via a hook that recomputes the weight tensor from the magnitude and direction before every <code>forward()</code> call.</p>
<p>By default, with <code>dim=0</code>, the norm is computed independently per output channel/plane. To compute a norm over the entire weight tensor, use <code>dim=None</code>.</p>
<p>See <a href="https://arxiv.org/abs/1602.07868">https://arxiv.org/abs/1602.07868</a></p>
<p>Parameters: </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – dimension over which to compute the norm</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>The original module with the weight norm hook</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40), name='weight')
Linear (20 -&gt; 40)
&gt;&gt;&gt; m.weight_g.size()
torch.Size([40, 1])
&gt;&gt;&gt; m.weight_v.size()
torch.Size([40, 20])

</code></pre>
<h3 id="remove_weight_norm">remove_weight_norm</h3>
<pre><code class="language-py">torch.nn.utils.remove_weight_norm(module, name='weight')
</code></pre>
<p>Removes the weight normalization reparameterization from a module.</p>
<p>Parameters: </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
</ul>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; m = weight_norm(nn.Linear(20, 40))
&gt;&gt;&gt; remove_weight_norm(m)

</code></pre>
<h3 id="spectral_norm">spectral_norm</h3>
<pre><code class="language-py">torch.nn.utils.spectral_norm(module, name='weight', n_power_iterations=1, eps=1e-12, dim=None)
</code></pre>
<p>Applies spectral normalization to a parameter in the given module.</p>
<p><img alt="" src="../img/1ca46cc2506aac38bf00645f64b1a3e3.jpg" /></p>
<p>Spectral normalization stabilizes the training of discriminators (critics) in Generaive Adversarial Networks (GANs) by rescaling the weight tensor with spectral norm <img alt="" src="../img/2469b2bd2a1ab19ebfcee223dcb52bb1.jpg" /> of the weight matrix calculated using power iteration method. If the dimension of the weight tensor is greater than 2, it is reshaped to 2D in power iteration method to get spectral norm. This is implemented via a hook that calculates spectral norm and rescales weight before every <code>forward()</code> call.</p>
<p>See <a href="https://arxiv.org/abs/1802.05957">Spectral Normalization for Generative Adversarial Networks</a> .</p>
<p>Parameters: </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
<li><strong>n_power_iterations</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – number of power iterations to calculate spectal norm</li>
<li><strong>eps</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – epsilon for numerical stability in calculating norms</li>
<li><strong>dim</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – dimension corresponding to number of outputs, the default is 0, except for modules that are instances of ConvTranspose1/2/3d, when it is 1</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>The original module with the spectal norm hook</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>Example:</p>
<pre><code class="language-py">&gt;&gt;&gt; m = spectral_norm(nn.Linear(20, 40))
Linear (20 -&gt; 40)
&gt;&gt;&gt; m.weight_u.size()
torch.Size([20])

</code></pre>
<h3 id="remove_spectral_norm">remove_spectral_norm</h3>
<pre><code class="language-py">torch.nn.utils.remove_spectral_norm(module, name='weight')
</code></pre>
<p>Removes the spectral normalization reparameterization from a module.</p>
<p>Parameters: </p>
<ul>
<li><strong>module</strong> (<a href="#torch.nn.Module" title="torch.nn.Module"><em>nn.Module</em></a>) – containing module</li>
<li><strong>name</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.7)"><em>str</em></a><em>,</em> <em>optional</em>) – name of weight parameter</li>
</ul>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; m = spectral_norm(nn.Linear(40, 10))
&gt;&gt;&gt; remove_spectral_norm(m)

</code></pre>
<h3 id="packedsequence">PackedSequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.PackedSequence(data, batch_sizes=None)
</code></pre>
<p>Holds the data and list of <code>batch_sizes</code> of a packed sequence.</p>
<p>All RNN modules accept packed sequences as inputs.</p>
<p>Note</p>
<p>Instances of this class should never be created manually. They are meant to be instantiated by functions like <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a>.</p>
<p>Batch sizes represent the number elements at each sequence step in the batch, not the varying sequence lengths passed to <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a>. For instance, given data <code>abc</code> and <code>x</code> the <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> would contain data <code>axbc</code> with <code>batch_sizes=[2,1,1]</code>.</p>
<p>| Variables: | </p>
<ul>
<li><strong>data</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Tensor containing packed sequence</li>
<li><strong>batch_sizes</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – Tensor of integers holding information about the batch size at each sequence step</li>
</ul>
<h3 id="pack_padded_sequence">pack_padded_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pack_padded_sequence(input, lengths, batch_first=False)
</code></pre>
<p>Packs a Tensor containing padded sequences of variable length.</p>
<p>Input can be of size <code>T x B x *</code> where <code>T</code> is the length of the longest sequence (equal to <code>lengths[0]</code>), <code>B</code> is the batch size, and <code>*</code> is any number of dimensions (including 0). If <code>batch_first</code> is True <code>B x T x *</code> inputs are expected.</p>
<p>The sequences should be sorted by length in a decreasing order, i.e. <code>input[:,0]</code> should be the longest sequence, and <code>input[:,B-1]</code> the shortest one.</p>
<p>Note</p>
<p>This function accepts any input that has at least two dimensions. You can apply it to pack the labels, and use the output of the RNN with them to compute the loss directly. A Tensor can be retrieved from a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> object by accessing its <code>.data</code> attribute.</p>
<p>Parameters: </p>
<ul>
<li><strong>input</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – padded batch of variable length sequences.</li>
<li><strong>lengths</strong> (<a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a>) – list of sequences lengths of each batch element.</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, the input is expected in <code>B x T x *</code> format.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> object</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pad_packed_sequence">pad_packed_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pad_packed_sequence(sequence, batch_first=False, padding_value=0.0, total_length=None)
</code></pre>
<p>Pads a packed batch of variable length sequences.</p>
<p>It is an inverse operation to <a href="#torch.nn.utils.rnn.pack_padded_sequence" title="torch.nn.utils.rnn.pack_padded_sequence"><code>pack_padded_sequence()</code></a>.</p>
<p>The returned Tensor's data will be of size <code>T x B x *</code>, where <code>T</code> is the length of the longest sequence and <code>B</code> is the batch size. If <code>batch_first</code> is True, the data will be transposed into <code>B x T x *</code> format.</p>
<p>Batch elements will be ordered decreasingly by their length.</p>
<p>Note</p>
<p><code>total_length</code> is useful to implement the <code>pack sequence -&amp;gt; recurrent network -&amp;gt; unpack sequence</code> pattern in a <a href="#torch.nn.Module" title="torch.nn.Module"><code>Module</code></a> wrapped in <a href="#torch.nn.DataParallel" title="torch.nn.DataParallel"><code>DataParallel</code></a>. See <a href="notes/faq.html#pack-rnn-unpack-with-data-parallelism">this FAQ section</a> for details.</p>
<p>Parameters: </p>
<ul>
<li><strong>sequence</strong> (<em>PackedSequence</em>) – batch to pad</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – if <code>True</code>, the output will be in <code>B x T x *</code> format.</li>
<li><strong>padding_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – values for padded elements.</li>
<li><strong>total_length</strong> (<a href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.7)"><em>int</em></a><em>,</em> <em>optional</em>) – if not <code>None</code>, the output will be padded to have length <code>total_length</code>. This method will throw <a href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.7)"><code>ValueError</code></a> if <code>total_length</code> is less than the max sequence length in <code>sequence</code>.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Tuple of Tensor containing the padded sequence, and a Tensor containing the list of lengths of each sequence in the batch.</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pad_sequence">pad_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pad_sequence(sequences, batch_first=False, padding_value=0)
</code></pre>
<p>Pad a list of variable length Tensors with zero</p>
<p><code>pad_sequence</code> stacks a list of Tensors along a new dimension, and pads them to equal length. For example, if the input is list of sequences with size <code>L x *</code> and if batch_first is False, and <code>T x B x *</code> otherwise.</p>
<p><code>B</code> is batch size. It is equal to the number of elements in <code>sequences</code>. <code>T</code> is length of the longest sequence. <code>L</code> is length of the sequence. <code>*</code> is any number of trailing dimensions, including none.</p>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; from torch.nn.utils.rnn import pad_sequence
&gt;&gt;&gt; a = torch.ones(25, 300)
&gt;&gt;&gt; b = torch.ones(22, 300)
&gt;&gt;&gt; c = torch.ones(15, 300)
&gt;&gt;&gt; pad_sequence([a, b, c]).size()
torch.Size([25, 3, 300])

</code></pre>
<p>Note</p>
<p>This function returns a Tensor of size <code>T x B x *</code> or <code>B x T x *</code> where <code>T</code> is the length of the longest sequence. This function assumes trailing dimensions and type of all the Tensors in sequences are same.</p>
<p>Parameters: </p>
<ul>
<li><strong>sequences</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em>[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>]</em>) – list of variable length sequences.</li>
<li><strong>batch_first</strong> (<a href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.7)"><em>bool</em></a><em>,</em> <em>optional</em>) – output will be in <code>B x T x *</code> if True, or in <code>T x B x *</code> otherwise</li>
<li><strong>padding_value</strong> (<a href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.7)"><em>float</em></a><em>,</em> <em>optional</em>) – value for padded elements. Default: 0.</li>
</ul>
<table>
<thead>
<tr>
<th>Returns:</th>
<th>Tensor of size <code>T x B x *</code> if <code>batch_first</code> is <code>False</code>. Tensor of size <code>B x T x *</code> otherwise</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="pack_sequence">pack_sequence</h3>
<pre><code class="language-py">torch.nn.utils.rnn.pack_sequence(sequences)
</code></pre>
<p>Packs a list of variable length Tensors</p>
<p><code>sequences</code> should be a list of Tensors of size <code>L x *</code>, where <code>L</code> is the length of a sequence and <code>*</code> is any number of trailing dimensions, including zero. They should be sorted in the order of decreasing length.</p>
<p>Example</p>
<pre><code class="language-py">&gt;&gt;&gt; from torch.nn.utils.rnn import pack_sequence
&gt;&gt;&gt; a = torch.tensor([1,2,3])
&gt;&gt;&gt; b = torch.tensor([4,5])
&gt;&gt;&gt; c = torch.tensor([6])
&gt;&gt;&gt; pack_sequence([a, b, c])
PackedSequence(data=tensor([ 1,  4,  6,  2,  5,  3]), batch_sizes=tensor([ 3,  2,  1]))

</code></pre>
<table>
<thead>
<tr>
<th>Parameters:</th>
<th><strong>sequences</strong> (<a href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.7)"><em>list</em></a><em>[</em><a href="tensors.html#torch.Tensor" title="torch.Tensor"><em>Tensor</em></a><em>]</em>) – A list of sequences of decreasing length.</th>
</tr>
</thead>
<tbody>
<tr>
<td>Returns:</td>
<td>a <a href="#torch.nn.utils.rnn.PackedSequence" title="torch.nn.utils.rnn.PackedSequence"><code>PackedSequence</code></a> object</td>
</tr>
<tr>
<td>---</td>
<td>---</td>
</tr>
</tbody>
</table>
<hr/>
<div align="center">
  <p><a href="https://www.apachecn.org/" target="_blank"><font face="KaiTi" size="6" color="red">我们一直在努力</font></a><p>
  <p><a href="https://github.com/apachecn/pytorch-doc-zh" target="_blank">apachecn/pytorch-doc-zh</a></p>
  <p><a target="_blank" href="https://qm.qq.com/cgi-bin/qm/qr?k=5u_aAU-YlY3fH-m8meXTJzBEo2boQIUs&jump_from=webapi&authKey=CVZcReMt/vKdTXZBQ8ly+jWncXiSzzWOlrx5hybX5pSrKu6s0fvGX54+vHHlgYNt"><img border="0" src="https://pub.idqqimg.com/wpa/images/group.png" alt="【布客】中文翻译组" title="【布客】中文翻译组"></a></p>
  <p><span id="cnzz_stat_icon_1275211409"></span></p>
  <!-- <p><a href="https://get.brightdata.com/apachecn" target="_blank"><img src="/assets/images/partnerstack.gif" /></a><p> -->
  <div class="wwads-cn wwads-horizontal" data-id="206" style="max-width:680px"></div>
  <div style="text-align:center;margin:0 0 10.5px;">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-3565452474788507" crossorigin="anonymous"></script>
    <!-- ApacheCNWide -->
    <ins class="adsbygoogle"
        style="display:inline-block;width:680px;height:90px"
        data-ad-client="ca-pub-3565452474788507"
        data-ad-slot="2543897000"></ins>
    <script>
        (adsbygoogle = window.adsbygoogle || []).push({});
    </script>
  </div>
</div>
<hr/>
<!-- 来必力City版安装代码 -->
<div id="lv-container" data-id="city" data-uid="MTAyMC81ODA2NC8zNDUyNw==">
  <script type="text/javascript">
  (function(d, s) {
      var j, e = d.getElementsByTagName(s)[0];

      if (typeof LivereTower === 'function') { return; }

      j = d.createElement(s);
      j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
      j.async = true;

      e.parentNode.insertBefore(j, e);
  })(document, 'script');
  </script>
<noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
</div>
<!-- City版安装代码已完成 -->






                
              </article>
            </div>
          
          
        </div>
        
      </main>
      
        <footer class="md-footer">
  
    
      
      <nav class="md-footer__inner md-grid" aria-label="Footer" >
        
          
          <a href="../storage/" class="md-footer__link md-footer__link--prev" aria-label="Previous: torch.Storage" rel="prev">
            <div class="md-footer__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11h12Z"/></svg>
            </div>
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Previous
              </span>
              <div class="md-ellipsis">
                torch.Storage
              </div>
            </div>
          </a>
        
        
          
          <a href="../nn_functional/" class="md-footer__link md-footer__link--next" aria-label="Next: torch.nn.functional" rel="next">
            <div class="md-footer__title">
              <span class="md-footer__direction">
                Next
              </span>
              <div class="md-ellipsis">
                torch.nn.functional
              </div>
            </div>
            <div class="md-footer__button md-icon">
              <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M4 11v2h12l-5.5 5.5 1.42 1.42L19.84 12l-7.92-7.92L10.5 5.5 16 11H4Z"/></svg>
            </div>
          </a>
        
      </nav>
    
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright" style="text-align: center; width: 100%;">
  
  
    <div>
      <div style="margin:0 0 10.5px;"><script type="text/javascript">var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");document.write(unescape("%3Cspan id='cnzz_stat_icon_1275211409'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s5.cnzz.com/z_stat.php%3Fid%3D1275211409%26online%3D1%26show%3Dline' type='text/javascript'%3E%3C/script%3E"));</script></div>
      <p>Copyright © 2023 学习网站 <a href="http://beian.miit.gov.cn" target="_blank">京ICP备19016010号-1</a><br/>网站由 <a href="https://apachecn.org/cooperate/">@片刻小哥哥</a> 提供支持 | 联系QQ/微信: 529815144 请注明来意！</p>
    </div>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy", "content.action.edit", "content.action.view", "navigation.footer"], "search": "../../assets/javascripts/workers/search.208ed371.min.js", "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}}</script>
    
    
  
      <script src="../../assets/javascripts/bundle.b425cdc4.min.js"></script>
      
        
          <script src="../../javascripts/mathjax.js"></script>
        
      
        
          <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
        
      
        
          <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
        
      
    
  <script src="../../assets/javascripts/custom.a7283b5f.min.js"></script>

  </body>
</html>